function initshape(index, x, y) {    
    let color = getRandomColor();   
    shape = {
        index: index, id: index, areaindex: 0, areaid: 0, partsrno: 0, partid: 0, partname: '', materialid: 0, isactive: 1,
        spactive: 0, mode: 'shape', spindex: -1, slabid: 0, slabindex: 0, unitcount: 1, dupcount: 0, tscale: zscale, layout: 1,
        x: x, y: y, tx: 0, ty: 0, h: sdh, angle: 0, color: color, opoints: [], sides: [], seams: [], slabparts: [], slabsplashs: [], labels: []
    };
    shape.opoints.push([x, y]);
}
function initpartshape31(mx, my) {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let partsrno = getlastactivepartsrno() + 1;
    let index = area.PartList.length;
    initshape(index, mx, my);    
    shape.areaid = area.ID;
    shape.areaindex = areaindex + 1;
    shape.unitcount = area.NoOfUnits;
    shape.partsrno = partsrno;    
    setshapegroups31(index, 'shape', 'initpartshape31');
}
function setdrawshape31(index, partsrno, areaid, smode, source) {
    if (shape == undefined) { return;}
    source += ":setdrawshape31";
    let areaindex = getareaindex();
    if (bdraw) { onendshapedraw(source); }
    if (shape.index != undefined && shape.index != index) { removeshapecorners(0, source); }
    //console.log(shape.index, index, partsrno, areaid, smode, source);
    shape = getpartshapebyareapartsrno(partsrno, areaid);
    if (shape!=undefined && shape.sides != undefined) {       
        shape.index = index;
        shape.areaid = areaid;
        shape.areaindex = areaindex + 1;
        shape.partsrno = partsrno;
        ActionSelectPart(partsrno);
        setshapegroups31(index, smode, source);
    }
}
function setduplicateshape31(dupcount) {
    //let areaindex = getareaindex();
    //let partlen = getpartlength(areaindex);
    //for (let i = 0; i < dupcount; i++) {
    //    duplicateshape31(partlen + i);
    //    ActionDuplicateShape('setduplicateshape31');
    //}   
    ActionDuplicateShape('setduplicateshape31', dupcount);//for loop moved to quotebride because timeout..and scope apply..
}
function duplicateshape31(index) {
    shape = JSON.parse(JSON.stringify(shape));
    shape.index = index;    
    shape.color = getRandomColor();
    shape.materialid = getpartmaterialidbyareapartid(shape.partid, shape.partsrno, shape.areaid);
    shape.partsrno = (index + 1);
    shape.partid = 0;
    shape.tx += 10, shape.ty += 10;
    shape.slabparts = [];   
    for (let j = 0; j < shape.sides.length; j++) {resetduplicateshapesideitems(shape.sides[j], shape.index);}
    drawshape32(index, 'shape', 'duplicateshape31');    
}
function drawshape31(index, partsrno, areaid, mode, source) {
    source += ':drawshape31';
    setdrawshape31(index, partsrno, areaid, mode, source);  
    if (shape != undefined) {
        shapesides(source);
        transformshape();
        if (shape.angle != 0) { rotateshape(0, index, shape.angle, source); }
    }
}
function drawshape32(index, smode, source) {
    source += ':drawshape32';
    setshapegroups31(index, smode, source);
    shapesides(source);
    transformshape();
    if (shape.angle != 0) { rotateshape(0, index, shape.angle, source); }
}
function setshapegroups31(index, smode, source) {    
    if (shape != undefined) {
        shape.mode = smode;
        let sindex = shape.index, partsrno = shape.partsrno, areaid = shape.areaid, materialid = shape.materialid,
        spindex = shape.spindex, spsideindex = shape.spsideindex, spseamindex = shape.spseamindex, startsideindex = shape.startsideindex, startseamindex = shape.startseamindex, endsideindex = shape.endsideindex, endseamindex = shape.endseamindex;
        let areashapeindex = areaid + "" + index;
        if (smode == 'print') {
            shapeouterg = prshapesg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = prshapesg.append("g").attr("id", smode + "outer" + areashapeindex); }           
        } else if (smode == 'shape') {
            shapeouterg = shapesg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = shapesg.append("g").attr("id", smode + "outer" + areashapeindex); }
            shapeouterg.call(shapedrag);
        } else if (smode == 'slabpart') {
            shapeouterg = mslabpartsg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = mslabpartsg.append("g").attr("id", smode + "outer" + areashapeindex); }
            shapeouterg.call(shapedrag);
        }
        else if (smode == 'shapedg') {
            shapeouterg = mdgslabpartsg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = mdgslabpartsg.append("g").attr("id", smode + "outer" + areashapeindex); }         
        }
        shapeouterg.attr("id", smode + "outer" + areashapeindex).attr("index", index).attr("sindex", sindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
        if (smode == 'slabpart') {
            shapeouterg.attr("spindex", spindex).attr("spseamindex", spseamindex).attr("spsideindex", spsideindex)
                .attr("startseamindex", startseamindex).attr("startsideindex", startsideindex).attr("endseamindex", endseamindex).attr("endsideindex", endsideindex);
        }
        setshapeinnergroups31(index, areaid, smode, source);
    }
}
function setshapeinnergroups31(index, areaid, smode, source) {
    let areashapeindex = areaid + "" + index;
    shapeg = shapeouterg.select("#" + smode + areashapeindex);
    if (shapeg.empty()) { shapeg = shapeouterg.append("g").attr("id", smode + areashapeindex); }
    shapepathg = shapeg.select("#" + smode + "pathg" + index); if (shapepathg.empty()) { shapepathg = shapeg.append("g").attr("id", smode + "pathg" + index); }
    sidesg = shapeg.select("#" + smode + "sidesg" + index); if (sidesg.empty()) { sidesg = shapeg.append("g").attr("id", smode + "sidesg" + index); }
    cornersg = shapeg.select("#" + smode + "cornersg" + index); if (cornersg.empty()) { cornersg = shapeg.append("g").attr("id", smode + "cornersg" + index); }
    sideshapesg = shapeg.select("#" + smode + "sideshapesg" + index); if (sideshapesg.empty()) { sideshapesg = shapeg.append("g").attr("id", smode + "sideshapesg" + index); }
    splashsg = shapeg.select("#" + smode + "splashsg" + index); if (splashsg.empty()) { splashsg = shapeg.append("g").attr("id", smode + "splashsg" + index); }
    cutoutsg = shapeg.select("#" + smode + "cutoutsg" + index); if (cutoutsg.empty()) { cutoutsg = shapeg.append("g").attr("id", smode + "cutoutsg" + index); }
    seamsg = shapeg.select("#" + smode + "seamsg" + index); if (seamsg.empty()) { seamsg = shapeg.append("g").attr("id", smode + "seamsg" + index); }
    anglehandlesg = shapeg.select("#" + smode + "anglehandlesg" + index); if (anglehandlesg.empty()) { anglehandlesg = shapeg.append("g").attr("id", smode + "anglehandlesg" + index); }    
}
function setpanmode() {
    switchsvgzoom32();  
}
function setdrawmode(dmode) {
    let source = 'setdrawmode';
    if (bdraw) { onendshapedraw(source); }
    drawmode = dmode; 
    if (drawmode != 2) { removeshapecorners(0, source); }   
}
function drawcountershape(type) {
    shapetype = type;
    setdrawmode(1);
}
function setcornertype(type, itemid) {
    cornertype = parseInt(type);
    cornertypeid = parseInt(itemid);
    setdrawmode(2);
    if (shape.mode == 'shape') {
        onsetcornertype(shape.index);
    }
}
function setsideshapetype(typeid, itemid) {
    sideshapetype = parseInt(itemid);
    sideshapetypeid = parseInt(typeid);
    setdrawmode(3);
}
function splashapronheightclick(dh, typeid) {
    splheight = parseFloat($('#txtsplashapronheight').val());
    splheight += dh;
    if (splheight <= 0) { splheight = splashminh; }
    $('#txtsplashapronheight').val(splheight);
    if (typeid == 0) {//spalsh
        setsplashtype(0, splheight); countersidemode = typeid;
    } else if (typeid == 1) {//apron
        setaprontype(splheight, 0, 1);
    } else if (typeid == 2) {//mitered
        setaprontype(splheight, 0, 2);
    } else if (typeid == 3) {//laminated
        setaprontype(splheight, 0, 3);
    }
}
function setsplashtype(typeid, height) {
    edgetype = linetxt == 'F' ? 'S' : 'U'; edgetypeid = typeid; splheight = height == 0 ? splashminh : height;
    setdrawmode(4);
}
function setedgetype(type, typeid, unittypeid) {
    //console.log(type, typeid, unittypeid);
    edgetype = type;
    edgetypeid = parseInt(typeid);    
    setdrawmode(5);
}
function setcutouttype(type, itemid) {
    cutouttype = type;
    cutoutinfo = getpricebookcutoutbyid(itemid);
    if (cutoutinfo.Code == null) { cutoutinfo.Code = ""; }
    setdrawmode(6);
}
function setsinkcutouttype(type, itemid) {
    let sink = getpricebooksinkcutoutbyid(itemid);
    if (sink != '' && sink.CutoutInfo != '') { //sink with cutout
        cutoutinfo = sink.CutoutInfo; cutoutinfo.SinkID = sink.ID; cutouttype = cutoutinfo.SinkCode;
        setdrawmode(6);
    } else {//sink only
        onaddpartsinkcutout31(itemid, '');
    }
}
function setseamtype(type) {
    seamtype = type;
    removeanglehandles();
    setdrawmode(7);
}
function setaprontype(dh, typeid, sidemode) {    
    splheight = dh == 0 ? splashminh : dh;
    if (sidemode == 1) { edgetype = "A"; } else if (sidemode == 2) { edgetype = "M"; } else if (sidemode == 3) { edgetype = "L"; }
    edgetypeid = parseInt(typeid); countersidemode = sidemode;
    setdrawmode(8);
}
function setshapetext() {
    setdrawmode(9);
}
function setlayoutmode() {    
    let mode = layoutmode == 1 ? 2 : 1;
    onsetlayoutmode(mode);
}
function setinnersizemode() {
    innersizemode = innersizemode == 0 ? 1 : 0;
    let innersizeclass = innersizemode == 1 ? "fa fa-toggle-on active1" : "fa fa-toggle-on fa-rotate-180 inactive1";
    $('#innersize_mode').attr('class', innersizeclass);    
    shapesides();
}
function ondrawshape(mx, my) {
    let stx = mx * (1 - zscale), sty = my * (1 - zscale);
    initpartshape31(mx, my);
    shape.tx = stx / zscale, shape.ty = sty / zscale;
    transformshape();
    if (shapetype == 0) {       
        drawshapedrawhandle(mx, my);
    } else {        
        drawpredefinedshapes(mx, my);
    }    
    shapetype = 0;
}
function drawpredefinedshapes(mx, my) {
    let source = 'drawpredefinedshapes';
    if (shapetype == 1) { drawrectshape(mx, my, source); }
    else if (shapetype == 2) { drawrlshape(mx, my, source); }
    else if (shapetype == 3) { drawllshape(mx, my, source); }
    else if (shapetype == 4) { drawushape(mx, my, source); }
    else if (shapetype == 5) { drawcircleshape(mx, my, source); }    
    setsideedge(shape.sides.length - 1, 3, linetxt, 0);    
    shapesides(source);
    //setdrawmode(0);
    ActionShape(source);   
   // console.log(shape.index, shape.sides[0].edges.length, JSON.stringify(shape.sides[0].edges), source);
}
function drawrectshape(x1, y1, source) {
    let angle = 0, w = (sdh * 5);
    w = applymminchfact(w, 3, 2, source);
    let npt = rotate_point1(x1, y1, -1, angle, w);
    let x2 = npt.dx, y2 = npt.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);  
}
function drawrlshape(x1, y1, source) {
    let angle1 = 90, angle2 = 0, w1 = (sdh * 2.5), w2 = (sdh * 2.5);
    w1 = applymminchfact(w1, 3, 2, source);
    w2 = applymminchfact(w2, 3, 2, source);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);   
}
function drawllshape(x1, y1, source) {
    let angle1 = 0, angle2 = 270, w1 = (sdh * 2.5), w2 = (sdh * 2.5);
    w1 = applymminchfact(w1, 3, 2, source);
    w2 = applymminchfact(w2, 3, 2, source);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);  
}
function drawushape(x1, y1, source) {
    let angle1 = 90, angle2 = 0, angle3 = 270, w1 = (sdh * 2.5), w2 = (sdh * 4), w3 = (sdh * 2.5);
    w1 = applymminchfact(w1, 3, 2, source);
    w2 = applymminchfact(w2, 3, 2, source);
    w3 = applymminchfact(w3, 3, 2, source);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);
    let npt3 = rotate_point1(x3, y3, -1, angle3, w3);
    let x4 = npt3.dx, y4 = npt3.dy;
    setnewshapeside(x4, y4);
    shape.opoints.push([x4, y4]);   
}
function drawcircleshape(x1, y1) {
    let angle = 0, w = (sdh * 3);
    shape.h = w;
    let r = w / 2;
    let npt = rotate_point1(x1, y1, -1, angle, w);
    let x2 = npt.dx, y2 = npt.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);   
    resetsidecorners32(r, r, r, 2, 10, 'drawcircleshape');
}
function svgclick() {
    //d3.event.preventDefault();
    let source = 'svgclick';
    //console.log(source, drawmode);
    removeshapecorners(0, source);
    if (editmode == 1) { reseteditmode(source); }
    if (bdraw) { onendshapedraw(source);}
    if (d3.event.srcElement.tagName == 'svg' || d3.event.srcElement.id == 'shapesrect') {
        removehandles();
        let m = d3.mouse(this);
        let mx = Math.round(m[0]), my = Math.round(m[1]);
        if (drawmode == 1) {
            ondrawshape(mx, my); 
        } else if (drawmode == 9) {onsetarealabel(mx, my, -1, 1, source); setdrawmode(0);            
        } else { setdrawmode(0); }
    }
    //  ActionDrawSideHide();
}
function svgblur() {
    setdrawmode(0);
}
function svgcontextmenu() {
     //console.log('svgcontextmenu');
     d3.event.preventDefault();
}
function drawshapedrawhandle(x, y) {
    let x1 = 0, y1 = 0, x2 = 0, y2 = 0, h = shape.h;
    x1 = x - h / 2, x2 = x + h / 2, y1 = y2 = y;
    let sclass = 'shapesideblue';
    sclass = colorflag == 1 ? 'shapesideblue' : 'shapesidegreen1';
    drawhandlesg = shapeouterg.select("#drawhandlesg");
    if (drawhandlesg.empty()) {drawhandlesg = shapeouterg.append("g").attr("id", "drawhandlesg").call(shapedraw);}
    let shapeline = drawhandlesg.select("#" + shape.mode +  "drawhandle1");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "drawhandle1"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);
    x1 = x2 = x, y1 = y - h / 2, y2 = y + h / 2;
    shapeline = drawhandlesg.select("#" + shape.mode + "drawhandle2");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "drawhandle2"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);   
}
function onendshapedraw(source) {
    source += ':' + 'onendshapedraw';
    bdraw = false;
    removedrawhandles();
    drawshapeendside();
    setsideedge(shape.sides.length - 1, 3, linetxt, 0);
    resetshapesideedgeswidth34(source);
    setdrawmode(0);
    ActionShape(source);    
}
function shapedrawstarted() {
    bdraw = true;
    let index = shape.opoints.length - 1;
    let x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];    
    drawshapedrawhandle(x1, y1);   
    reseteditmode('shapedrawstarted');
}
function shapedrawed() {
    let source = 'shapedrawed';
    let index = shape.opoints.length - 1;
    let x0 = 0, y0 = 0, x1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    if (index > 0) { x0 = shape.opoints[index - 1][0], y0 = shape.opoints[index - 1][1]; }
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if (Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh) {
        //console.log(index, x0, y0, x1, y1, x2, y2);
        setnewshapeside(x2, y2);
        shapesides(source);
    }
   // console.log(index, shape.index, x1, x2, y1, y2, source);
    drawshapedrawhandle(x2, y2);   
}
function shapedrawended() {
    let source = 'shapedrawended';
    let index = shape.opoints.length - 1;
    let x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    if (index > 0) { x0 = shape.opoints[index - 1][0], y0 = shape.opoints[index - 1][1]; }
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if ((Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh)) {
        if (index == 0) { shape.opoints.push([x2, y2]); } else {
            if (((x0 === x2) && (x1 === x2)) || ((y0 === y2) && (y1 === y2))) {
                shape.opoints[index][0] = x2;
                shape.opoints[index][1] = y2;
            } else {
                shape.opoints.push([x2, y2]);
            }
        }
    }
    //console.log(index, shape.index, x1, x2, y1, y2, source);
}
function onshape() {   
    d3.event.stopPropagation();
    bdrag = false;
    let source = 'onshape';
    let sindex1 = shape.index;
    let index = parseInt(this.getAttribute("index"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let spseamindex = parseInt(this.getAttribute("spseamindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let startseamindex = parseInt(this.getAttribute("startseamindex"));
    let startsideindex = parseInt(this.getAttribute("startsideindex"));
    let endseamindex = parseInt(this.getAttribute("endseamindex"));
    let endsideindex = parseInt(this.getAttribute("endsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    let m = d3.mouse(this);    
    if (mode == 'slabpart') {        
        if (drawmode == 7) {
            //console.log(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, drawmode, seamtype);
            if (seamtype != 2) {
                onsetslabpartshape31(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, source);
                onsetsideseam31(m[0], m[1], -1, index, sindex, seamtype, source); setdrawmode(0);
            } 
        }
    } else if (mode == 'shape') {
        //console.log(shape.index, sindex1, index, sindex, drawmode);
        if (sindex != sindex1) { setdrawshape31(sindex, partsrno, areaid, mode, source); }       
        if (drawmode == 2) {
            drawshapecorners(sindex, source);
        } else if (drawmode == 6) {
            onsetshapesidecutout(m[0], m[1], -1, index, sindex, source);
        } else if (drawmode == 9) {
            onsetshapelabel(m[0], m[1], -1, sindex, 2, source); setdrawmode(0);
        } else if (drawmode == 1) { }
        else { setdrawmode(0); }
    }
}
function onshapecontextmenu() {
    let source = 'onshapecontextmenu';
    if (bdraw) { onendshapedraw(source); return;}
    removeshapecorners(0, source);
    d3.event.preventDefault();
    let m = d3.mouse(this);
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let spseamindex = parseInt(this.getAttribute("spseamindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let startseamindex = parseInt(this.getAttribute("startseamindex"));
    let startsideindex = parseInt(this.getAttribute("startsideindex"));
    let endseamindex = parseInt(this.getAttribute("endseamindex"));
    let endsideindex = parseInt(this.getAttribute("endsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    //console.log(index, sindex, partsrno, areaid, mode);
    if (mode == 'shape') { setdrawshape31(sindex, partsrno, areaid, mode, source); }
    else if (mode == 'slabpart') {       
        onsetslabpartshape31(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, source);
    }
    drawshapecontrols(index, spsideindex, spindex, startseamindex, startsideindex, m[0], m[1]);
}
function onduplshapecounter(val, index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    let newdupcount = dupcount + parseInt(val);
    if (newdupcount == 0) { newdupcount = 1; }
    $('#shapectlduplinput' + shape.index).val(newdupcount);
}
function onduplicateshape(index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    if (shape.unitcount > 1) { shape.dupcount = parseInt(shape.dupcount) + dupcount; }
    setduplicateshape31(dupcount);
   // ActionDuplicateShape(partlen, dupcount, 'onduplicateshape');
}
function ondeleteshape(index) {
    removeshapetools();   
    deleteshape1(index, 'ondeleteshape');   
}
function deleteshape1(index, source) {
   deleteshape(index);   
   ActionShapeRemove(index, source);
}
function deleteshape(index) {    
    let areashapeindex =  shape.areaid + "" +  index;
    shapesg.select("#shapeouter" + areashapeindex).remove();
}
function resetduplicateshapesideitems(dupside, sindex) {
    dupside.sindex = sindex;
    for (var j = 0; j < dupside.edges.length; j++) {
        dupside.edges[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.splashs.length; j++) {
        dupside.splashs[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.corners.length; j++) {
        dupside.corners[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.cutouts.length; j++) {
        dupside.cutouts[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.sideshapes.length; j++) {
        dupside.sideshapes[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.seams.length; j++) {
        dupside.seams[j].sindex = sindex;
    }
}
function shapedragstarted() {
    let source = 'shapedragstarted';
    //console.log(bdraw, d3.event.sourceEvent.srcElement.tagName);
    if (bdraw) { onendshapedraw(source); return; }
   // if (drawmode != 0) { return;}
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        let source = 'shapedragstarted';
        removehandles();
        let index = parseInt(this.getAttribute("index"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid")); 
        let spindex = parseInt(this.getAttribute("spindex"));
        let spseamindex = parseInt(this.getAttribute("spseamindex"));
        let spsideindex = parseInt(this.getAttribute("spsideindex"));
        let startseamindex = parseInt(this.getAttribute("startseamindex"));
        let startsideindex = parseInt(this.getAttribute("startsideindex"));
        let endseamindex = parseInt(this.getAttribute("endseamindex"));
        let endsideindex = parseInt(this.getAttribute("endsideindex"));
        let mode = this.getAttribute("smode");
        //console.log(index, mode, shape.mode, shape.index, spindex, partsrno, areaid, 'shapedragstarted');
        if (mode == 'shape') {
           // if (drawmode != 2) {
                reseteditmode(source);                
                bdrag = true;
                setdrawshape31(index, partsrno, areaid, mode, source);
          //  }
        } else if (mode == 'slabpart') {          
            //if (drawmode != 7) {             
                bdrag = true;
                dragdx = Math.round(d3.event.x - shape.tx); dragdy = Math.round(d3.event.y - shape.ty);                
                reseteditmode(source);
                //console.log("index:" + index, "spindex:" + spindex, "startseamindex:" + startseamindex, "startsideindex:" + startsideindex, "partsrno:" + partsrno, "areaid:" + areaid, "mode:" + mode, "source:" + source);
                onsetslabpartshape31(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, source);
          //  }
        }
    }
}
function shapedragged() {
    let source='shapedragged';
    if (bdrag && shape!=undefined) {
        d3.event.sourceEvent.stopPropagation(); 
        let ndx = this.x || shape.tx;
        let ndy = this.y || shape.ty;
        ndx += d3.event.dx;
        ndy += d3.event.dy;
        let stx = shape.tx, sty = shape.ty;       
        if (shape.mode == 'shape') {
            let sgscale = getshapesgscale();
            shape.tx = Math.round(ndx), shape.ty = Math.round(ndy), shape.tscale = zscale;
            transformshape();
            //if (!isshapeinbounds32()) {
            //    shape.tx = stx, shape.ty = sty;
            //    transformshape();
            //}
        } else if (shape.mode == 'slabpart') {          
            ondragslabpartshape32(ndx, ndy, stx, sty, source);
        }
    }
}
function shapedragended() {
    let source = 'shapedragended';
    if (bdrag && shape != undefined) {       
        bdrag = false;
        if (shape.mode == 'slabpart') {          
            ondragendslabpart32(source);
            dragdx = 0, dragdy = 0;
            //isslabpartinbounds32(source);
        } else {           
            ActionUpdateShape(source);
        }
    }
}
function transformshape() {   
    if(shape.tx==undefined || shape.ty==undefined){return;}
    let ztx = shape.tx, zty = shape.ty, stscale = shape.tscale;    
    if (shape.mode == 'slabpart') { stscale = lzscale; shape.ltscale = stscale; } else { stscale = zscale; shape.tscale = stscale; }
    ztx = Math.round(ztx * stscale), zty = Math.round(zty * stscale);
   // console.log("sindex:" + shape.index, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "stscale:" + shape.tscale, "sx:" + shape.x, "sy:" + shape.y);
    let npt = [ztx, zty];   
    shapeouterg.attr('transform', 'translate(' + npt + ') scale(' + stscale + ')');
}
function onrotateshape(type, index, angle) {
    let source = 'onrotateshape';    
    if (shape.mode == 'slabpart') {
        onrotateslabpart32(type, index, angle, source);
    } else if (shape.mode == 'shape') {
        rotateshape(type, index, angle, source);
        drawshapesides(shape.index, source);
        ActionRotateShape(source);      
    }
}
function rotateshape(type, index, angle, source) {
    if(shape.angle==undefined){return;}
    if (!shapeg.empty()) {
        if (type == 0) { shape.angle = angle; }
        else if (type == 1) { shape.angle += angle; }
        else if (type == -1) { shape.angle -= angle; }     
        setshapecentercords32(source);       
        let npt = [shape.rtx, shape.rty];
        shapeg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");        
        let areashapeindex = shape.areaid + "" + index;
        $('#shapectlinputangle' + areashapeindex).val(shape.angle);
    }
}
function oncloseshapecontrols34() {
    removeshapetools();
}
function reseteditmode(source) {
    if (editmode == 1) {
        editmode = 0; drawshapesides(shape.index, source);
        if (bedit == true) { bedit = false; loguseraction("editshape", source); }
    }
}
function removedrawhandles() {
    if (drawhandlesg != undefined) { shapesg.select("#drawhandlesg").remove(); }
}
function removeanglehandles() {
    if (anglehandlesg != undefined) { anglehandlesg.selectAll('*').remove(); }
}
function removehandles() {
    removedrawhandles();
    removeanglehandles();
    removeshapetools();
}
