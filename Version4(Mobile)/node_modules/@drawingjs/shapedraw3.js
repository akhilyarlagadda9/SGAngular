function initshape(x, y) {
    let index = shapes.length, cr = 12;
    let color = getRandomColor();
    shape = {
        index: index, id: index, areaid: area.ID, materialid: 0, partid: 0, partname: '', isactive: 1, spactive: 0, mode: 'shape', spindex: index, slabid: 0, slabindex: 0, unitcount: 0,
        x: x, y: y, tx: 0, ty: 0, h: 102, angle: 0, color: color, opoints: [], sides: [], seams: []
    };
    shape.opoints.push([x, y]);
    shapes.push(shape);
    initshapegroups(index, 'shape', 'initshape');
}
function initshapegroups(index, smode, source) {
    // removehandles(); //effecting cutout rotation
   // console.log(index, smode, source);
    if (smode == 'print') {
        shape = shapes[index]; shapeouterg = prshapesg.select("#" + smode + "outer" + index);
        if (shapeouterg.empty()) { shapeouterg = prshapesg.append("g").attr("id", smode + "outer" + index).attr("index", index).attr("sindex", index).attr("smode", smode); }
    } else if (smode == 'slabpart') {
        if (slabpartsg != undefined) {
            shape = slabparts[index]; shapeouterg = slabpartsg.select("#" + smode + "outer" + index);
            if (shapeouterg.empty()) { shapeouterg = slabpartsg.append("g").attr("id", smode + "outer" + index).attr("index", index).attr("sindex", index).attr("smode", smode); }
            shapeouterg.call(shapedrag);
        }
    } else if (smode == 'shape') {
        shape = shapes[index];
        shapeouterg = shapesg.select("#" + smode + "outer" + index);
        if (shapeouterg.empty()) { shapeouterg = shapesg.append("g").attr("id", smode + "outer" + index).attr("index", index).attr("sindex", index).attr("smode", smode);}
        shapeouterg.call(shapedrag);
        let shapeslabimgsg = shapeouterg.select("#" + "shapeslabimgsg" + index); if (shapeslabimgsg.empty()) { shapeslabimgsg = shapeouterg.append("g").attr("id", "shapeslabimgsg" + index); }
    }
    if (shape != undefined) {
        shapeg = shapeouterg.select("#" + smode + index);
        if (shapeg.empty()) { shapeg = shapeouterg.append("g").attr("id", smode + index); }        
        shapepathg = shapeg.select("#" + smode + "pathg" + index);if (shapepathg.empty()) { shapepathg = shapeg.append("g").attr("id", smode + "pathg" + index); }
        sidesg = shapeg.select("#" + smode + "sidesg" + index); if (sidesg.empty()) { sidesg = shapeg.append("g").attr("id", smode + "sidesg" + index); }
        cornersg = shapeg.select("#" + smode + "cornersg" + index); if (cornersg.empty()) { cornersg = shapeg.append("g").attr("id", smode + "cornersg" + index); }
        sideshapesg = shapeg.select("#" + smode + "sideshapesg" + index); if (sideshapesg.empty()) { sideshapesg = shapeg.append("g").attr("id", smode + "sideshapesg" + index); }
        splashsg = shapeg.select("#" + smode + "splashsg" + index); if (splashsg.empty()) { splashsg = shapeg.append("g").attr("id", smode + "splashsg" + index); }
        cutoutsg = shapeg.select("#" + smode + "cutoutsg" + index); if (cutoutsg.empty()) { cutoutsg = shapeg.append("g").attr("id", smode + "cutoutsg" + index); }
        seamsg = shapeg.select("#" + smode + "seamsg" + index); if (seamsg.empty()) { seamsg = shapeg.append("g").attr("id", smode + "seamsg" + index); }
        anglehandlesg = shapeg.select("#" + smode + "anglehandlesg" + index); if (anglehandlesg.empty()) { anglehandlesg = shapeg.append("g").attr("id", smode + "anglehandlesg" + index); }
        if (smode == 'shape') {
            if (source != 'drawAreashapes') {
                ActionSelectShape();
            }
        }
        shape.mode = smode;
    }
}
function setdrawmode(dmode) {   
    if (bdraw) { onendshapedraw('setdrawmode'); }
    drawmode = dmode; 
    if (drawmode != 2) { removeshapecorners(0, 'setdrawmode'); }
}
function drawcountershape(type) {
    shapetype = type;
    setdrawmode(1);
}
function setcornertype(type, itemid) {
    cornertype = parseInt(type);
    cornertypeid = parseInt(itemid);
    setdrawmode(2);   
    if (shape.mode == 'shape') { drawshapecorners(shape.index, 'setcornertype'); }
}
function setsideshapetype(type, itemid) {
    sideshapetype = parseInt(type);
    sideshapetypeid = parseInt(itemid);
    setdrawmode(3);
}
function setsplashtype(height, typeid) {
    edgetype = "S";
    edgetypeid = parseInt(typeid);
    splheight = Number(height);
    if (splheight == 0) { splheight = 4; }
    setdrawmode(4);
}
function setedgetype(type, typeid) {
    edgetype = type;
    edgetypeid = parseInt(typeid);
    setdrawmode(5);
}
function setcutouttype(type, itemid) {
    cutouttype = type;
    cutoutinfo = getpricebookcutoutbyid(itemid);
    setdrawmode(6);
    //ActionSinkProductItems();
}
function setseamtype(type) {
    seamtype = type;
    removeanglehandles();
    setdrawmode(7);
}
function setlayoutmode() {    
    let mode = layoutmode == 1 ? 2 : 1;
    onsetlayoutmode(mode);
}
function drawAreashapes(mode) {
    if (shapes.length > 0) {
        for (var i = 0; i < shapes.length; i++) {
            if (shapes[i].areaid == area.ID && shapes[i].isactive == 1 && shapes[i].sides.length > 0) {
                drawshape(i, mode);
            }
        }
    }
}
function drawshape(index, mode) {
    shape = shapes[index];
    shape.unitcount = area.NoOfUnits; shape.isactive = 1;
    if (shape.dupcount == undefined) { shape.dupcount = 0; }
    initshapegroups(index, mode, 'drawAreashapes');
    shapesides('drawAreashape');
    transformshape();
    if (shape.angle != 0) { rotateshape(0, index, shape.angle); }
}
function ondrawshape(mx, my) {
    //mx = (mx - zscalex) / zscale;
    //my = (my - zscaley) / zscale;
    if (shapetype == 0) {
        initshape(mx, my);
        transformshape();
        drawshapedrawhandle(mx, my);
    } else {
        if (shapetype == 1) { drawrectshape(mx, my); }
        else if (shapetype == 2) { drawrlshape(mx, my); }
        else if (shapetype == 3) { drawllshape(mx, my); }
        else if (shapetype == 4) { drawushape(mx, my); }
        else if (shapetype == 5) { drawllshape(mx, my); }
        initendsideedge();
        shapesides('shapedrawed');
        transformshape();
        ActionAddShape('onendshapedraw');
    }
    shapetype = 0;
    drawlogservice.add(shape, 'ondrawshape', 1);
}
function drawrectshape(x1, y1) {
    let angle = 0, w = 480;
    initshape(x1, y1);
    let npt = rotate_point1(x1, y1, -1, angle, w);
    let x2 = npt.dx, y2 = npt.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);  
}
function drawrlshape(x1, y1) {
    let angle1 = 90, angle2 = 0, w1 = 240, w2 = 240;
    initshape(x1, y1);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);   
}
function drawllshape(x1, y1) {
    let angle1 = 90, angle2 = 180, w1 = 240, w2 = 240;
    initshape(x1, y1);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);  
}
function drawushape(x1, y1) {
    let angle1 = 90, angle2 = 0, angle3 = 270, w1 = 240, w2 = 360, w3 = 240;
    initshape(x1, y1);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);
    let npt3 = rotate_point1(x3, y3, -1, angle3, w3);
    let x4 = npt3.dx, y4 = npt3.dy;
    setnewshapeside(x4, y4);
    shape.opoints.push([x4, y4]);   
}
function svgclick() {
    removeshapecorners(0, 'svgclick');
    if (editmode == 1) { reseteditmode('svg click'); }
    if (bdraw) { onendshapedraw('svgclick'); removedrawhandles(); }
    if (d3.event.srcElement.tagName == 'svg' || d3.event.srcElement.id == 'shapesrect') {
        if (shapes.length > 0) { removehandles(); }
        if (drawmode == 1) {
            let m = d3.mouse(this);
            let mx = Math.round(m[0]), my = Math.round(m[1]);
            ondrawshape(mx, my);
            drawmode = 0;
        } else { setdrawmode(0); }

    }
    //  ActionDrawSideHide();
}
function svgblur() {
    setdrawmode(0);
}
function svgcontextmenu() {
    // d3.event.preventDefault();
}
function drawshapedrawhandle(x, y) {
    let x1 = 0, y1 = 0, x2 = 0, y2 = 0, h = shape.h;
    x1 = x - h / 2, x2 = x + h / 2, y1 = y2 = y;
    var sclass = 'shapesideblue';
    drawhandlesg = shapesg.select("#drawhandlesg"); if (drawhandlesg.empty()) { drawhandlesg = shapesg.append("g").attr("id", "drawhandlesg").call(shapedraw); }
    var shapeline = drawhandlesg.select("#" + "drawhandle1");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "handle1"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);
    x1 = x2 = x, y1 = y - h / 2, y2 = y + h / 2;
    shapeline = drawhandlesg.select("#" + shape.mode + "handle2");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "handle2"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);
}
function onshapesidedrawhandle() {
    let index = shape.opoints.length - 1;
    let x2 = shape.opoints[index][0], y2 = shape.opoints[index][1];
    drawshapedrawhandle(x2, y2);
}
function onendshapedraw(source) {
    initendsideedge();
    drawshapeendside();
    bdraw = false;
    ActionAddShape('onendshapedraw');
    drawlogservice.add(shape, 'ondrawshape', 1);
}
function onshape() {   
    d3.event.stopPropagation();
    var index = parseInt(this.getAttribute("index"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    var m = d3.mouse(this);
    initshapegroups(sindex, mode, 'onshape');
   // console.log("index:" + index, "shape index:" + shape.spindex, "mode:" + mode, drawmode);  
    if (drawmode == 2) {
        drawshapecorners(index, 'onshape');
       // setdrawmode(0);
    } else if (drawmode == 6) {
        onsetshapesidecutout(m[0], m[1], -1, index);
        //setdrawmode(0);
    } else if (drawmode == 7) {
        if (seamtype != 2) { onsetsideseam(m[0], m[1], -1, index, sindex, seamtype); }        
        setdrawmode(0);
    } else if (drawmode == 1) {
    } else {
        setdrawmode(0);
    }
}
function onshapecontextmenu() {
    removeshapecorners(0,'onshapecontextmenu');
    d3.event.preventDefault();
    var m = d3.mouse(this);
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    initshapegroups(sindex, mode, 'onshapecontextmenu');
    drawshapecontrols(sindex, m[0], m[1]);
}
function onduplshapecounter(val, index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    let newdupcount = dupcount + parseInt(val);
    if (newdupcount == 0) { newdupcount = 1; }
    $('#shapectlduplinput' + shape.index).val(newdupcount);
}
function onduplicateshape(index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    if (shape.unitcount > 1) { shape.dupcount = parseInt(shape.dupcount) + dupcount; }
    //console.log(dupcount, shape.dupcount);
    for (let i = 0; i < dupcount; i++) {
        duplicateshape(shape.index);
    }
}
function duplicateshape(sindex) {
    var copyshape = JSON.parse(JSON.stringify(shapes[sindex]));
    copyshape.index = shapes.length;
    copyshape.color = getRandomColor();
    for (let j = 0; j < copyshape.sides.length; j++) {
        resetduplicateshapesideitems(copyshape.sides[j], copyshape.index);
    }
    shapes.push(copyshape);
    setTimeout(function () {
        _qscope.$apply(function () {
            let part = ActionAddCopyPart();
            initshapegroups(copyshape.index, 'shape', 'onduplicateshape');
            shapesides('onduplicateshape');
            shape.tx += 10, shape.ty += 10;
            transformshape();
            let partid = shape.partid, partsrno = shape.partsrno;
            shape.partsrno = part.SrNo; shape.partid = 0;
            ActionCopyShapesToPart(partid, partsrno);
            drawshapesidestext();
            drawlogservice.add(shape, 'ondrawshape', 1);
        });
    });
}
function onshapemouseover() {
    if (shape != undefined && shape.mode == 'shape') {
        let sindex = parseInt(this.getAttribute("sindex"));
        unhighlightslabparts(sindex, 'yellow');
        unhighlightslabsplashs(sindex, 'yellow')
    }
}
function onshapemouseout() {
    if (shape != undefined && shape.mode == 'shape') {
        let sindex = parseInt(this.getAttribute("sindex"));
        unhighlightslabparts(sindex, 'blue');
        unhighlightslabsplashs(sindex, 'blue')
    }
}
function ondeleteshape(index) {
    removeshapetools();   
    deleteshape1(index);
    drawlogservice.remove(shape, 'ondeleteshape', 1);
}
function deleteshape1(index) {
    deleteshape(index);
    ondeleteshapeslabparts(index);
    ActionRemoveShapePart(index);
}
function deleteshape(index) {
    shapes[index].isactive = 0;
    shapesg.select("#shapeouter" + index).remove();
}
function resetduplicateshapesideitems(dupside, sindex) {
    dupside.sindex = sindex;
    for (var j = 0; j < dupside.edges.length; j++) {
        dupside.edges[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.splashs.length; j++) {
        dupside.splashs[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.corners.length; j++) {
        dupside.corners[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.cutouts.length; j++) {
        if (dupside.cutouts[j].Isactive == 1) {
            dupside.cutouts[j].sindex = sindex;
            dupside.cutouts[j].shapeindex = sindex;
            dupside.cutouts[j].index = j;
            //ActionAddCutout(dupside.cutouts[j].index, dupside.cutouts[j]);
        }
    }
    for (var j = 0; j < dupside.sideshapes.length; j++) {
        dupside.sideshapes[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.seams.length; j++) {
        dupside.seams[j].sindex = sindex;
    }
}
function shapedrawstarted() {
    bdraw = true;
    let index = shape.opoints.length - 1;
    let x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    drawshapedrawhandle(x1, y1);
    reseteditmode('shapedrawstarted');
}
function shapedrawed() {
    let index = shape.opoints.length - 1;
    let x1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if (Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh) {
        setnewshapeside(x2, y2);
        shapesides('shapedrawed');
    }
    drawshapedrawhandle(x2, y2);
}
function shapedrawended() {
    let index = shape.opoints.length - 1;
    let x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    if (index > 0) { x0 = shape.opoints[index - 1][0], y0 = shape.opoints[index - 1][1]; }
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if ((Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh)) {
        if (index == 0) { shape.opoints.push([x2, y2]); } else {
            if (((x0 === x2) && (x1 === x2)) || ((y0 === y2) && (y1 === y2))) {
                shape.opoints[index][0] = x2;
                shape.opoints[index][1] = y2;
            } else {
                shape.opoints.push([x2, y2]);
            }
        }
    }
}
function shapedragstarted() {
    // console.log(d3.event.sourceEvent.srcElement.tagName);
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        removehandles();
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        if (mode == 'shape') {
            if (bdraw) { onendshapedraw(); }
            reseteditmode('shapedragstarted');
            drawlogservice.beforeupdate(shape, 'shapedragstarted', 1);
            bdrag = true;
            initshapegroups(sindex, mode, 'shapedragstarted');
        } else if (mode == 'slabpart') {
            bdrag = true;
            editmode = 0;
            initshapegroups(sindex, mode, 'shapedragstarted');
        }
    }
}
function shapedragged() {
    if (bdrag) {
        d3.event.sourceEvent.stopPropagation();
       
      //  console.log(d3.event.sourceEvent.srcElement.tagName);
        let ndx = this.x || shape.tx;
        let ndy = this.y || shape.ty;
        ndx += d3.event.dx;
        ndy += d3.event.dy;
        let stx = shape.tx, sty = shape.ty;
        shape.tx = Math.round(ndx), shape.ty = Math.round(ndy);
        transformshape();
        if (shape.mode == 'shape') { 
            if (!checksvgbounds(ndx, ndy)) {//not in bounds transform back to previous pos
                shape.tx = stx, shape.ty = sty;
                transformshape();
            }
        } else if (shape.mode == 'slabpart') {
            //checklayoutsvgbounds1(shape.index, ndx, ndy)
            if (drawmode != 7) { shapeouterg.attr("pointer-events", "none"); }
            if (layoutmode == 2) { onsetslabpartclipimage(shape.index); }
        }
    }
}
function shapedragended() {
    if (bdrag) {
        shapeouterg.attr("pointer-events", "auto");
        bdrag = false;
        if (shape.mode == 'slabpart') {
            // shapeouterg.attr("pointer-events", "auto");
            // checkslabbounds(shape.tx, shape.ty);
            ActionUpdateSlabParts();
        } else {
            drawlogservice.update(shape, 'shapedragended', 1);
            ActionShapeDrag();
        }
        dragdx = 0, dragdy = 0;
    }
}
function transformshape() {
    shape.tx = Math.round(shape.tx), shape.ty = Math.round(shape.ty);
    var npt = [shape.tx, shape.ty];
    shapeouterg.attr('x', shape.tx).attr('y', shape.ty).attr('transform', 'translate(' + npt + ')');
}
function onrotateshape(type, index, angle) {
    rotateshape(type, index, angle);
    if (shape.mode == 'slabpart') { onsetslabpartclipimage(index); }
    else if (shape.mode == 'shape') { onsetshapeslabpartsclipimage(index); }
}
function rotateshape(type, index, angle) {
    if (!shapeg.empty()) {
        if (type == 0) { shape.angle = angle; }
        else if (type == 1) { shape.angle += angle; }
        else if (type == -1) { shape.angle -= angle; }
        var gnode = shapeg.node();
        var sx = gnode.getBBox().x + gnode.getBBox().width / 2; sy = gnode.getBBox().y + gnode.getBBox().height / 2;
        var npt = [sx.toFixed(), sy.toFixed()];
        shapeg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");
        if (shape.mode == 'shape') {
            let shapeslabimagesg = d3.select("#shapeslabimgsg" + index);
            shapeslabimagesg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");
        }        
        $('#shapectlinputangle' + index).val(shape.angle);
    }
}
function reseteditmode(source) {
    if (editmode == 1) {
        editmode = 0; drawshapesides(shape.index, source);
        if (bedit == true) { bedit = false; loguseraction("editshape", source); }
    }
}
function removedrawhandles() {
    if (drawhandlesg != undefined) { shapesg.select("#drawhandlesg").remove(); }
}
function removeanglehandles() {
    if (anglehandlesg != undefined) { anglehandlesg.selectAll('*').remove(); }
}
function removehandles() {
    removedrawhandles();
    removeanglehandles();
    removeshapetools();
}
/*Drawing log service*/
function undoredo(type) {
    if (type == 0) {
        drawlogservice.undodraw();
    } else {
        drawlogservice.redodraw();
    }
}
function onundodeleteshape(index) {
    deleteshape1(index);
}
function onundodrawshape(index) {
    drawshape(index, 'shape');
    ActionUpdateShape();
}
function onredodrawshape(index) {
    drawshape(index, 'shape');
    ActionUpdateShape();
}
function onundoudpateshape(item, type) {
    // console.log(item.index, shapes.length);
    $("#shapeouter" + item.index).remove();
    let partid = -1;
    if (shapes[item.index] != undefined) { partid = shapes[item.index].partid; }    
    shapes[item.index] = angular.copy(item);
    if (partid != -1) { shapes[item.index].partid = partid; }
    drawshape(item.index, 'shape');
    ActionShapeReSize1();
}
function onredoudpateshape(item, type) {
    // console.log(item.index, shapes.length);
    $("#shapeouter" + item.index).remove();
    let partid = -1;
    if (shapes[item.index] != undefined) { partid = shapes[item.index].partid; }
    shapes[item.index] = angular.copy(item);
    if (partid != -1) { shapes[item.index].partid = partid; }
    drawshape(item.index, 'shape');
    ActionShapeReSize1();
}