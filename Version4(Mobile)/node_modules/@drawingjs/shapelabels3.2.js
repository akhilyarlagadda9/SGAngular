function initshapelabel(index, sindex, type, slx, sly, text) {    
    let shapelabel = { index: index, sindex: sindex, type: type, text: text, width: 100, height: 40, x: slx, y: sly, isactive: 1 };
    shape.labels.push(shapelabel);
}
function setdefaultshapelabel() {
    if (shape.labels == undefined || shape.labels.length == 0) {
        let shapegnode = shapeouterg.node().getBBox(), w = Math.round(shapegnode.width), h = Math.round(shapegnode.height), sx = Math.round(shapegnode.x + w / 2), sy = Math.round(shapegnode.y + h);
        sx -= 125;//default label width/2       
        onsetshapelabel(sx, sy, -1, shape.index, 1, 'setdefaultshapelabel');
    }
}
function onsetshapelabel(mx, my, index, sindex, type, source) {  
    if (shape.labels == undefined) { shape.labels = []; }    
    if (index == -1) {
        index = shape.labels.length;
        let labeltext = shape.partname;
        if (labeltext == undefined || labeltext == '') { labeltext = '<p><span>' + 'A' + (shape.areaindex) + ':P' + (shape.partsrno) + '</span></p>'; }
        initshapelabel(index, sindex, type,  mx, my, labeltext);''
    }
    let shapelabel = shape.labels[index];
    drawshapelabel32(index, mx, my, shapelabel.text);
    ActionUpdateShape('onsetshapelabel');   
}
function drawshapelabels() {
    //if (!bdraw) { setdefaultshapelabel(); }
    if (shape.labels != undefined && shape.labels != null) {
        for (let j = 0; j < shape.labels.length; j++) {
            let shapelabel = shape.labels[j];
            shapelabel.type = 2;
            if (shapelabel.isactive == 1) { drawshapelabel32(j, shapelabel.x, shapelabel.y, shapelabel.text); }
        }
    }
}
function drawshapelabel32(index, sltx, slty, ltext) {
    let type = 2, lw = 250, lh = 30;
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let slindex = shape.index + "" + index + "" + type;
    //console.log(index, sindex, sltx, slty, smode, partsrno, areaid, spindex);
    let splabelouterg = sidesg.select("#splabelouterg" + slindex);
    if (splabelouterg.empty()) { splabelouterg = sidesg.append('g').attr("id", "splabelouterg" + slindex); } else { splabelouterg.selectAll('*').remove(); }
    splabelouterg.attr("slindex", slindex).attr("index", index).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
        .attr("type", type).attr("x", sltx).attr("y", slty).attr("width", lw).attr("height", lh).attr("style", "overflow: visible;cursor:pointer;");
    if (shape.mode == 'shape') { splabelouterg.call(shapelabeldrag).on("click", oneditshapelabel); }
    let ltextdiv = document.createElement('div');
    ltext = ltext.replace('<br>', '').replace('&nbsp;', '');
    ltextdiv.innerHTML = ltext;   
    if (ltextdiv.childNodes.length == 1) {ltextdiv.innerHTML = "<p><span>" + ltext + "<p><span>";}   
    for (let i = 0; i < ltextdiv.childNodes.length; i++) {
        let ltextNode = ltextdiv.childNodes[i];       
        for (let j = 0; j < ltextNode.childNodes.length; j++) {
            let ltextNodeStyle = '', ltextNodeText = '';
            ltextNodeText = ltextNode.childNodes[j].innerText;
            if (ltextNodeText == undefined) { ltextNodeText = ltextNode.innerHTML; }
            ltextNodeText = ltextNodeText.replace('&nbsp;', '');
            if (ltextNode.childNodes[j].tagName == 'SPAN' && ltextNode.childNodes[j].getAttribute('style') != null) {
                ltextNodeStyle = ltextNode.childNodes[j].getAttribute('style');
                if (ltextNodeStyle.indexOf('background-color') != -1) {
                    let splabelrect = splabelouterg.append("rect").attr("id", "splabelrect" + slindex + i + j).attr("slindex", slindex).attr("index", index)
                        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("type", type).attr("x", sltx).attr("y", slty)
                        .attr("x", sltx - lw / 2).attr("y", slty - lh / 2).attr("width", lw).attr("height", lh / 2).attr("style", ltextNodeStyle.replace('background-color', 'fill'));
                    if (shape.mode == 'shape') { splabelrect.on("click", oneditshapelabel); }
                }
            }
            let splabeltext = splabelouterg.append("text").attr("id", "splabeltext" + slindex + i + j).attr("slindex", slindex).attr("slindex", slindex).attr("index", index).attr("sindex", sindex).attr("type", type).attr("x", sltx).attr("y", slty);
            let splabeltextspan = splabeltext.attr("x", sltx).attr("y", slty).append("tspan").attr("id", "splabeltextspan" + slindex + i).attr("slindex", slindex).attr("index", index)
                .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("type", type)
                .attr("x", sltx).attr("y", slty).attr("text-anchor", "middle").attr("alignment-baseline", "ideographic").text(ltextNodeText);
            if (shape.mode == 'shape') { splabeltextspan.on("click", oneditshapelabel); }
            if (ltextNodeStyle != '') { splabeltextspan.attr("style", ltextNodeStyle); }
            slty += 15;
        }
    }
}
function oneditshapelabel() {
    let smode = this.getAttribute("smode");
    if (shape.mode == 'shape') {
        let index = parseInt(this.getAttribute("index"));        
        let sindex = parseInt(this.getAttribute("sindex"));        
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        //console.log(sindex, partsrno, areaid, smode);
        setdrawshape31(sindex, partsrno, areaid, smode, 'oneditshapelabel');
        let shapelabel = shape.labels[index];
        $('.note-editable').html(shapelabel.text);
        labelindex = index, labeltype = 2;
        $("#divmodelshape").show();   
    }
}
function onsaveareashapelabel() {    
    if (labeltype == 1) { onsavearealabel(); } else if (labeltype == 2) { onsaveshapelabel(); }
}
function ondeleteareashapelabel() {
    if (labeltype == 1) { ondeletearealabel(); } else if (labeltype == 2) { ondeleteshapelabel(); }
}
function onsaveshapelabel() {   
    let labeltext = $('.note-editable').html();    
    let shapelabel = shape.labels[labelindex];
    shapelabel.text = labeltext.replace('&nbsp;', '');
    drawshapelabel32(labelindex, shapelabel.x, shapelabel.y, shapelabel.text);
    ActionUpdateShape('onsaveareashapelabel');
    $("#divmodelshape").hide();   
}
function ondeleteshapelabel() {  
    let shapelabel = shape.labels[labelindex];
    let slindex = shape.index + "" + labelindex + "" + 2;    
    let splabelouterg = sidesg.select("#splabelouterg" + slindex);
    //console.log(labelindex, slindex, "#splabelouterg" + slindex, splabelouterg.empty());
    if (!splabelouterg.empty()) { splabelouterg.remove(); }
    shapelabel.isactive = 0;
    ActionUpdateShape('ondeleteareashapelabel');
    $("#divmodelshape").hide();
}
function oncloseareashapelabelmodel() {
    $("#divmodelshape").hide();
}
function shapelabeldragstarted() {  
    let smode = this.getAttribute("smode");
    if (shape.mode == 'shape') {
        let index = parseInt(this.getAttribute("index"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
       // console.log(sindex, partsrno, areaid, smode);
        setdrawshape31(sindex, partsrno, areaid, smode, 'oneditshapelabel');
        let shapelabel = shape.labels[index];
        dragdx = d3.event.x - shapelabel.x; dragdy = d3.event.y - shapelabel.y;        
        removeshapetools();
        bdrag = true;
    }
}
function shapelabeldragged() {    
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));        
        let shapelabel = shape.labels[index];        
        let slx = d3.event.x - dragdx, sly = d3.event.y - dragdy;
        shapelabel.x = slx; shapelabel.y = sly;
        drawshapelabel32(index, slx, sly, shapelabel.text);
    }
}
function shapelabeldragended() {
    if (bdrag) {       
        bdrag = false;
        resetdragvars('shapelabeldragended');
        ActionUpdateShape('shapelabeldragended');
    }
}
