function getareaid(index) {
    let areaid = -1;
    let area = getareabyindex(index);
    if (area != null) { areaid = area.ID; }
    return areaid;
}
function getareabyid(areaid) {
    let areas = getversionareas();
    for (let i = 0; i < areas.length; i++) {
        if (areas[i].ID == areaid) {
            return areas[i];
        }
    }
    return "";
}
function getareaunits(index) {
    let areaunits = 0;
    let area = getareabyindex(index);
    if (area != null) { areaunits = area.NoOfUnits; }
    return areaunits;
}
function getpartlist(areaindex) {
    let areapartlist = [];
    let area = getareabyindex(areaindex);
    if (area != null && area.PartList != null) { areapartlist = area.PartList; }
    return areapartlist;
}

function getpartlength(areaindex) {
    let partlist = getpartlist(areaindex);
    return partlist.length;
}
function getpartbypartindex(index) {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    if (partlist.length > index) {
        return partlist[index];
    }
}
function getpartbypartsrno(partlist, partsrno) {
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].SrNo == partsrno && partlist[i].IsActive == 1) {
            return partlist[i];
        }
    }
}
function getpartbypartid(partlist, partid) {
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].ID == partid) {
            return partlist[i];
        }
    }
}
function getpartbyareapartid(partid, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        return getpartbypartid(area.PartList, partid);
    }
}
function getpartbyareapartsrno(partsrno, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        return getpartbypartsrno(area.PartList, partsrno);
    }
}
function getpartshapebyareapartsrno(partsrno, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        let part = getpartbypartsrno(area.PartList, partsrno);
        if (part != undefined && part != "") {
            let pshape = parsepartshape(part.Shape);
            pshape.partsrno = part.SrNo;
            pshape.partid = part.ID;
            pshape.areaid = part.AreaID;
            pshape.materialid = getpartmaterialid(part.PartMaterialList);
            pshape.unitcount = area.NoOfUnits;
            return pshape;
        }
    }
}
function getpartmaterialidbyareapartid(partid, partsrno, areaid) {
    let area = getareabyid(areaid);
    let matid = 0;
    for (let i = 0; i < area.PartList.length; i++) {
        if (area.PartList[i].ID == partid && area.PartList[i].SrNo == partsrno) {
            return getpartmaterialid(area.PartList[i].PartMaterialList);
        }
    }
    return matid;
}
function getpartshapecopybyareaidpartsrno(partsrno, areaid) { //used for slabpart
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        let part = getpartbypartsrno(area.PartList, partsrno);
        let pshape = JSON.parse(JSON.stringify(part.Shape));
        return pshape;
    }
}
function getlastactivepartsrno() {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    let partsrno = 0;
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            partsrno = partlist[i].SrNo;
        }
    }
    return partsrno;
}
function getpartsrno(parts) {
    let partsrno = 1;
    if (parts != null && parts.length > 0) {
        for (let i = 0; i < parts.length; i++) {
            if (parts[i].IsActive == 1) {
                partsrno += 1;
            }
        }
    }
    return partsrno;
}
function getpartmaterialid(partmats) {
    let materialid = 0;
    if (partmats != null && partmats.length > 0) {
        materialid = partmats[partmats.length - 1].MaterialID;
    }
    return materialid;
}
function getshapebypartindex(index) {
    let areaindex = getareaindex();
    return setshapeareapartinfo(index, areaindex); // set should not be in get functions any better way??
}
function getshapebypartsrno(partsrno) {
    let areaindex = getareaindex();
    return setshapeareapartinfo(index, areaindex);// set should not be in get functions any better way??
}
function parsepartshape(unpshape) {
    let tmppartshape = {};
    if (typeof (unpshape) == 'string' && unpshape != '' && unpshape != 'null') {
        tmppartshape = JSON.parse(unpshape);
    } else if (typeof (unpshape) == 'object') {
        tmppartshape = unpshape;
    }
    if (tmppartshape != null && tmppartshape.length > 0) { tmppartshape = tmppartshape[0]; }
    return tmppartshape;
}
function jasonpartshape(partshape) {
    let tmppartshape = {};
    if (typeof (partshape) == 'object') {
        tmppartshape = JSON.stringify(partshape);
    } else {
        tmppartshape = partshape;
    }
    return tmppartshape;
}
function getpartedgebytypeid(typeid, edgelist) {
    for (let i = 0; i < edgelist.length; i++) {
        if (edgelist[i].EdgeProfileID == typeid) {
            return edgelist[i];
        }
    }
}
function getpartedgebytypeid1(typeid, edgelist, height) {
    for (let i = 0; i < edgelist.length; i++) {
        if (typeid == 10 && edgelist[i].Height == height) {//circle shape
            return edgelist[i];
        } else if (edgelist[i].EdgeProfileID == typeid) {
            return edgelist[i];
        }
    }
}
function getpartedgebydesc(desc, edgelist) {
    for (let i = 0; i < edgelist.length; i++) {
        if (edgelist[i].EdgeProfile.toLowerCase() == desc.toLowerCase()) { return edgelist[i]; }
    }
}
function getpartsplashbytype(height, splashlist, typeid) {
    for (let i = 0; i < splashlist.length; i++) {
        if (splashlist[i].Height == height && splashlist[i].TypeID == typeid) { return splashlist[i]; }
    }
}
function getpartcutoutbytype(type, height, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        if (cutoutlist[i].Type == type && cutoutlist[i].Height == height) {
            return cutoutlist[i]
        }
    }
}
function getcutouttypeid(type) {
    let typeid = 1;
    if (type == "rc") { typeid = 3; } else if (type == 'cor') { typeid = 2; }
    return typeid;
}
function getpricebookcutouttypebyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.cutoutlist != null) {
        for (var i = 0; i < pricebook.cutoutlist.length; i++) {
            let cutout = pricebook.cutoutlist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}
function getcutouttypedesc(cutouttype, width) {
    let desc = 'Undermount';
    if (cutouttype == 'cor') { desc = 'Outlet' }
    else if (cutouttype == 'crf') { desc = 'FORM' }
    else if (cutouttype == 'crd') { desc = 'Drop-In' }
    else if (cutouttype == 'rc') { desc = 'Cooktop' }
    desc = '1 - ' + width + '" ' + desc;
    return desc;
}
function getparttemplateinstallbydesc(laborlist, desc) {
    let plabor;
    for (let i = 0; i < laborlist.length; i++) {
        if (laborlist[i].Description == desc && laborlist[i].ViewTypeID == 1 && laborlist[i].Isactive == 1) {
            plabor = laborlist[i];
        }
    }
    return plabor;
}
function getcutoutpricebyrange(width, type) {
    let pricebook = getqscopepricebook();
    if (pricebook.cutoutlist != null) {
        for (var i = 0; i < pricebook.cutoutlist.length; i++) {
            let cutout = pricebook.cutoutlist[i];
            if (type == "cor" && cutout.Description == "Outlet") { return cutout; }//outlet
            else if (type == "crf" && cutout.Description == "Apron/Farm Sink Cutout (Prem EP)") { return cutout; }//farm
            else if (type == "crd" && cutout.Description == "Drop-In") { return cutout; }//dropin
            else if (type == "rc" && cutout.Description == "Cooktop") { return cutout; }//dropin
                //else if (width >= cutout.MinWidth && width <= cutout.MaxWidth) { return cutout; }
            else if (width == cutout.MaxWidth) { return cutout; }
        }
    }
}
function getricebookpricerangeoptions(priceoptions, materialid, width, height) {
    let material = getmaterialbyid(materialid);
    if (priceoptions != undefined && priceoptions != null && priceoptions != 'null' && priceoptions != '') {
        let tmppriceoptions = [];
        if (typeof (priceoptions) == 'string') { tmppriceoptions = JSON.parse(priceoptions); }
        for (let i = 0; i < tmppriceoptions.length; i++) {
            let popt = tmppriceoptions[i];
            if (popt.ProductGroupID == material.ProGroupID && popt.ProductSubGroupID == material.ProSubGroupID && width >= Number(popt.RangeMin) && width <= Number(popt.RangeMax)) {
                return popt;
            }
        }
    }
}
function getpricebookbumplistbyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.defaultbumplist != null) {
        for (var i = 0; i < pricebook.defaultbumplist.length; i++) {
            let cutout = pricebook.defaultbumplist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}
function getpricebookcornerlistbyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.defaultcornerlist != null) {
        for (var i = 0; i < pricebook.defaultcornerlist.length; i++) {
            let cutout = pricebook.defaultcornerlist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}

function setpart31(index, partsrno) {
    let userid = getloginuserId();
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let versionid = area.VersionID;
    let phaseid = 0;
    let areaid = area.ID;
    let coid = getcoid();
    let cosrno = getcosrno();
    let roundup = getpbroundup();
    let part = initpart();
    part.SrNo = partsrno;
    part.AreaID = areaid;
    part.CoID = coid;
    part.VersionID = versionid;
    part.UserID = userid;
    part.RoundUp = roundup;
    part.PartCheck = 0;
    part.show = false;
    if (area.PartList == null) { area.PartList = []; }
    area.PartList.push(part);
    area.show1 = true;
    area.SaveFlag = 1;
    area.AreaCheck = 1;
    return part;
}
function setshapeareapartinfo(partindex, areaindex) {
    let area = getareabyindex(areaindex);
    let partlist = area.PartList;
    let part = partlist[partindex];
    let pshape = parsepartshape(part.Shape);
    pshape.partsrno = part.SrNo;
    pshape.partid = part.ID;
    pshape.areaid = part.AreaID;
    pshape.unitcount = area.NoOfUnits;
    return pshape;
}
function setshapeareainfo(pshape, areaindex) {
    let area = getareabyindex(areaindex);
    pshape.areaindex = (areaindex + 1);
    pshape.areaid = area.ID;
    pshape.unitcount = area.NoOfUnits;
    return pshape;
}
function resetareapartssrno() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let partlist = getpartlist(areaindex);
    let partsrno = 1;
    area.SaveFlag = 1;
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            partlist[i].SrNo = partsrno;
            partsrno++;
        }
    }
}
function resetareapartssrno31(areaid) {
    let area = getareabyid(areaid);
    let partsrno = 1;
    for (let i = 0; i < area.PartList.length; i++) {
        if (area.PartList[i].IsActive == 1) {
            area.PartList[i].SrNo = partsrno;
            partsrno++;
        }
    }
}
function setpartmaterial31(part) {
    let pmat;
    if (part.PartMaterialList.length == 0 && part.ID == 0) {
        pmat = initmaterial();
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = getmattaxpercent();
        pmat.AreaID = part.AreaID;
        pmat.VersionID = part.VersionID;
        pmat.CoID = coid;
        pmat.CoSrNo = cosrno;
        pmat.Tax = taxperc > 0 ? 1 : 0;
        if (part.AreaID > 0) {
            pmat.MaterialID = getareamaterialbyareaid(part.AreaID);
            if (pmat.MaterialID > 0) {
                let material = getmaterialbyid(pmat.MaterialID);
                resetpartmaterial32(pmat, material);
            }
        }
        part.PartMaterialList.push(pmat);
    } else if (part.PartMaterialList != null) {
        let pcount = part.PartMaterialList.length;
        pmat = part.PartMaterialList[pcount - 1];
    }
    return pmat;
}
function setpartfab31(part, source) {
    let fab;
    if (part.PartFabList.length == 0 && part.ID == 0) {
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = getfabtaxpercent();
        let pbresklevel = { cost: 0, Margin: 0, price: 0 };
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0) {
            pbresklevel = getmaterialrisklevelfabprice(matid);
        } else {
            pbresklevel = getpricebookrisklevel31(0);
        }
        fab = initfab();
        fab.AreaID = part.AreaID;
        fab.VersionID = part.VersionID;
        fab.CoID = coid;
        fab.CoSrNo = cosrno;
        fab.Tax = taxperc > 0 ? 1 : 0;
        fab.UnitCost = 0;
        fab.Margin = 0;
        fab.UnitPrice = 0;
        fab.MaterialID = matid;
        if (pbresklevel != undefined) { fab.UnitCost = pbresklevel.cost; fab.Margin = pbresklevel.margin; fab.LaborUnitPrice = pbresklevel.price; }
        if (source == 'quote') {
            let fabmeasure = initfabmeasure(); if (fab.MeasureList == null) { fab.MeasureList = []; } fab.MeasureList.push(fabmeasure);
        }
        part.PartFabList.push(fab);
    }
    else if (part.PartFabList != null) {
        let pcount = part.PartFabList.length;
        fab = part.PartFabList[pcount - 1];
    }
    return fab;
}
function setfabmeasure31(index, w, h, sindex, stype, stypeid) {
    let fabmeasure = {};
    let metricmode = getmetrictypeid();
    fabmeasure.Width = roundToTwo(w);
    fabmeasure.Height = roundToTwo(h);
    fabmeasure.Sqft = calcsqft1(w, h, metricmode);
    fabmeasure.shapeindex = sindex;
    fabmeasure.index = index;
    fabmeasure.CounterType = stype;
    fabmeasure.CounterTypeID = stypeid;
    return fabmeasure;
}
function setpartsplash31(part, type, width, height, sqft, desc, itemid) {
    let psplash = initsplash();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    let matid = getpartmaterialid(part.PartMaterialList);
    let metric = getcompanyunittype();
    psplash.AreaID = part.AreaID;
    psplash.VersionID = part.VersionID;
    psplash.CoID = coid;
    psplash.CoSrNo = cosrno;
    psplash.TypeID = type == undefined ? 0 : type;
    psplash.Tax = taxperc > 0 ? 1 : 0;;
    psplash.Width = width;
    psplash.Height = height;
    psplash.Sqft = sqft;
    let spname = metric == 1 ? " MM" + " Splashback" : "'' Backsplash";
    let apronname = metric == 1 ? " MM " : "''";
    if (psplash.TypeID == 1 || psplash.TypeID == 2 || psplash.TypeID == 3) {//apron,mitered,laminated
        let pricebksplash = getpbitembyid(itemid, psplash.TypeID);
        psplash.Splash = height + apronname + pricebksplash.Description;
    } else {
        psplash.Splash = height + spname;
    }
    psplash.MaterialID = matid;
    return psplash;
}
function setpartedge31(part, typeid, type, desc, w, h) {
    let pedge = initedge();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    let metric = getcompanyunittype();
    let pricebookedge;
    pedge.AreaID = part.AreaID;
    pedge.VersionID = part.VersionID;
    pedge.CoID = coid;
    pedge.CoSrNo = cosrno;
    pedge.Tax = taxperc > 0 ? 1 : 0;;
    pedge.Width = roundToTwo(w);
    pedge.Inches = roundToTwo(w);
    pedge.Height = roundToTwo(h);
    //pedge.LF = calclinerfeet(w);
    pedge.EdgeProfileID = typeid;
    if (typeid != 0) {
        pricebookedge = getpbedgebyprofileid(typeid); if (pricebookedge != undefined) { desc = pricebookedge.Description; }
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0 && pricebookedge != undefined) {
            let pricerange = getricebookpricerangeoptions(pricebookedge.JsonOptions, matid, pedge.Width, pedge.Height);
            if (pricerange != undefined) { pricebookedge = pricerange; }
        }
    }
    else if (desc != '') { pricebookedge = getpbedgebydesc(desc); if (pricebookedge != undefined) { desc = pricebookedge.Description; } }
    if (pricebookedge != undefined) {
        pedge.UnitCost = pricebookedge.Cost;
        pedge.Margin = pricebookedge.Margin;
        pedge.UnitPrice = pricebookedge.Price; pedge.Path = pricebookedge.ProductPath;
    }
    pedge.EdgeProfile = desc; pedge.Description = desc;
    if (typeid == 10) {//circle shape
        metric = metric == 0 ? '"' : " mm ";
        pedge.EdgeProfileID = 0; desc = pedge.Height + metric + 'Outside Radius Corner';
    }
    pedge.EdgeProfile = desc; pedge.Description = desc;
    return pedge;
}
function setpartcutout31(part, typeid, type, width, height, sindex, cindex, sideindex) {
    let pcutout = initcutout();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    pcutout.AreaID = part.AreaID;
    pcutout.VersionID = part.VersionID;
    pcutout.CoID = coid;
    pcutout.CoSrNo = cosrno;
    pcutout.Tax = taxperc > 0 ? 1 : 0;;
    pcutout.CutOutTypeID = typeid;
    pcutout.Type = type;
    pcutout.Width = width;
    pcutout.Height = height;
    pcutout.LF = 1;//qty??? 
    pcutout.ShapeID = sindex;//shape index
    pcutout.SrNo = cindex;//cutout index
    pcutout.SIndex = sideindex;//shape sideindex  
    return pcutout;
}
function setparttemplateinstall31(part, typeid, qty) {
    let desc = typeid == 1 ? 'Template' : "Install";
    let plabor = getparttemplateinstallbydesc(part.LaborList, desc);
    if (plabor == undefined) {
        plabor = initlabor();
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = gettaxpercent();
        plabor.ViewTypeID = 1;
        plabor.UnitTypeID = 2;
        plabor.Qty = qty;
        plabor.Description = desc;
        plabor.AreaID = part.AreaID;
        plabor.VersionID = part.VersionID;
        plabor.CoID = coid;
        plabor.CoSrNo = cosrno;
        plabor.Tax = taxperc;
        if (part.ID == 0) {
            let materialid = getpartmaterialid(part.PartMaterialList);
            let pbresklevel = {};
            if (materialid > 0) {
                pbresklevel = typeid == 1 ? gettemplaterisklevelfabprice(materialid) : getinstallrisklevelfabprice(materialid);
            } else {
                pbresklevel = getpricebookrisklevel31(typeid);
            }
            if (pbresklevel != undefined) {
                plabor.UnitCost = pbresklevel.cost;
                plabor.Margin = pbresklevel.margin;
                plabor.UnitPrice = pbresklevel.price;
            }
        }
        part.LaborList.push(plabor);
    } else { plabor.Qty = qty; }
}
function setpartinactive(index) {
    let part = getpartbypartindex(index);
    if (part != null) { part.IsActive = 0; }
}
function setpartactive(index) {
    let part = getpartbypartindex(index);
    if (part != null) { part.IsActive = 1; }
}
function setedgelistinactive(edgelist) {
    for (let i = 0; i < edgelist.length; i++) { edgelist[i].Isactive = 0; edgelist[i].LF = 0; edgelist[i].Inches = 0; }
}
function setcutoutlistinactive(cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) { cutoutlist[i].Isactive = 0; cutoutlist[i].LF = 0; }
}
function setsplashlistinactive(splashlist) {
    for (let i = 0; i < splashlist.length; i++) { splashlist[i].Isactive = 0; splashlist[i].Sqft = 0; splashlist[i].Width = 0; }
}
function setfabsidemeasure(sideindex, fabmeasurelist) {
    //console.log(sideindex, shape.sides.length, JSON.stringify(fabmeasurelist));
    let source = 'setfabsidemeasure';
    ///*1. Side sqft cal: Rectangle box approach is used to cal side sqft. Side means rectangle box with 4 side codes(0,1,2,3). 
    //  2. Side width: w = max(w1,w2); max of side codes 1 or 2;  */
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source), cangle = 0, w = 0;
    if (sideindex > 0) { cangle = calcshapeangle(sideindex - 1); }
    if (sideindex == 0) {
        w = Math.max(w1, w2);
    } else if (sideindex < shape.sides.length - 1) {
        w = Math.min(w1, w2);
    } else if (sideindex == shape.sides.length - 1) {
        if (shape.sides.length > 2) { w = Math.max(w1, w2); } else { w = Math.min(w1, w2); }
    }    
    let swh = calcfabsidebumpoutmeasures32(sideindex, source);     
    let sw = w + swh.scw1 + swh.scw2, sh = h + swh.sch1 + swh.sch2;
    //console.log(sideindex, sw, sh, swh.sw, swh.sh);
    let fabmeasure = setfabmeasure31(side.index, sw, sh, side.sindex, side.stype, side.stypeid);
    fabmeasurelist.push(fabmeasure);
}
function setfabsideshapemeasure(side, sidecode, fabmeasurelist) {
    /*3. side codes 0,3 : w = side height + max(sideshapeheight) 
      4. side codes 1,2 : w = side width +  max(sideshapeheight)  */
    let source = 'setfabsideshapemeasure'; let stype = side.stype;
    if (side.sideshapes != undefined) {
        let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source), bpush = false, sw = 0, sh = 0, cangle = 0, sideindex = side.index;
        if (sideindex > 0) { cangle = calcshapeangle(sideindex - 1); }
        for (let i = 0; i < side.sideshapes.length; i++) {
            let sideshape = side.sideshapes[i];
            if (sideshape.isactive == 1 && sideshape.sidecode == sidecode && sideshape.typeid != 1 && sideshape.typeid != 2 && sideshape.typeid != 3) {//bump: in,out,angle
                bpush = true;
                let h1 = applymminchfact1(sideshape.h, 2, 2, source); sw = applymminchfact1(sideshape.w, 2, 0, source);
                if (h1 > sh) { sh = h1; }
                if (sidecode == 0 || sidecode == 3) { sw = h; }
                else if (sidecode == 1 || sidecode == 2) { if (sideindex < shape.sides.length - 1) { sw = Math.min(w1, w2); } else { sw = Math.max(w1, w2); } }
                if (sideshape.typeid == 4) { stype = 'Bump Out'; } else if (sideshape.typeid == 5) { stype = 'Bump Out Angle'; } else if (sideshape.typeid == 6) { stype = 'Bump Out Arc'; }
                else if (sideshape.typeid == 11) { stype = 'Full Arc'; }
            }
        }
        if (bpush) {
            let fabmeasure = setfabmeasure31(side.index, sw, sh, side.sindex, stype, side.stypeid);
            fabmeasurelist.push(fabmeasure);
        }
    }
}
function setfabsidecornermeasure(index, sideindex, sidecorner, fabmeasurelist) {
    let source = 'setfabsidecornermeasure';
    let cw = applymminchfact(sidecorner.w, 2, 2, source), ch = applymminchfact(sidecorner.h, 2, 2, source), cr = applymminchfact(sidecorner.r, 2, 2, source);
    let cornerdesc = '', cw1 = 0;
    if (sidecorner.type == 1) { cornerdesc = 'Clip Corner'; } else if (sidecorner.type == 2) { cornerdesc = 'Radius Corner'; }
    else if (sidecorner.type == 3) { cornerdesc = 'Notch Corner'; } else if (sidecorner.type == 4) { cornerdesc = 'Bump Out Corner'; }
    // console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
    if (sidecorner.type == 4) { ch = cr; } // for bump out use r/depth to cal. sq.ft
    if (sideindex > 0 && sidecorner.index == 1) {
        //   console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
        let fabmeasure = setfabmeasure31(sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
        fabmeasurelist.push(fabmeasure);
    } else {
        if (sidecorner.type == 1) {//bumpout corner , clip   
            let fabmeasure = setfabmeasure31(sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
            fabmeasurelist.push(fabmeasure);
        }
        else if (sidecorner.type == 4) {//bumpout corner , clip   
            let side = shape.sides[sideindex];
            let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source);
            let ch1 = calcsidecoderbumpoutwidth32(index, sideindex, source);
            let cw1 = w1 + h + ch1;
            console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid, cw1, ch1);
            let fabmeasure = setfabmeasure31(sidecorner.index, cw1, ch1, sidecorner.sindex, cornerdesc, sidecorner.typeid);
            fabmeasurelist.push(fabmeasure);
        }
    }
}
function setfabsideshapemeasures(side, fabmeasurelist) {
    /*3. side codes 0,3 : w = side height + max(sideshapeheight) 
      4. side codes 1,2 : w = side width +  max(sideshapeheight)  */
    let sideindex = side.index;
    if (sideindex == 0) { setfabsideshapemeasure(side, 0, fabmeasurelist); }
    setfabsideshapemeasure(side, 1, fabmeasurelist);
    setfabsideshapemeasure(side, 2, fabmeasurelist);
    if (sideindex == shape.sides.length - 1) { setfabsideshapemeasure(side, 3, fabmeasurelist); }
}
function setfabsidecornermeasures(side, fabmeasurelist, prsideheight) {
    for (let i = 0; i < side.corners.length; i++) {
        if (side.corners[i].type != 0) {
            setfabsidecornermeasure(i, side.index, side.corners[i], fabmeasurelist);
        }
    }
}
function calcsidecornerbumpoutheight32(index, sideindex, source) {
    let side = shape.sides[sideindex];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let corner = side.corners[index];
    let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1,
    type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
    let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
    let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
    let angle3 = calclineangle2(x11, y11, x12, y12), angle4 = 0;
    let rpt3 = rotate_point1(sx21, sy21, asign, angle3, r);
    let vpt3 = calcverticalvectorpoint(sx21, sy21, rpt3.dx, rpt3.dy, x2, y2);
    let ch3 = applymminchfact(calchyplen(x2, y2, vpt3.dx, vpt3.dy), 2, 2, source);
    // console.log(index, sideindex, sidecode, ch3);
    //  drawpointcircle(4, index, 1, 1, vpt3.dx, vpt3.dy, 10, 'F');
    return ch3;
}
function calcsideshapebumpoutheight32(sidecode, sideindex, source) {
    let side = shape.sides[sideindex];
    let sh = 0;
    if (side.sideshapes != undefined) {
        for (let i = 0; i < side.sideshapes.length; i++) {
            let sideshape = side.sideshapes[i];
            if (sideshape.isactive == 1 && sideshape.sidecode == sidecode && sideshape.typeid != 1 && sideshape.typeid != 2 && sideshape.typeid != 3) {//bump: in,out,angle             
                let h1 = applymminchfact1(sideshape.h, 2, 2, source);
                if (h1 > sh) { sh = h1; }
            }
        }
    }
    return sh;
}
function calcfabsidebumpoutmeasures32(sideindex, source) {
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source), sindex = side.sindex;
    let ch1 = 0, ch2 = 0, ch3 = 0, ch4 = 0, sh1 = 0, sh2 = 0, sh3 = 0, sh4 = 0, sw = 0, sh = 0, measuredesc = "Bump Out", typeid = 4;

    if (side.corners[0].type == 4) { ch1 = calcsidecornerbumpoutheight32(0, sideindex, source); }
    if (side.corners[1].type == 4) { ch2 = calcsidecornerbumpoutheight32(1, sideindex, source); }
    if (sideindex == shape.sides.length - 1) {
        if (side.corners[2].type == 4) { ch3 = calcsidecornerbumpoutheight32(2, sideindex, source); }
        if (side.corners[3].type == 4) { ch4 = calcsidecornerbumpoutheight32(3, sideindex, source); }
    }
    if (sideindex == 0) { //sidecode =0
        sh1 = calcsideshapebumpoutheight32(0, sideindex, source);
    }
    sh2 = calcsideshapebumpoutheight32(1, sideindex, source);
    sh3 = calcsideshapebumpoutheight32(2, sideindex, source);
    if (sideindex == shape.sides.length - 1) { //sidecode =3
        sh4 = calcsideshapebumpoutheight32(3, sideindex, source);
    }
    let scw1 = 0, sch1 = 0, scw2 = 0, sch2 = 0;
    scw1 = Math.max(ch1, sh1, ch2);
    sch1 = Math.max(ch1, sh2, ch3);
    sch2 = Math.max(ch2, sh3, ch4);
    scw2 = Math.max(ch3, sh4, ch4);
    //console.log(ch1, ch2, ch3, ch4, sh1, sh2, sh3, sh4, scw1, sch1, sch2, scw2);
    return { scw1: scw1, scw2: scw2, sch1: sch1, sch2: sch2 };
}
function setfabsidemeasurelist32(fabmeasurelist) {  
    let source = 'setfabsidemeasurelist';
    //let prsideheight = 0;
    for (let i = 0; i < shape.sides.length; i++) {
        setfabsidemeasure(i, fabmeasurelist); // side measurements        
    }
}
function setfabshapemeasurelist() {
    let fabmeasurelist = [];
    setfabsidemeasurelist32(fabmeasurelist);
    return fabmeasurelist;
}
function setshapesidesplash(sidesplash, part, splashlist) {
    let width = sidesplash.width, height = sidesplash.height, type = sidesplash.spltype, typeid = sidesplash.typeid;
    let desc = height + '"splash';
    let metric = getcompanyunittype();
    let sqft = roundToTwo(calcsqft1(width, height, metric));
    let psplash = getpartsplashbytype(height, splashlist, type);
    if (psplash == undefined) {
        psplash = setpartsplash31(part, type, width, height, sqft, desc, typeid); splashlist.push(psplash);
    } else { psplash.Width += width; psplash.Sqft += sqft; psplash.Isactive = 1; }
    // psplash.Isactive = sidesplash.isactive;
    // console.log(sidesplash.isactive, psplash.Isactive);
}
function setpartcutout(cutout, part, cutoutlist) {
    //let type = cutout.type, width = roundToTwo(cutout.w / 4), height = roundToTwo(cutout.h / 4);
    let type = cutout.type, width = applymminchfact(cutout.w, 2, 2), height = applymminchfact(cutout.h, 2, 2);
    let typeid = getcutouttypeid(type);
    let desc = getcutouttypedesc(type, width);
    let pcutout = getpartcutoutbytype(desc, height, cutoutlist);
    if (pcutout == undefined) {
        pcutout = setpartcutout31(part, typeid, desc, width, height, cutout.shapeindex, cutout.index, cutout.sideindex);
        cutoutlist.push(pcutout);
    } else {
        pcutout.LF += 1; pcutout.Width = width; pcutout.Height = height; pcutout.Isactive = 1;
    }
    let matid = getpartmaterialid(part.PartMaterialList);
    let pbcutout = getpricebookcutouttypebyid(cutout.itemid);
    if (matid > 0 && cutout.itemid > 0 && pbcutout != undefined) {
        pcutout.Type = pbcutout.Description;
        pcutout.TypeID = pbcutout.ID;
        pcutout.ProductItemID = pbcutout.ProductItemID;
        let pricerange = getricebookpricerangeoptions(pbcutout.JsonOptions, matid, width, height);
        if (pricerange != undefined) { pbcutout = pricerange; }
    }
    if (pbcutout != undefined) {
        pcutout.UnitCost = pbcutout.Cost;
        pcutout.Margin = pbcutout.Margin;
        pcutout.Unitprice = pbcutout.Price;
    }
}

function setshapesidesplashlist(side, part, splashlist) {
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].isactive == 1) { setshapesidesplash(side.splashs[i], part, splashlist); }
    }
}
function setpartshapesplashlist(part) {
    setsplashlistinactive(part.SplashList);
    let splashlist = part.SplashList;
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidesplashlist(shape.sides[i], part, splashlist); // side
    }
    return splashlist;
}
function setpartsideedge(edge, part, edgelist, source) {
    let width = edge.width, height = edge.height, typeid = edge.typeid, type = edge.type, desc = '';
    if (type == 'U' || type == 'W' || width == 0) { return; }
    if (type == 'F') { desc = 'Finished Edge'; } else if (type == 'A') { desc = 'Appliance Edge'; } else if (type == 'E') { desc = 'Eased Edge'; } else if (type == 'M') { desc = 'Mitred Edge'; } else { desc = type; }
    let pedge;
    let metric = getcompanyunittype();
    if (typeid != 0) { pedge = getpartedgebytypeid(typeid, edgelist); }
    else { pedge = getpartedgebydesc(desc, edgelist); }
    if (pedge == undefined) { pedge = setpartedge31(part, typeid, type, desc, width, height); pedge.LF = calclinerfeet1(width, metric); edgelist.push(pedge); }
    else { pedge.LF = roundToTwo(pedge.LF + calclinerfeet1(width, metric)); pedge.Inches += width; pedge.Isactive = 1; }
}
function setpartsideshape(sideshape, part, edgelist) {
    //let width = sideshape.w / 4, height = sideshape.h / 4;
    let width = applymminchfact(sideshape.w, 2, 2), height = applymminchfact(sideshape.h, 2, 2);
    let pedge;
    if (sideshape.type != 0) { pedge = getpartedgebytypeid(sideshape.type, edgelist); }
    if (pedge == undefined) { pedge = setpartedge31(part, 0, '', '', width, height); pedge.LF = 1; edgelist.push(pedge); }
    else { pedge.LF += 1; pedge.Inches += width; pedge.Isactive = 1; }

    let pbbump = getpricebookbumplistbyid(sideshape.type);
    if (pbbump != undefined) {
        pedge.Inches = width;
        pedge.EdgeProfile = pbbump.Description;
        pedge.EdgeProfileID = pbbump.ID;
        pedge.ProductItemID = pbbump.ProductItemID;
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0) {
            let pricerange = getricebookpricerangeoptions(pbbump.JsonOptions, matid, width, height);
            if (pricerange != undefined) { pbbump = pricerange; }
        }
        pedge.UnitCost = pbbump.Cost;
        pedge.Margin = pbbump.Margin;
        pedge.UnitPrice = pbbump.Price;
    }
}
function setpartsidecorner(sidecorner, part, edgelist) {
    //let width = sidecorner.w / 4, height = sidecorner.h / 4;
    let source = 'setpartsidecorner';
    let width = applymminchfact(sidecorner.w, 2, 2, source), height = applymminchfact(sidecorner.h, 2, 2, source), rad = applymminchfact(sidecorner.r, 2, 2, source);
    let pedge;
    let metric = getcompanyunittype();
    if (sidecorner.type == 4) { height = rad; }
    if (sidecorner.type != 0) { pedge = getpartedgebytypeid1(sidecorner.typeid, edgelist, height); }
    if (pedge == undefined) { pedge = setpartedge31(part, sidecorner.typeid, '', '', width, height); pedge.LF = calclinerfeet1(width, metric); edgelist.push(pedge); }
    else { pedge.LF += calclinerfeet1(width, metric); pedge.Inches += width; pedge.Isactive = 1; }

    let pbcorner = getpricebookcornerlistbyid(sidecorner.typeid);
    if (pbcorner != undefined) {
        pedge.Inches = width;
        pedge.EdgeProfile = pbcorner.Description;
        pedge.EdgeProfileID = pbcorner.ID;
        pedge.ProductItemID = pbcorner.ProductItemID;
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0) {
            let pricerange = getricebookpricerangeoptions(pbcorner.JsonOptions, matid, width, height);
            if (pricerange != undefined) { pbcorner = pricerange; }
        }
        pedge.UnitCost = pbcorner.Cost;
        pedge.Margin = pbcorner.Margin;
        pedge.UnitPrice = pbcorner.Price;
    }
}

function setsidesideshapelist(side, part, edgelist) {
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].isactive == 1) {
            setpartsideshape(side.sideshapes[i], part, edgelist);
        }
    }
}
function setsidesidecornerlist(side, part, edgelist) {
    for (let i = 0; i < side.corners.length; i++) {
        if (side.corners[i].type != 0) {
            setpartsidecorner(side.corners[i], part, edgelist);
        }
    }
}
function setsidesplashedgelist(splash, part, edgelist) {
    if (splash.isactive == 1) {
        for (let i = 0; i < splash.edges.length; i++) { setpartsideedge(splash.edges[i], part, edgelist, 'setsidesplashedgelist'); }
    }
}
function setsidesplashsedgelist(side, part, edgelist) {
    for (let i = 0; i < side.splashs.length; i++) { setsidesplashedgelist(side.splashs[i], part, edgelist); }
}
function setsidecorneredgelist(corner, part, edgelist) {
    for (let i = 0; i < corner.edges.length; i++) {
        setpartsideedge(corner.edges[i], part, edgelist, 'setsidecorneredgelist');
    }
}

function setsideshapeedgelist(sideshape, part, edgelist) {
    for (let i = 0; i < sideshape.edges.length; i++) {
        setpartsideedge(sideshape.edges[i], part, edgelist, 'setsideshapeedgelist');
    }
}
function setshapesidecorneredgelist(side, part, edgelist) {
    for (let i = 0; i < side.corners.length; i++) { setsidecorneredgelist(side.corners[i], part, edgelist); }
}
function setsidesideshapeedgelist(side, part, edgelist) {
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].isactive == 1) { setsideshapeedgelist(side.sideshapes[i], part, edgelist); }
    }
}
function setshapesideedgelist(side, part, edgelist) {
    for (let i = 0; i < side.edges.length; i++) { setpartsideedge(side.edges[i], part, edgelist, 'setshapesideedgelist'); }
}
function setpartshapeedgelist(part) {
    setedgelistinactive(part.EdgeList);
    let edgelist = part.EdgeList;
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesideedgelist(shape.sides[i], part, edgelist);
        setsidesideshapeedgelist(shape.sides[i], part, edgelist);
        setshapesidecorneredgelist(shape.sides[i], part, edgelist);
        setsidesplashsedgelist(shape.sides[i], part, edgelist);
        setsidesideshapelist(shape.sides[i], part, edgelist);//bumps
        setsidesidecornerlist(shape.sides[i], part, edgelist);//corners
    }
    return edgelist;
}
function setshapesidescutoutlist(side, part, cutoutlist) {
    for (let i = 0; i < side.cutouts.length; i++) {
        if (side.cutouts[i].Isactive == 1) { setpartcutout(side.cutouts[i], part, cutoutlist, 'setshapesidescutoutlist'); }
    }
}
function setpartshapecutoutlist(part) {
    setcutoutlistinactive(part.CutoutList);
    let cutoutlist = part.CutoutList;
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidescutoutlist(shape.sides[i], part, cutoutlist);
    }
    return cutoutlist;
}
function setareasummary31() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    calcareasummary31(area);
}
function setchangeorderitems(part) {
    //step1:set part material
    validatesetcopartmaterial(part);
    //step2:set part measurement item
    validatesetcopartmeasurement(part);
    //step3:set part splash
    //validatesetcopartsplashs(part);
    //step4:set part edge
    //validatesetcopartedges(part);
    //step5:set part template
    valiadtesetcoparttemplateinstall(part, 1);
    //step6:set part install
    valiadtesetcoparttemplateinstall(part, 2);
}

function onaddpartshape31(source) {
    //1:set Part   
    let index = shape.index, areaid = shape.areaid, partsrno = shape.partsrno;
    let coid = getcoid();
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part == undefined) { part = setpart31(shape.index, shape.partsrno); part.show = true; part.PartCheck = 1; }
    else if (coid > 0) { setchangeorderitems(part); }
    //2: Assign shape to part
    part.Shape = shape;
    //3.set part material
    let partmat = setpartmaterial31(part);
    //3.1 duplicate shape
    if (source == "setduplicateshape31") {
        partmat.MaterialID = shape.materialid;
        let material = getmaterialbyid(partmat.MaterialID);
        resetpartmaterial32(partmat, material);
    }
    //3.2:set fab   
    let fab = setpartfab31(part, 'shape');
    //4: set shape measurements to part 
    //part.MeasureList = setfabshapemeasurelist();  //should be part.Measurelist. check with Raghu
    fab.MeasureList = setfabshapemeasurelist();
    //5: set shape splahses to part
    part.SplashList = setpartshapesplashlist(part);
    //6: set shape edges to part
    part.EdgeList = setpartshapeedgelist(part);
    //7: set shape cutouts to part   
    part.CutoutList = setpartshapecutoutlist(part);
    //8: set shape fabrication to part     
    fab.PartSqft = calcpartfabsqft31(fab);
    fab.SplashSqft = calcpartsplashstotalsqft31(part.SplashList);
    partmat.Sqft = fab.PartSqft + fab.SplashSqft; partmat.Qty = partmat.Sqft; fab.JobSplashSf = fab.SplashSqft;
    //9: set shape template to part
    setparttemplateinstall31(part, 1, fab.PartSqft + fab.SplashSqft);//template
    //10:set shape install to part.    
    setparttemplateinstall31(part, 2, fab.PartSqft + fab.SplashSqft);//install
    //11.labor unitytpe sqft
    restsetpartlaborqty31(part.LaborList, part.AreaID, fab.PartSqft + fab.SplashSqft);
    //12.set unused materials
    setunusedmaterial32();
    //13.set part area summary
    calcpartversionsummary(part);
    //14:flag
    setchangeflag();
    selectpartbysrno(shape.partsrno);
    //15:jason string
    part.Shape = jasonpartshape(shape);
}
function onupdatepartshape31() {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let area = getareabyid(areaid);
    if (part != undefined) {
        part.Shape = jasonpartshape(shape); part.SaveFlag = 1; area.SaveFlag = 1;
        setchangeflag();
    }
}
function onpartshapeactive31(source) {
    setpartactive(shape.index);
    resetareapartssrno();
    setchangeflag();
    selectpartbysrno(shape.partsrno);
}
function onpartshaperemove31(index, source) {
    setpartinactive(index);
    resetareapartssrno();
    setchangeflag();
    selectpartbysrno(-1);
    setareasummary31();
}
function onaddpartsinkcutout31(sinkId, source) {
    let sinkinfo = getpricebooksinkcutoutbyid(sinkId);
    let part = getpartbyareapartsrno(shape.partsrno, shape.areaid);
    if (part != undefined) {
        let coid = getcoid();
        let cosrno = getcosrno();
        let sinkpercent = getsinktaxpercent();
        setpartsink2(part, sinkinfo, coid, cosrno, sinkpercent);
    }
}

function onaddpartseam31(index, sideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let slabpartseam = JSON.parse(JSON.stringify(shape.sides[sideindex].seams[index]));
    let spsideindex = slabpartseam.spsideindex;
    let pshapeside = part.Shape.sides[spsideindex];
    let psideseams = [];
    let sw = 0;

    slabpartseam.index = psideseams.length;
    slabpartseam.spseamindex = psideseams.length;
    pshapeside.seams.push(slabpartseam);
    //reorder and index
    //console.log(index, sideindex, spsideindex, part.SrNo, pshapeside.seams.length);   
    for (let i = 0; i < pshapeside.seams.length; i++) {
        if (pshapeside.seams[i].isactive == 1 && pshapeside.seams[i].sw <= slabpartseam.sw && pshapeside.seams[i].type != 2) {
            //console.log(index, sideindex, spsideindex, part.SrNo, pshapeside.seams.length, pshapeside.seams[i].sw, slabpartseam.sw);
            pshapeside.seams[i].index = psideseams.length;
            pshapeside.seams[i].spseamindex = psideseams.length;
            if (pshapeside.seams[i].split == 1) { sw = pshapeside.seams[i].sw; }
            psideseams.push(pshapeside.seams[i]);
        }
    }
    if (sw > 0 && slabpartseam.type != 2) { slabpartseam.sw += sw; }
    for (let i = 0; i < pshapeside.seams.length; i++) {
        if (pshapeside.seams[i].isactive == 1 && pshapeside.seams[i].sw > slabpartseam.sw && pshapeside.seams[i].type != 2) {
            // console.log(index, sideindex, spsideindex, part.SrNo, pshapeside.seams.length, pshapeside.seams[i].sw, slabpartseam.sw);
            pshapeside.seams[i].index = psideseams.length;
            pshapeside.seams[i].spseamindex = psideseams.length;
            psideseams.push(pshapeside.seams[i]);
        }
    }
    for (let i = 0; i < pshapeside.seams.length; i++) {
        if (pshapeside.seams[i].isactive == 1 && pshapeside.seams[i].type == 2) {
            pshapeside.seams[i].index = psideseams.length;
            pshapeside.seams[i].spseamindex = psideseams.length;
            psideseams.push(pshapeside.seams[i]);
        }
    }
    //  console.log(JSON.stringify(psideseams));
    pshapeside.seams = psideseams;
    setchangeflag();
}
function onupdatepartseam31(index, sideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let slabpartseam = JSON.parse(JSON.stringify(shape.sides[sideindex].seams[index]));
    let spsideindex = slabpartseam.spsideindex, spseamindex = slabpartseam.spseamindex;
    let pshapeside = part.Shape.sides[spsideindex];
    pshapeside.seams[spseamindex] = slabpartseam;
    setchangeflag();
}
function setpartshapeseamslabpart31(spseamindex, spsideindex, partshape, source) {
    let areaid = partshape.areaid, partsrno = partshape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        part.Shape.sides[spsideindex].seams[spseamindex].split = 1;
        part.Shape.slabparts = shape.slabparts;
        setchangeflag();
    }
}
function setpartshapeslabpart31(source) {
    //1. getpartby part id and area id
    //2. update slabaprt from shape 
    let areaid = shape.areaid, partsrno = shape.partsrno, spindex = shape.spindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let slabpart = part.Shape.slabparts[spindex];
        slabpart.tx = shape.tx;
        slabpart.ty = shape.ty;
        slabpart.angle = shape.angle;
        slabpart.color = shape.color;
        slabpart.slabindex = shape.slabindex;
        slabpart.slabid = shape.slabid;
        setchangeflag();
        let area = getareabyid(areaid);
        setareasaveflag(area);
    }
}
function ondeletepartseam31(spseamindex, spsideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let pshapeside = part.Shape.sides[spsideindex];
        let psideseams = [];
        for (let i = 0; i < pshapeside.seams.length; i++) {
            if (pshapeside.seams[i].isactive == 1 && pshapeside.seams[i].spseamindex != spseamindex) {
                pshapeside.seams[i].index = i;
                pshapeside.seams[i].spseamindex = i;
                psideseams.push(pshapeside.seams[i]);
            }
        }
        pshapeside.seams = psideseams;
        setchangeflag();
    }
}
function ondeletepartslabpart31(source) {
    let areaid = shape.areaid, partsrno = shape.partsrno, spindex = shape.spindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let slabpart = shape.slabparts[spindex];
    let spseamindex = slabpart.spseamindex, spsideindex = slabpart.spsideindex;
    if (part != undefined) {
        let partshape = part.Shape;
        partshape.sides[spsideindex].seams[spseamindex].split = 0;
        let pslabparts = [];
        //console.log(JSON.stringify(partshape.slabparts));
        for (let i = 0; i < partshape.slabparts.length; i++) {
            //console.log(partshape.slabparts[i].index, spindex);
            if (partshape.slabparts[i].index != spindex) {
                partshape.slabparts[i].index = i;
                pslabparts.push(partshape.slabparts[i]);
            }
        }
        partshape.slabparts = pslabparts;
        setchangeflag();
        //console.log(JSON.stringify(partshape.slabparts));
    }
}

function checkseamtype(spsideindex, smtype) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let pshapeside = part.Shape.sides[spsideindex];
        for (let j = 0; j < pshapeside.seams.length; j++) {
            if (pshapeside.seams[j].isactive == 1 && pshapeside.seams[j].type != smtype) {
                return false;
            }
        }
    }
    return true;
}
function ispartsideseamsplit(spsideindex) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let pshapeside = part.Shape.sides[spsideindex];
        for (let j = 0; j < pshapeside.seams.length; j++) {
            if (pshapeside.seams[j].isactive == 1 && pshapeside.seams[j].split == 1) {
                return true;
            }
        }
    }
    return false;
}
function setpartshapeslabsplash31(source) {
    //1. getpartby part id and area id
    //2. update slabaprt from shape 
    let spseamindex = shapeslabsplash.spseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let pshapeslabsplash = part.Shape.sides[spsideindex].splashs[spsplashindex].slabsplashs[splindex];
        pshapeslabsplash.tx = shapeslabsplash.tx;
        pshapeslabsplash.ty = shapeslabsplash.ty;
        pshapeslabsplash.angle = shapeslabsplash.angle;
        pshapeslabsplash.spseamindex = spseamindex;
        pshapeslabsplash.spsplashindex = spsplashindex;
        pshapeslabsplash.spsideindex = spsideindex;
        pshapeslabsplash.splindex = splindex;
        pshapeslabsplash.partsrno = partsrno;
        pshapeslabsplash.areaid = areaid;
        pshapeslabsplash.color = shapeslabsplash.color;
        pshapeslabsplash.slabindex = shapeslabsplash.slabindex;
        pshapeslabsplash.slabid = shapeslabsplash.slabid;
        setchangeflag();
        //  console.log(shapeslabsplash.tx, shapeslabsplash.ty, pshapeslabsplash.tx, pshapeslabsplash.ty, source);
    }
}
function onaddpartsplashseam31(index, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index]));
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    let psplashseams = [];
    let sw = 0;
    for (let i = 0; i < pshapesplash.seams.length; i++) {
        if (pshapesplash.seams[i].isactive == 1 && pshapesplash.seams[i].sw < slabsplashseam.sw) {
            pshapesplash.seams[i].index = i;
            pshapesplash.seams[i].spseamindex = i;
            if (pshapesplash.seams[i].split == 1) { sw = pshapesplash.seams[i].sw; }
            psplashseams.push(pshapesplash.seams[i]);
        }
    }
    slabsplashseam.index = psplashseams.length;
    slabsplashseam.spseamindex = psplashseams.length;
    psplashseams.push(slabsplashseam);
    if (sw > 0) { slabsplashseam.sw += sw; }
    for (let i = 0; i < pshapesplash.seams.length; i++) {
        if (pshapesplash.seams[i].isactive == 1 && pshapesplash.seams[i].sw > slabsplashseam.sw) {
            pshapesplash.seams[i].index = i;
            pshapesplash.seams[i].spseamindex = i;
            psplashseams.push(pshapesplash.seams[i]);
        }
    }
    //  console.log(index, splashindex, spsplashindex, spsideindex, splindex, areaid, partsrno, pshapesplash.seams.length);
    pshapesplash.seams = psplashseams;
    //console.log(JSON.stringify(pshapesplash));
    setchangeflag();
}
function onupdatepartsplashseam31(index, sideindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index])), spseamindex = slabsplashseam.spseamindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    pshapesplash.seams[spseamindex] = slabsplashseam;
    // console.log(index, spseamindex,  sideindex, pshapesplash.seams.length, source);
    setchangeflag();
}
function onseampartsplash31(spseamindex, spsideindex, source) {
    //console.log(spseamindex, spsideindex, source);
    let spsplashindex = shapeslabsplash.spsplashindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashs = JSON.parse(JSON.stringify(shapeslabsplash.slabsplashs));
    let part = getpartbyareapartsrno(partsrno, areaid);
    //let slabsplash = shapeslabsplash.slabsplashs[index];
    part.Shape.sides[spsideindex].splashs[spsplashindex].seams[spseamindex].split = 1;
    part.Shape.sides[spsideindex].splashs[spsplashindex].slabsplashs = slabsplashs;
    setchangeflag();
}
function onupdatepartshapeszoom32() {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    if (partlist != null && partlist.length > 0) {
        for (let i = 0; i < partlist.length; i++) {
            if (partlist[i].IsActive == 1 && partlist[i].Shape != null && partlist[i].Shape != 'null') {
                partlist[i].Shape.tscale = zscale;
            }
        }
    }
    setchangeflag();
}