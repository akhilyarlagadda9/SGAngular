function getareaid(index) {
    let areaid = -1;
    let area = getareabyindex(index);
    if (area != null) { areaid = area.ID; }
    return areaid;
}
function getareabyid(areaid) {
    let areas = getversionareas();
    for (let i = 0; i < areas.length; i++) {
        if (areas[i].ID == areaid) {
            return areas[i];
        }
    }
    return "";
}
function getareaunits(index) {
    let areaunits = 0;
    let area = getareabyindex(index);
    if (area != null) { areaunits = area.NoOfUnits; }
    return areaunits;
}
function getpartlist(areaindex) {
    let areapartlist = [];
    let area = getareabyindex(areaindex);
    if (area != null && area.PartList != null) { areapartlist = area.PartList; }
    return areapartlist;
}
function getpartwithshapelist(areaindex) {
    let areapartlist = [];
    let area = getareabyindex(areaindex);
    if (area != null && area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) {
            if (area.PartList[i].Shape != null && area.PartList[i].Shape != '') {
                areapartlist.push(area.PartList[i]);
            }
        }
        //areapartlist = area.PartList;
    }
    return areapartlist;
}

function getpartlength(areaindex) {
    let partlist = getpartlist(areaindex);
    return partlist.length;
}
function getpartbypartindex(index) {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    if (partlist.length > index) {
        return partlist[index];
    }
}
function getpartbypartsrno(partlist, partsrno) {
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].SrNo == partsrno && partlist[i].IsActive == 1) {
            return partlist[i];
        }
    }
}
function getpartbypartid(partlist, partid) {
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].ID == partid) {
            return partlist[i];
        }
    }
}
function getpartbyareapartid(partid, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        return getpartbypartid(area.PartList, partid);
    }
}
function getpartbyareapartsrno(partsrno, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        return getpartbypartsrno(area.PartList, partsrno);
    }
}
function getpartshapebyareapartsrno(partsrno, areaid) {
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        let part = getpartbypartsrno(area.PartList, partsrno);
        if (part != undefined && part != "") {
            let pshape = parsepartshape(part.Shape);
            pshape.partsrno = part.SrNo;
            pshape.partid = part.ID;
            pshape.areaid = part.AreaID;
            pshape.materialid = getpartmaterialid(part.PartMaterialList);
            pshape.unitcount = area.NoOfUnits;
            return pshape;
        }
    }
}
function getpartmaterialidbyareapartid(partid, partsrno, areaid) {
    let area = getareabyid(areaid);
    let matid = 0;
    for (let i = 0; i < area.PartList.length; i++) {
        if (area.PartList[i].ID == partid && area.PartList[i].SrNo == partsrno) {
            return getpartmaterialid(area.PartList[i].PartMaterialList);
        }
    }
    return matid;
}
function getpartshapecopybyareaidpartsrno(partsrno, areaid) { //used for slabpart
    let area = getareabyid(areaid);
    if (area != null && area.PartList != null) {
        let part = getpartbypartsrno(area.PartList, partsrno);
        //let pshape = JSON.parse(JSON.stringify(part.Shape));
        let pshape = JSON.parse(jasonpartshape(part.Shape));
        return pshape;
    }
}
function getlastactivepartsrno() {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    let partsrno = 0;
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            partsrno = partlist[i].SrNo;
        }
    }
    return partsrno;
}
function getpartsrno(parts) {
    let partsrno = 1;
    if (parts != null && parts.length > 0) {
        for (let i = 0; i < parts.length; i++) {
            if (parts[i].IsActive == 1) {
                partsrno += 1;
            }
        }
    }
    return partsrno;
}
function getpartmaterialid(partmats) {
    let materialid = 0; let coid = getcoid();
    if (partmats != null && partmats.length > 0) {
        for (let i = 0; i < partmats.length; i++) {
            if (partmats[i].IsOptional == 0 && partmats[i].IsChg != 2 && partmats[i].CoID == coid) {
                return partmats[i].MaterialID;
            }
        }
        //materialid = partmats[partmats.length - 1].MaterialID;
    }
    return materialid;
}
function getpartmaterial32(partmats) {
    let coid = getcoid();
    if (partmats != null && partmats.length > 0) {
        for (let i = 0; i < partmats.length; i++) {
            if (partmats[i].IsOptional == 0 && partmats[i].IsChg != 2 && partmats[i].CoID == coid) {
                return partmats[i];
            }
        }
    }
}
function getshapebypartindex(index) {
    let areaindex = getareaindex();
    return setshapeareapartinfo(index, areaindex); // set should not be in get functions any better way??
}
function getshapebypartsrno(partsrno) {
    let areaindex = getareaindex();
    return setshapeareapartinfo(index, areaindex);// set should not be in get functions any better way??
}
function parsepartshape(unpshape) {
    let tmppartshape = {};
    if (typeof (unpshape) == 'string' && unpshape != '' && unpshape != 'null') {
        tmppartshape = JSON.parse(unpshape);
    } else if (typeof (unpshape) == 'object') {
        tmppartshape = unpshape;
    }
    if (tmppartshape != null && tmppartshape.length > 0) { tmppartshape = tmppartshape[0]; }
    return tmppartshape;
}
function jasonpartshape(partshape) {
    let tmppartshape = {};
    if (typeof (partshape) == 'object') {
        tmppartshape = JSON.stringify(partshape);
    } else {
        tmppartshape = partshape;
    }
    return tmppartshape;
}
function getpartedgebytypeid(typeid, edgelist) {
    for (let i = 0; i < edgelist.length; i++) {
        if (edgelist[i].EdgeProfileID == typeid) {
            return edgelist[i];
        }
    }
}
function getpartedgebytypeid1(typeid, edgelist, height) {
    //console.log(typeid, height, JSON.stringify(edgelist));
    for (let i = 0; i < edgelist.length; i++) {     
        if (typeid == 10 && edgelist[i].Height == height) {//circle shape
            return edgelist[i];
        } else if (edgelist[i].EdgeProfileID == typeid) {
            return edgelist[i];
        }
    }
}
function getpartedgebydesc(desc, edgelist) {
    if (desc == undefined) { return;}
    for (let i = 0; i < edgelist.length; i++) {
        //console.log(i, desc, edgelist[i].EdgeProfile, edgelist[i].EdgeProfile.toLowerCase(), desc.toLowerCase());
        if (edgelist[i].EdgeProfile != undefined && edgelist[i].EdgeProfile.toLowerCase() == desc.toLowerCase()) { return edgelist[i]; }
    }
}
function getpartsplashbytype(height, splashlist, typeid) {
    for (let i = 0; i < splashlist.length; i++) {
        if (splashlist[i].Height == height && splashlist[i].TypeID == typeid) { return splashlist[i]; }
    }
}
function getpartcutoutbytype(type, height, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        //console.log(type, JSON.stringify(cutoutlist[i]));
        if (cutoutlist[i].Type == type) {           
            return cutoutlist[i]
        }
    }
}
function getpartcutoutbytypeold(cutoutshapeindex, cutoutindex, cutoutsideindex, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        let cut = cutoutlist[i];
        if (cut.ShapeID == cutoutshapeindex && cut.SrNo == cutoutindex && cut.SIndex == cutoutsideindex) { return cut; }
        else if (cut.ShapeID == cutoutshapeindex && cut.SrNo == cutoutindex) { return cut; }
    }
}
function getpartcutoutbyitemid(typeid, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        //console.log(typeid, JSON.stringify(cutoutlist[i]));
        if (cutoutlist[i].TypeID == typeid) {
            return cutoutlist[i]
        }
    }
}
function getpartcutoutholebytype(type, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        if (cutoutlist[i].Type == type) {
            return cutoutlist[i]
        }
    }
}
function getcutouttypeid(type) {
    let typeid = 1;
    if (type == "outlet1" || type == "outlet2" || type == "outlet3" ) { typeid = 2; } else if (type == 'ckt4b' || type == 'ckt5b') { typeid = 3; }
    return typeid;
}
function getpricebookcutouttypebyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.cutoutlist != null) {
        for (var i = 0; i < pricebook.cutoutlist.length; i++) {
            let cutout = pricebook.cutoutlist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}
function getpricebookcutoutholesbyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.holeslist != null) {
        return pricebook.holeslist[0];
        //for (var i = 0; i < pricebook.holeslist.length; i++) {
        //    let cutout = pricebook.holeslist[i];
        //    if (cutout.ID == itemid) {
        //        return cutout;
        //    }
        //}
    }
}
function getcutouttypedesc(cutouttype, width) {
    let desc = 'Undermount';
    if (cutouttype == 'cor') { desc = 'Outlet' }
    else if (cutouttype == 'crf') { desc = 'FARM' }
    else if (cutouttype == 'crd') { desc = 'Drop-In' }
    else if (cutouttype == 'rc') { desc = 'Cooktop' }
    desc = '1 - ' + width + '" ' + desc;
    return desc;
}
function getparttemplateinstallbydesc(laborlist, desc) {
    let plabor;
    for (let i = 0; i < laborlist.length; i++) {
        if (laborlist[i].Description == desc && laborlist[i].ViewTypeID == 1 && laborlist[i].Isactive == 1) {
            plabor = laborlist[i];
        }
    }
    return plabor;
}
function getcutoutpricebyrange(width, type) {
    let pricebook = getqscopepricebook();
    if (pricebook.cutoutlist != null) {
        for (var i = 0; i < pricebook.cutoutlist.length; i++) {
            let cutout = pricebook.cutoutlist[i];
            if (type == "cor" && cutout.Description == "Outlet") { return cutout; }//outlet
            else if (type == "crf" && cutout.Description == "Apron/Farm Sink Cutout (Prem EP)") { return cutout; }//farm
            else if (type == "crd" && cutout.Description == "Drop-In") { return cutout; }//dropin
            else if (type == "rc" && cutout.Description == "Cooktop") { return cutout; }//dropin
                //else if (width >= cutout.MinWidth && width <= cutout.MaxWidth) { return cutout; }
            else if (width == cutout.MaxWidth) { return cutout; }
        }
    }
}
function getricebookpricerangeoptions(priceoptions, materialid, width, height) {
    let material = getmaterialbyid(materialid);
    if (priceoptions != undefined && priceoptions != null && priceoptions != 'null' && priceoptions != '') {
        let tmppriceoptions = []; let duplicateoptions = [];
        if (typeof (priceoptions) == 'string') { tmppriceoptions = JSON.parse(priceoptions); }
        for (let i = 0; i < tmppriceoptions.length; i++) {
            let popt = tmppriceoptions[i];
            let isbool = checkpropertiesofpriceoption34(popt, material);
            if (isbool == true && width >= Number(popt.RangeMin) && width <= Number(popt.RangeMax)) {
                duplicateoptions.push(popt);
            }
        }
        return getpricingfromduplicates34(duplicateoptions, material, width);
    }
}
function getricebookpricerangeoptionswithoutrange(pbfablist, materialid) {
    let pricerange;
    let material = getmaterialbyid(materialid);
    if (pbfablist != undefined && pbfablist != null && pbfablist != 'null' && pbfablist != '') {
        pricerange =  getpricingfrommaterial33(pbfablist, material, materialid,'');
    }
    return pricerange
}
function getpricingfrompbook33(pbfablist, material,source) {
    let pricerange;
    if (pbfablist != undefined && pbfablist != null && pbfablist != 'null' && pbfablist != '') {
        pricerange = getpricingfrommaterial33(pbfablist, material, material.ID, source);
    }
    return pricerange;
}
function getpricingfrommaterial33(pbfablist, material, materialId, source) {
        //let tmppriceoptions = []; 
    let duplicateoptions = [];
    let risklevelid = getpricebookdefaultrisklevelid();
        //if (typeof (priceoptions) == 'string') { tmppriceoptions = JSON.parse(priceoptions); }
        for (let i = 0; i < pbfablist.length; i++) {
            let popt = pbfablist[i];
            let isbool = checkpropertiesofpriceoption(popt, material, materialId, risklevelid, source);
            if (isbool == true) {
                duplicateoptions.push(popt);
            }
    }
    let pricerange;
    if (materialId == 0 && source != 'matinfo') {
        pricerange =  getrisklevelpricingfromduplicates33(duplicateoptions, risklevelid)
    } else {
        pricerange = getpricingfromduplicateswithoutrange(duplicateoptions, material, risklevelid)
    }
    return pricerange;
}
function getpricingfromduplicateswithoutrange(duplicateoptions, mat) {
    let pricerange;
    if (duplicateoptions.length == 1) {
        pricerange = duplicateoptions[0];
    } else {
        //get default pricing and duplicate group list from duplicates
        let result = getdefaultfromduplicates33(duplicateoptions, mat);
        pricerange = result.priceobj;
        let subgrouppricinglist = result.subgrouplist;
        if (subgrouppricinglist.length == 1) {
            pricerange = subgrouppricinglist[0];
        } else {
            //get pricing from duplicate thisckness
            let thisckneslist = getthiscknesslistfromgroup33(subgrouppricinglist, mat);
            if (thisckneslist.length == 1) {
                pricerange = subgrouppricinglist[0];
            }
            else {
                for (let i = 0; i < thisckneslist.length; i++) {
                    let popt = thisckneslist[i];
                    //check with unique price subgroup
                    if ((popt.ThicknessID == mat.DepthID) && (popt.RiskLevelID == mat.RiskLevelID)) {
                        pricerange = popt;
                    }
                }
            }
           
        }

    }
    return pricerange;
}
function getduplicatesubgroups33(duplicateoptions, mat) {
    let subgrouppricinglist = [];
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        //check with unique price group
        if ((popt.MatGroupID == mat.ProGroupID) && (popt.MatSubGroupID == mat.ProSubGroupID || popt.MatSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID)) {
            subgrouppricinglist.push(popt);
        }
    }
    return subgrouppricinglist;
}
function getthiscknesslistfromgroup33(duplicateoptions, mat) {
    let thicknesslist = [];
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        //check with unique price group
        if ((popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID)) {
            thicknesslist.push(popt);
        }
    }
    return thicknesslist;
}
function getdefaultfromduplicates33(duplicateoptions, mat) {
    let priceobj= { cost: 0, Margin: 0, price: 0 };
    let model = { pricing: priceobj,subgrouplist:[]}
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        //check with unique price group
        if ((popt.MatGroupID == mat.ProGroupID || popt.MatGroupID == 0) && (popt.MatSubGroupID == mat.ProSubGroupID || popt.MatSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID)) {
            model.pricing = popt;
        }
        //check groups
        if ((popt.MatGroupID == mat.ProGroupID) && (popt.MatSubGroupID == mat.ProSubGroupID || popt.MatSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID)) {
            model.subgrouplist.push(popt);
        }
    }
    return model;
}
function getrisklevelpricingfromduplicates33(duplicateoptions, risklevelid) {
    let pricerange;
    if (duplicateoptions.length == 1) {
        pricerange = duplicateoptions[0];
    }
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        if (popt.RiskLevelID == risklevelid) {
            pricerange = popt; 
        }
    }
    return pricerange;
}
function getpricingfromduplicates(duplicateoptions, mat, width) {
    if (duplicateoptions.length == 1) {
        return duplicateoptions[0];
    }
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        if (popt.MatGroupID == mat.ProGroupID && popt.MatSubGroupID == mat.ProSubGroupID && popt.ThicknessID == mat.DepthID && popt.RiskLevelID == mat.RiskLevelID && (width >= Number(popt.RangeMin) && width <= Number(popt.RangeMax))) {
            return popt;
        }
    }
}
function checkpropertiesofpriceoption(popt, mat, matId, risklevelid, source) {
    let isbool = false;
    if (matId == 0 && source != 'matinfo') {
        if ((popt.MatGroupID == mat.ProGroupID || popt.MatGroupID == 0) && (popt.MatSubGroupID == mat.ProSubGroupID || popt.MatSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == risklevelid)) {
            isbool = true;
        }
    } else {
        if ((popt.MatGroupID == mat.ProGroupID || popt.MatGroupID == 0) && (popt.MatSubGroupID == mat.ProSubGroupID || popt.MatSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID)) {
            isbool = true;
        }
    }
    
    return isbool;
}

function getpricingfromduplicates34(duplicateoptions, mat, width) {
    if (duplicateoptions.length == 1) {
        return duplicateoptions[0];
    }
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        if (popt.ProductGroupID == mat.ProGroupID && popt.ProductSubGroupID == mat.ProSubGroupID && popt.ThicknessID == mat.DepthID && width >= Number(popt.RangeMin) && width <= Number(popt.RangeMax)) {
            return popt;
        }
    }
}
function checkpropertiesofpriceoption34(popt, mat) {
    let isbool = false;
    if (mat != null && mat != '') {
        if ((popt.ProductGroupID == mat.ProGroupID || popt.ProductGroupID == 0) && (popt.ProductSubGroupID == mat.ProSubGroupID || popt.ProductSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID || popt.RiskLevelID == 0)) {
            isbool = true;
        }
    } else {
        isbool = true;
    }
    return isbool;
}
function getpricingfromduplicateswithoutrange34(duplicateoptions, mat) {
    let pricerange; let allpricerange
    let isrange = 0;
    if (duplicateoptions.length == 1) {
        pricerange = duplicateoptions[0];
    }
    for (let i = 0; i < duplicateoptions.length; i++) {
        let popt = duplicateoptions[i];
        if ((popt.ProductGroupID == mat.ProGroupID || popt.ProductGroupID == 0) && (popt.ProductSubGroupID == mat.ProSubGroupID || popt.ProductSubGroupID == 0) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID || popt.RiskLevelID == 0)) {
            if (isrange == 0) {
                allpricerange = popt; isrange = 1;
            }
        }
        if ((popt.ProductGroupID == mat.ProGroupID) && (popt.ProductSubGroupID == mat.ProSubGroupID) && (popt.ThicknessID == mat.DepthID || popt.ThicknessID == 0) && (popt.RiskLevelID == mat.RiskLevelID || popt.RiskLevelID == 0)) {
            pricerange = popt; isrange = 2;
        }
    }
    pricerange = isrange == 1 ? allpricerange : pricerange;
    return pricerange;
}

function getpricebookbumplistbyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.defaultbumplist != null) {
        for (var i = 0; i < pricebook.defaultbumplist.length; i++) {
            let cutout = pricebook.defaultbumplist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}
function getpricebookcornerlistbyid(itemid) {
    let pricebook = getqscopepricebook();
    if (pricebook.defaultcornerlist != null) {
        for (var i = 0; i < pricebook.defaultcornerlist.length; i++) {
            let cutout = pricebook.defaultcornerlist[i];
            if (cutout.ID == itemid) {
                return cutout;
            }
        }
    }
}
function getedgeheightbythickness(typeid) {
    let height = 0;
    if (typeid != 0) {
        let pricebookedge = getpbedgebyprofileid(typeid);
        if (pricebookedge != undefined) {
            if (pricebookedge.ThicknessID > 0 && height == 0) {
                let str = pricebookedge.Thickness.match(/\d+/);
                height = convertToFloat(str[0]);
            }
        }
    }
    return height;
}
function getedgeheightbyid(typeid) {
    let height = 0;
    if (typeid != 0) {
        let pricebookedge = getpbedgebyprofileid(typeid);
        if (pricebookedge != undefined) { height = pricebookedge.Height; }        
        //if (pricebookedge.ThicknessID > 0 && height == 0) {
        //    let str = pricebookedge.Thickness.match(/\d+/);
        //    height = convertToFloat(str[0]);
        //}
    }
    return height;
}
function getfirstmaterialfromareaparts(areaid) {
    let materialid = 0;
    let area = getareabyid(areaid);
    if (area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) {
            let part = area.PartList[i];
            materialid = getmaterialfrompartmats(part.PartMaterialList);
            if (materialid > 0) { return materialid; }
        }
    }
    return materialid;
}
function getfirstmaterialfromareaparts33(areaid) {
    let materialid = 0;
    let area = getareabyid(areaid);
    if (area.AreaMaterialList != null) {
        for (let i = 0; i < area.AreaMaterialList.length; i++) {
            let mat = area.AreaMaterialList[i];
            if (mat.AreaID == areaid && mat.TypeID == 0 && mat.IsOptional == 0) {
                materialid = mat.MaterialID;
                return materialid;
            }
        }
    }
    return materialid;
}
function getfirstmaterialfromarea33(area) {
    let materialid = 0;
    if (area.AreaMaterialList != null) {
        for (let i = 0; i < area.AreaMaterialList.length; i++) {
            let mat = area.AreaMaterialList[i];
            if (mat.AreaID == area.ID && mat.TypeID == 0 && mat.IsOptional == 0) {
                materialid = mat.MaterialID;
                return materialid;
            }
        }
    }
    return materialid;
}

function getmaterialfrompartmats(pmats) {
    let materialid = 0;
    if (pmats != null) {
        for (let i = 0; i < pmats.length; i++) {
            if (pmats[i].MaterialID > 0 && pmats[i].IsOptional == 0 && pmats[i].IsChg != 2) {
                return pmats[i].MaterialID;
            }          
        }
    }
    return materialid;
}
function getmafabprice(areaid, matid) {
    let area = getareabyid(areaid);
    getmafabpriceByarea(area, matid);
}
function getmafabpriceByarea(area, matid) {
    if (area != null && area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) {
            let part = area.PartList[i];
            if (part.IsActive == 1) {
                let partfab = getpartfab(part.PartFabList, matid);
                if (partfab != undefined) {
                    return partfab;
                }
            }
        }
    }
}
function gettempinstallpricefrompart(area, matid, typeId) {
    if (area != null && area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) {
            let part = area.PartList[i];
            if (part.IsActive == 1) {
                let partmat = getpartmaterial33(part.PartMaterialList, matid);
                if (partmat != undefined) {
                    let partlabor = getfablaborfromlaborlist33(part.LaborList, typeId, partmat.CoID);
                    return partlabor;
                }
            }
        }
    }
}
function getpartfab(fabs, matid) {
    if (fabs != null) {
        for (let i = 0; i < fabs.length; i++) {
            if (fabs[i].MaterialID == matid) {
                return fabs[i];
            }
        }
    }
}

function setpart31(index, partsrno) {
    let userid = getloginuserId();
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let versionid = area.VersionID;
    let phaseid = 0;
    let areaid = area.ID;
    let coid = getcoid();
    let cosrno = getcosrno();
    let roundup = area.SqftRoundUp;
    let part = initpart();
    part.SrNo = partsrno;
    part.AreaID = areaid;
    part.CoID = coid;
    part.VersionID = versionid;
    part.UserID = userid;
    part.RoundUp = roundup;
    part.PartCheck = 0;
    part.show = false;
    part.AreaUnits = area.NoOfUnits;
    if (area.PartList == null) { area.PartList = []; }
    area.PartList.push(part);
    area.show1 = true;
    area.SaveFlag = 1;
    area.AreaCheck = 1;
    return part;
}
function setshapeareapartinfo(partindex, areaindex) {
    let area = getareabyindex(areaindex);
    let partlist = area.PartList;
    let part = partlist[partindex];
    let pshape = parsepartshape(part.Shape);
    pshape.partsrno = part.SrNo;
    pshape.partid = part.ID;
    pshape.areaid = part.AreaID;
    pshape.areaindex = (areaindex + 1);
    pshape.unitcount = area.NoOfUnits;
    return pshape;
}
function setshapeareainfo(pshape, areaindex) {
    let area = getareabyindex(areaindex);
    pshape.areaindex = (areaindex + 1);
    pshape.areaid = area.ID;
    pshape.unitcount = area.NoOfUnits;
    return pshape;
}
function resetareapartssrno() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let partlist = getpartlist(areaindex);
    let partsrno = 1;
    area.SaveFlag = 1;
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            partlist[i].PrevSrNo = partlist[i].SrNo;
            partlist[i].SrNo = partsrno;
            partsrno++;
        }
    }
}
function resetareapartssrno31(areaid) {
    let area = getareabyid(areaid);
    let partsrno = 1;
    for (let i = 0; i < area.PartList.length; i++) {
        if (area.PartList[i].IsActive == 1) {
            area.PartList[i].PrevSrNo = partsrno;  area.PartList[i].SrNo = partsrno; area.SaveFlag = 1;
            partsrno++;
        }
    }
}
function setpartmaterial31(part) {
    let pmat;
    if (part.PartMaterialList.length == 0 && part.ID == 0) {
        pmat = initmaterial();
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = getmattaxpercent();
        pmat.AreaID = part.AreaID; pmat.VersionID = part.VersionID;
        pmat.AreaUnits = part.AreaUnits;
        pmat.RoundUp = part.RoundUp;
        pmat.CoID = coid; pmat.CoSrNo = cosrno; pmat.Tax = taxperc > 0 ? 1 : 0;
        pmat.PartSrNo = part.SrNo; pmat.PartShape = part.Shape != "" && part.Shape != null ? "shape" : "";
        pmat.MaterialID = getfirstmaterialfromareaparts33(pmat.AreaID);
        if (pmat.MaterialID > 0) { let material = getmaterialbyid(pmat.MaterialID); resetpartmaterial32(pmat, material); }
        part.PartMaterialList.push(pmat);
    } else if (part.PartMaterialList != null) {
        //let pcount = part.PartMaterialList.length; pmat = part.PartMaterialList[pcount - 1];
        pmat = getpartmaterial32(part.PartMaterialList);
    }
    return pmat;
}
function setpartfab31(part, source) {
    let fab;
    let matid = getpartmaterialid(part.PartMaterialList);
    if (part.PartFabList.length == 0 && part.ID == 0) {
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = getfabtaxpercent();
        fab = initfab();
        fab.AreaID = part.AreaID;
        fab.AreaUnits = part.AreaUnits;
        fab.RoundUp = part.RoundUp;
        fab.VersionID = part.VersionID;
        let fabchk = checkfabactive(part.AreaID);//fab inactive case
        fab.FabIsActive = fabchk == 0 ? 0 : 1;
        fab.CoID = coid;
        fab.CoSrNo = cosrno;
        fab.Tax = taxperc > 0 ? 1 : 0;
        fab.UnitCost = 0;
        fab.Margin = 0;
        fab.UnitPrice = 0;
        fab.MaterialID = matid;
        fab.PartSrNo = part.SrNo;
        fab.PartShape = part.Shape != "" && part.Shape != null ? "shape" : "";
        if (source == 'quote') { let fabmeasure = initfabmeasure(); if (fab.MeasureList == null) { fab.MeasureList = []; } fab.MeasureList.push(fabmeasure); }
        let area = getareabyid(fab.AreaID);
        setpartfabdegaultprice34(fab, area);
        part.PartFabList.push(fab);
    }
    else if (part.PartFabList != null) { let pcount = part.PartFabList.length; fab = part.PartFabList[pcount - 1]; }
    return fab;
}
function checkfabactive(areaid) {
    let area = getareabyid(areaid);
    if (area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) {
            let part = area.PartList[i];
            for (let j = 0; j < part.PartFabList.length; j++) {
                if (part.PartFabList[j].FabIsActive == 0) {
                    return 0;
                }
            }
        }
    }
}
function setpartfabdegaultprice34(fab, area) {
    // if (matid > 0) {
    let pbresklevel = { cost: 0, Margin: 0, price: 0, description:"" };
    let pricebook = getpricebook();
    if (pricebook.fablist != null) {
        let pricerange = getricebookpricerangeoptionswithoutrange(pricebook.fablist, fab.MaterialID);
        if (pricerange != undefined) { pbresklevel = { cost: pricerange.Cost, margin: pricerange.Margin, price: pricerange.Price, description: pricerange.Description}; }
    }
    let partmatfabprice = getmafabpriceByarea(area, fab.MaterialID);
    if (partmatfabprice != undefined) {
        fab.UnitCost = partmatfabprice.UnitCost;
        fab.Margin = partmatfabprice.Margin;
        fab.LaborUnitPrice = partmatfabprice.LaborUnitPrice;
        fab.Description = partmatfabprice.Description;
        fab.IsPriceChg = 1;
    }
    else if (pbresklevel != undefined) {
        let desc = pbresklevel.description == null || pbresklevel.description == "" ? "Fabrication" : pbresklevel.description;
        fab.UnitCost = pbresklevel.cost; fab.Margin = pbresklevel.margin; fab.IsPriceChg = 1;
        fab.LaborUnitPrice = pbresklevel.price; fab.Description = desc;
    } else {
        fab.Description = "Fabrication";
    }
}
function setpartfab34(part, source) {
    let fab;
    let pbresklevel = { cost: 0, Margin: 0, price: 0 };
    let matid = getpartmaterialid(part.PartMaterialList);
    if (part.PartFabList.length == 0 && part.ID == 0) {
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = getfabtaxpercent();
        fab = initfab();
        fab.AreaID = part.AreaID;
        fab.AreaUnits = part.AreaUnits;
        fab.RoundUp = part.RoundUp;
        fab.VersionID = part.VersionID;
        fab.FabIsActive = 1;
        fab.CoID = coid;
        fab.CoSrNo = cosrno;
        fab.Tax = taxperc > 0 ? 1 : 0;
        fab.UnitCost = 0;
        fab.Margin = 0;
        fab.UnitPrice = 0;
        fab.MaterialID = matid;
        fab.PartSrNo = part.SrNo;
        fab.PartShape = part.Shape != "" && part.Shape != null ? "shape" : "";
        if (source == 'quote') { let fabmeasure = initfabmeasure(); if (fab.MeasureList == null) { fab.MeasureList = []; } fab.MeasureList.push(fabmeasure); }
        part.PartFabList.push(fab);
    }
    else if (part.PartFabList != null) { let pcount = part.PartFabList.length; fab = part.PartFabList[pcount - 1]; }
    if (matid > 0) {
        let pricebook = getpricebook();
        if (pricebook.fablist != null) {
            let pricerange = getricebookpricerangeoptionswithoutrange(pricebook.fablist, matid);
            if (pricerange != undefined) { pbresklevel = { cost: pricerange.Cost, margin: pricerange.Margin, price: pricerange.Price }; }
        }

        //pbresklevel = getmaterialfabrictionprice(matid);
        //if (pbresklevel != undefined) {
        //    let pricerange = getricebookpricerangeoptionswithoutrange(pbresklevel.JsonOptions, matid);
        //    if (pricerange != undefined) { pbresklevel = { cost: pricerange.Cost, margin: pricerange.Margin, price: pricerange.Price }; }
        //}
    } else if (matid == 0) { pbresklevel = getpricebookrisklevel31(0); }
    if (pbresklevel != undefined) {
        fab.UnitCost = pbresklevel.cost; fab.Margin = pbresklevel.margin; fab.IsPriceChg = 1;
        fab.LaborUnitPrice = pbresklevel.price; //fab.Description = pbresklevel.Description;
    }
    return fab;
}
function setfabmeasure31(index, w, h, sindex, stype, stypeid) {
    let fabmeasure = {};
    let metricmode = getmetrictypeid();
    fabmeasure.Width = w; fabmeasure.Height = h; fabmeasure.Sqft = calcsqft1(w, h, metricmode);
    fabmeasure.shapeindex = sindex; fabmeasure.index = index; fabmeasure.CounterType = stype; fabmeasure.CounterTypeID = stypeid;
    return fabmeasure;
}
function setpartsplash311(part, type, sqft, sidesplash) {
    let psplash = initsplash();
    let taxperc = gettaxpercent();
    let matid = getpartmaterialid(part.PartMaterialList);
    let issplashlf = getpricebooksplashlf();
    let coid = getcoid();
    let cosrno = getcosrno();
    psplash.MaterialID = matid;
    psplash.AreaID = part.AreaID;
    psplash.AreaUnits = part.AreaUnits;
    psplash.RoundUp = part.RoundUp;
    psplash.VersionID = part.VersionID;
    psplash.TypeID = type == undefined ? 0 : type;
    psplash.Tax = taxperc > 0 ? 1 : 0;;
    psplash.PartSrNo = part.SrNo;
    psplash.PartShape = (part.Shape != "" && part.Shape != null) ? "shape" : "";
    psplash.PartName = part.Name;
    psplash.Sqft = sqft;
    psplash.CopyQty = sqft;
    psplash.SplashID = 0;
    psplash.CoID = coid;
    psplash.CoSrNo = cosrno;
    //1.side splash shape
    psplash.Width = sidesplash.width;
    psplash.Height = sidesplash.height;
    psplash.SrNo = sidesplash.index;
    psplash.SideCode = sidesplash.sidecode;
    psplash.SideIndex = sidesplash.sideindex;

    //2.item description default
    let itemname = psplash.TypeID == 0 ? "Backsplash" : psplash.TypeID == 1 ? ' Apron' : psplash.TypeID == 2 ? ' Mitered' : ' Laminated';
    psplash.Splash = itemname + " " + sidesplash.height + '"' + "tall";

    //3.check pricebook item by itemid or height
    let pricebkitem = "";
    if (sidesplash.typeid > 0) { pricebkitem = getpbitembyid(sidesplash.typeid, psplash.TypeID); }//apron-1,mitered-2,laminated-3
    else { pricebkitem = getpbitembyheight(sidesplash.height, psplash.TypeID); }

    //set pricing
    if (pricebkitem != undefined) {
        psplash.SplashID = pricebkitem.ID;
        psplash.Splash = pricebkitem.Description;
        //sf pricing
        if (psplash.SFPrice == 0) {
            let pbresklevel = { Cost: 0, Margin: 0, Price: 0 };
            if (matid > 0 && pricebkitem != undefined) {
                let pricerange = getsplashpricebasedonmaterial(pricebkitem.JsonOptions, matid);
                if (pricerange != undefined) { pbresklevel = pricerange; }
            }
            psplash.SFCost = pbresklevel.Cost; psplash.SFMargin = pbresklevel.Margin; psplash.SFPrice = pbresklevel.Price;
        }
        //lf pricing
        if (issplashlf == 1) {
            psplash.LF = roundToTwo(calclinerfeet1(psplash.Width, 0)); psplash.JobSplashLF = psplash.LF; psplash.CopyLF = psplash.LF;
            if (psplash.UnitPrice == 0) {
                psplash.UnitCost = pricebkitem.Cost; psplash.Margin = pricebkitem.Margin; psplash.UnitPrice = pricebkitem.Price;
            }
        }
    }
    return psplash;
}
function setpartsplash31(part, type, width, height, sqft, desc, itemid) {
    let psplash = initsplash(); 
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    let matid = getpartmaterialid(part.PartMaterialList);
    let metric = getcompanyunittype();
    psplash.AreaID = part.AreaID;
    psplash.AreaUnits = part.AreaUnits;
    psplash.RoundUp = part.RoundUp;
    psplash.VersionID = part.VersionID;
    psplash.CoID = coid;
   psplash.CoSrNo = cosrno;
    psplash.TypeID = type == undefined ? 0 : type;
    psplash.Tax = taxperc > 0 ? 1 : 0;;
    psplash.Width = width;
    psplash.PartSrNo = part.SrNo;
    psplash.PartShape = part.Shape != "" && part.Shape != null ? "shape" : "";
    psplash.PartName = part.Name;
    psplash.Height = height;
    psplash.Sqft = sqft;
    psplash.CopyQty = sqft;
    let spname = metric == 1 ? " MM" + " Splash Back" : "'' Back Splash";
    let metricmode = metric == 1 ? " MM " : "''";
    let itemname = psplash.TypeID == 1 ? ' Apron' : psplash.TypeID == 2 ? ' Mitered' : ' Laminated';
    let pricebkitem = "";
    if (itemid > 0) {
        pricebkitem = getpbitembyid(itemid, psplash.TypeID);        
    } else {
        pricebkitem = getpbitembyheight(height, psplash.TypeID);
    }
    psplash.SplashID = pricebkitem != undefined ? pricebkitem.ID : 0;
    if (psplash.TypeID > 0) {//apron-1,mitered-2,laminated-3
        let desc = pricebkitem == undefined ? itemname : pricebkitem.Description; psplash.Splash = height > 0 ? height + metricmode + desc : desc;
    } else if (height > 0 && itemid > 0 && pricebkitem != undefined) {
        psplash.Splash = pricebkitem.Description;
    } else if (height > 0){
        psplash.Splash = height + spname;
    }

    //splash price
    if (pricebkitem != undefined && psplash.SFPrice == 0) {
        let pbresklevel = { Cost: pricebkitem.Cost, Margin: pricebkitem.Margin, Price: pricebkitem.Price };
        if (matid > 0 && pricebkitem != undefined) {
            let pricerange = getsplashpricebasedonmaterial(pricebkitem.JsonOptions, matid);
            if (pricerange != undefined) { pbresklevel = pricerange; }
        }
        psplash.SFCost = pbresklevel.Cost;
        psplash.SFMargin = pbresklevel.Margin;
        psplash.SFPrice = pbresklevel.Price;
    }

    //splaash linear price
    let issplashlf = getpricebooksplashlf();
    if (issplashlf == 1) {
        psplash.LF = roundToTwo(calclinerfeet1(psplash.Width, 0)); psplash.JobSplashLF = psplash.LF; psplash.CopyLF = psplash.LF;
        if (pricebkitem != undefined && psplash.SFPrice == 0) {
            psplash.UnitCost = pricebkitem.Cost;
            psplash.Margin = pricebkitem.Margin;
            psplash.UnitPrice = pricebkitem.Price;
            psplash.SplashID = pricebkitem.ID;
        }      
    }
    psplash.MaterialID = matid;
    psplash.SrNo = part.SplashList.length + 1;
    return psplash;
}
function getsplashpricebasedonmaterial(priceoptions, materialid) {
    let material = getmaterialbyid(materialid);
    if (priceoptions != undefined && priceoptions != null && priceoptions != 'null' && priceoptions != '') {
        let tmppriceoptions = []; let duplicateoptions = [];
        if (typeof (priceoptions) == 'string') { tmppriceoptions = JSON.parse(priceoptions); }
        for (let i = 0; i < tmppriceoptions.length; i++) {
            let popt = tmppriceoptions[i];
            let isbool = checkpropertiesofpriceoption34(popt, material);
            if (isbool == true) {
                duplicateoptions.push(popt);
            }
        }
        return getpricingfromduplicateswithoutrange34(duplicateoptions, material);
    }
}
function setpartedge31(part, typeid, type, desc, w, h) {
    let pedge = initedge();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    let metric = getcompanyunittype();
    let pricebookedge;
    pedge.UnitTypeID = 112;//LF(or)LM
    pedge.UnitType = metric == 1 ? 'LM' : 'LF';
    pedge.AreaID = part.AreaID;
    pedge.AreaUnits = part.AreaUnits;
    pedge.RoundUp = part.RoundUp;
    pedge.VersionID = part.VersionID;
    pedge.CoID = coid;
    pedge.CoSrNo = cosrno;
    pedge.Tax = taxperc > 0 ? 1 : 0;
    pedge.Width = roundToTwo(w);
    pedge.Inches = roundToTwo(w);
    pedge.Height = roundToTwo(h);
    pedge.PartSrNo = part.SrNo;
    pedge.PartShape = (part.Shape != "" && part.Shape != null) ? "shape" : "";
    pedge.PartName = part.Name;
    pedge.EdgeProfileID = typeid;
    if (typeid != 0) {
        pricebookedge = getpbedgebyprofileid(typeid); if (pricebookedge != undefined) { desc = pricebookedge.Description; }
        let matid = getpartmaterialid(part.PartMaterialList);
        if (pricebookedge != undefined) {
            let pricerange = getricebookpricerangeoptions(pricebookedge.JsonOptions, matid, pedge.Width, pedge.Height);
            if (pricerange != undefined) {
                //pricebookedge = pricerange;
                if (pricerange.Price != 0) { pedge.UnitCost = pricerange.Cost; pedge.Margin = pricerange.Margin; pedge.UnitPrice = pricerange.Price; }
            } else if (pricebookedge.Price != 0) {
                pedge.UnitCost = pricebookedge.Cost; pedge.Margin = pricebookedge.Margin; pedge.UnitPrice = pricebookedge.Price;
            }
        }
    }
    else if (desc != '') {
        pricebookedge = getpbedgebydesc(desc);
        if (pricebookedge != undefined) {
            desc = pricebookedge.Description;
            if (pricebookedge.Price != 0) { pedge.UnitCost = pricebookedge.Cost; pedge.Margin = pricebookedge.Margin; pedge.UnitPrice = pricebookedge.Price; }
        }
    }
    if (pricebookedge != undefined) {
        pedge.Path = pricebookedge.ProductPath;
        pedge.UnitTypeID = pricebookedge.UnitTypeID;
        pedge.IsSqft = pricebookedge.IsEdgeSF;
        pedge.Height = pricebookedge.Height;      
    }
    pedge.EdgeProfile = desc; pedge.Description = desc;
    pedge.SrNo = part.EdgeList.length + 1;
    return pedge;
}
function setpartcutout31(part, typeid, type, width, height, sindex, cindex, sideindex) {
    let pcutout = initcutout();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    pcutout.ID = 0;
    pcutout.AreaID = part.AreaID;
    pcutout.AreaUnits = part.AreaUnits;
    pcutout.RoundUp = part.RoundUp;
    pcutout.VersionID = part.VersionID;
    pcutout.CoID = coid;
    pcutout.CoSrNo = cosrno;
    pcutout.Tax = taxperc > 0 ? 1 : 0;;
    pcutout.CutOutTypeID = typeid;
    pcutout.Type = type;
    pcutout.Width = width;
    pcutout.Height = height;
    pcutout.LF = 1;//qty??? 
    pcutout.ShapeID = sindex;//shape index
    pcutout.SrNo = cindex == undefined ? part.CutoutList.length + 1 : cindex;//cutout index
    pcutout.SIndex = sideindex;//shape sideindex  
    pcutout.PartSrNo = part.SrNo;
    pcutout.PartShape = part.Shape != "" && part.Shape != null ? "shape" : "";
    pcutout.PartName = part.Name;
    return pcutout;
}
function setparttemplateinstall31(part, typeid, qty) {
    let desc = typeid == 1 ? 'Template' : "Install";
    let plabor = getparttemplateinstallbydesc(part.LaborList, desc);
    let materialid = getpartmaterialid(part.PartMaterialList);
    if (plabor == undefined) {
        plabor = initlabor();
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = gettaxpercent();
        plabor.ViewTypeID = 1;
        plabor.UnitTypeID = 2;
        plabor.Qty = qty;
        plabor.Description = desc;
        plabor.AreaID = part.AreaID;
        plabor.AreaUnits = part.AreaUnits;
        plabor.RoundUp = part.RoundUp;
        plabor.VersionID = part.VersionID;
        plabor.CoID = coid;
        plabor.CoSrNo = cosrno;
        plabor.Tax = taxperc > 0 ? 1 : 0;
        plabor.PartSrNo = part.SrNo;
        // if (materialid > 0) {
        let area = getareabyid(plabor.AreaID);
        setparttemplateinstalldegaultprice34(plabor, materialid, typeid, area);
        part.LaborList.push(plabor);
    } else {
        plabor.Qty = qty;
    }
}
function setparttemplateinstalldegaultprice34(plabor, materialid, typeid, area) {
    let pbresklevel = { cost: 0, Margin: 0, price: 0 };
    let tempinstallprice = gettempinstallpricefrompart(area, materialid, typeid);
    if (tempinstallprice != undefined) {
        plabor.UnitCost = tempinstallprice.UnitCost;
        plabor.Margin = tempinstallprice.Margin;
        plabor.UnitPrice = tempinstallprice.UnitPrice;
        plabor.IsPriceChg = 1;
    }
    else {
        let pricebook = getpricebook();
        let pblist = typeid == 1 ? pricebook.templatelist : pricebook.installlist;
        if (pblist != null) {
            let pricerange = getricebookpricerangeoptionswithoutrange(pblist, materialid);
            if (pricerange != undefined) { pbresklevel = { cost: pricerange.Cost, margin: pricerange.Margin, price: pricerange.Price }; }
        }
        settempinstallprice(plabor, pbresklevel);
    }
}
function setparttemplateinstall34(part, typeid, qty) {
    let desc = typeid == 1 ? 'Template' : "Install";
    let plabor = getparttemplateinstallbydesc(part.LaborList, desc);
    let materialid = getpartmaterialid(part.PartMaterialList);
    let pbresklevel = { cost: 0, Margin: 0, price: 0 };
    if (materialid > 0) {
        pbresklevel = typeid == 1 ? getmaterialtemplateprice(materialid) : getmaterialinstallprice(materialid);
        if (pbresklevel != undefined) {
            let pricerange = getricebookpricerangeoptionswithoutrange(pbresklevel.JsonOptions, materialid);
            if (pricerange != undefined) { pbresklevel = { cost: pricerange.Cost, Margin: pricerange.Margin, price: pricerange.Price }; }
        }
    } else if (materialid == 0) {
        pbresklevel = getpricebookrisklevel31(typeid);
    }
    if (plabor == undefined) {
        plabor = initlabor();
        let coid = getcoid();
        let cosrno = getcosrno();
        let taxperc = gettaxpercent();
        plabor.ViewTypeID = 1;
        plabor.UnitTypeID = 2;
        plabor.Qty = qty;
        plabor.Description = desc;
        plabor.AreaID = part.AreaID;
        plabor.AreaUnits = part.AreaUnits;
        plabor.RoundUp = part.RoundUp;
        plabor.VersionID = part.VersionID;
        plabor.CoID = coid;
        plabor.CoSrNo = cosrno;
        plabor.Tax = taxperc > 0 ? 1 : 0;
        plabor.PartSrNo = part.SrNo;
        settempinstallprice(plabor, pbresklevel);
        part.LaborList.push(plabor);
    } else {
        settempinstallprice(plabor, pbresklevel);
        plabor.Qty = qty;
    }
}
function settempinstallprice(plabor, pbresklevel) {
    if (pbresklevel != undefined) {
        plabor.UnitCost = pbresklevel.cost;
        plabor.Margin = pbresklevel.Margin;
        plabor.UnitPrice = pbresklevel.price;
        plabor.IsPriceChg = 1;
    }
}
function setpartinactive(index) {
    let part = getpartbypartindex(index);
    if (part != null) {
        part.IsActive = 0;
        // inactive part items
        InactivePartItems33(part);
    }
}
function setpartactive(index) {
    let part = getpartbypartindex(index);
    if (part != null) { part.IsActive = 1; }
}
function setedgelistinactive(edgelist) {
    for (let i = 0; i < edgelist.length; i++) { edgelist[i].Isactive = 0; edgelist[i].LF = 0; edgelist[i].Inches = 0; edgelist[i].Width = 0; edgelist[i].Height = 0; edgelist[i].Sqft = 0; }
}
function setcutoutlistinactive(cutoutlist) {
    let index = 0;
    for (let i = 0; i < cutoutlist.length; i++) {
        if (cutoutlist[i].Isactive = 1) { cutoutlist[i].SrNo = index; index++;}
            cutoutlist[i].Isactive = 0; cutoutlist[i].LF = 0; }
}
function setsplashlistinactive(splashlist) {
    for (let i = 0; i < splashlist.length; i++) {
        if (splashlist[i].IsChg != 2) { splashlist[i].Isactive = 0; splashlist[i].Sqft = 0; splashlist[i].LF = 0; splashlist[i].Width = 0; }
    }
}
function setfabsidemeasureold(sideindex, fabmeasurelist) {
    //console.log(sideindex, shape.sides.length, JSON.stringify(fabmeasurelist));
    let source = 'setfabsidemeasure';
    ///*1. Side sqft cal: Rectangle box approach is used to cal side sqft. Side means rectangle box with 4 side codes(0,1,2,3). 
    //  2. Side width: w = max(w1,w2); max of side codes 1 or 2;  */
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 2, source),  w = 0;    
    if (sideindex == 0) {
        w = Math.max(w1, w2);
    } else if (sideindex < shape.sides.length - 1) {
        w = Math.min(w1, w2);
    } else if (sideindex == shape.sides.length - 1) {
        if (shape.sides.length > 2) {
            let side1 = shape.sides[sideindex - 2];
            let x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12, x3 = side1.x11, y3 = side1.y11, x4 = side1.x12, y4 = side1.y12;
            let angle = 0, angle1 = 0, angle2 = 0;
            angle1 = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
            angle2 = calclineangle2(x4, y4, x3, y3, 'calcshapeangle');
            angle = Math.abs(angle1 - angle2);
            if (angle < 90) { w = Math.max(w1, w2); } else { w = Math.min(w1, w2); }
        } else {
            w = Math.max(w1, w2);
        }
    }   
    let swh = calcfabsidebumpoutmeasures32(sideindex, source);     
    let sw = w + swh.scw1 + swh.scw2, sh = h + swh.sch1 + swh.sch2;
    //console.log(sideindex, sw, sh, swh.sw, swh.sh);
    let fabmeasure = setfabmeasure31(side.index, roundToTwo(sw), roundToTwo(sh), side.sindex, side.stype, side.stypeid);
    fabmeasurelist.push(fabmeasure);
}
function setfabsidemeasure34(sideindex, fabmeasurelist) {
    //console.log(sideindex, shape.sides.length, JSON.stringify(fabmeasurelist));
    let source = 'setfabsidemeasure';
    ///*1. Side sqft cal: Rectangle box approach is used to cal side sqft. Side means rectangle box with 4 side codes(0,1,2,3). 
    //  2. Side width: w = max(w1,w2); max of side codes 1 or 2;  */
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 2, source), w = 0, angle = 0, angle1 = 0, angle2 = 0;
    if (sideindex == 0) {
        w = Math.max(w1, w2);
    } else if (shape.sides.length == 2) {
        w = Math.min(w1, w2);
    } else {
        if ((sideindex - 2) >= 0) {
            let side1 = shape.sides[sideindex - 2];
            let x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12;
            let x3 = side1.x11, y3 = side1.y11, x4 = side1.x12, y4 = side1.y12;
            angle1 = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
            angle2 = calclineangle2(x3, y3, x4, y4, 'calcshapeangle');
            angle = Math.abs(angle1 - angle2);
            if (angle > 90) {
                w = Math.max(w1, w2);
                if (sideindex < shape.sides.length - 1) {
                    let side2 = shape.sides[sideindex + 1];
                    let h2 = applymminchfact1(side2.h, 2, 2, source);
                    //w -= h2;
                }
            } else { w = Math.min(w1, w2); }
            //console.log("sideindex:" + sideindex, "angle:" + angle, "angle1:" + angle1, "angle2:" + angle2, "w:" + w, "w1:" + w1, "w2:" + w2, "sidelen:" + shape.sides.length);
        } else {
            angle = calcshapeangle(sideindex - 1);
            if (sideindex == shape.sides.length - 1) { w = Math.max(w1, w2); } else { w = Math.min(w1, w2); }
            //console.log("sideindex:" + sideindex, "angle:" + angle,  "w:" + w, "w1:" + w1, "w2:" + w2, "sidelen:" + shape.sides.length);
        }
    }
    let swh = calcfabsidebumpoutmeasures32(sideindex, source);
    let sw = w + swh.scw1 + swh.scw2, sh = h + swh.sch1 + swh.sch2;
    //console.log(sideindex, sw, sh, swh.sw, swh.sh);
    let fabmeasure = setfabmeasure31(side.index, roundToTwo(sw), roundToTwo(sh), side.sindex, side.stype, side.stypeid);
    fabmeasurelist.push(fabmeasure);
}
function setfabsidemeasure(sideindex, fabmeasurelist) {
    //console.log(sideindex, shape.sides.length, JSON.stringify(fabmeasurelist));
    let source = 'setfabsidemeasure';
    ///*1. Side sqft cal: Rectangle box approach is used to cal side sqft. Side means rectangle box with 4 side codes(0,1,2,3). 
    //  2. Side width: w = max(w1,w2); max of side codes 1 or 2;  */
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 2, source), w = 0;
    if (sideindex == 0) {
        w = Math.max(w1, w2);
    } else {
        let side1 = shape.sides[sideindex - 1];
        let x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12, x3 = side1.x11, y3 = side1.y11, x4 = side1.x12, y4 = side1.y12;
        let angle = calcshapeangle(sideindex - 1);
        //console.log(sideindex, angle, w1, w2);
        if (angle == 90) {
            if (shape.sides.length == 2) { w = Math.min(w1, w2); }
            else {
                if (sideindex == shape.sides.length - 1) { w = Math.max(w1, w2); } else { w = Math.min(w1, w2); }
            }
        } else { w = Math.max(w1, w2); }
    }
    let swh = calcfabsidebumpoutmeasures32(sideindex, source);
    let sw = w + swh.scw1 + swh.scw2, sh = h + swh.sch1 + swh.sch2;
    //console.log(sideindex, sw, sh, swh.sw, swh.sh);
    let fabmeasure = setfabmeasure31(side.index, roundToTwo(sw), roundToTwo(sh), side.sindex, side.stype, side.stypeid);
    fabmeasurelist.push(fabmeasure);
}
function setfabsideshapemeasure(side, sidecode, fabmeasurelist) {
    /*3. side codes 0,3 : w = side height + max(sideshapeheight) 
      4. side codes 1,2 : w = side width +  max(sideshapeheight)  */
    let source = 'setfabsideshapemeasure'; let stype = side.stype;
    if (side.sideshapes != undefined) {
        let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source), bpush = false, sw = 0, sh = 0, cangle = 0, sideindex = side.index;
        if (sideindex > 0) { cangle = calcshapeangle(sideindex - 1); }
        for (let i = 0; i < side.sideshapes.length; i++) {
            let sideshape = side.sideshapes[i];
            if (sideshape.isactive == 1 && sideshape.sidecode == sidecode && sideshape.typeid != 1 && sideshape.typeid != 2 && sideshape.typeid != 3) {//bump: in,out,angle
                bpush = true;
                let h1 = applymminchfact1(sideshape.h, 2, 2, source); sw = applymminchfact1(sideshape.w, 2, 0, source);
                if (h1 > sh) { sh = h1; }
                if (sidecode == 0 || sidecode == 3) { sw = h; }
                else if (sidecode == 1 || sidecode == 2) { if (sideindex < shape.sides.length - 1) { sw = Math.min(w1, w2); } else { sw = Math.max(w1, w2); } }
                if (sideshape.typeid == 4) { stype = 'Bump Out'; } else if (sideshape.typeid == 5) { stype = 'Bump Out Angle'; } else if (sideshape.typeid == 6) { stype = 'Bump Out Arc'; }
                else if (sideshape.typeid == 11) { stype = 'Full Arc'; }
            }
        }
        if (bpush) {
            let fabmeasure = setfabmeasure31(side.index, sw, sh, side.sindex, stype, side.stypeid);
            fabmeasurelist.push(fabmeasure);
        }
    }
}
function setfabsidecornermeasure(index, sideindex, sidecorner, fabmeasurelist) {
    let source = 'setfabsidecornermeasure';
    let cw = applymminchfact(sidecorner.w, 2, 2, source), ch = applymminchfact(sidecorner.h, 2, 2, source), cr = applymminchfact(sidecorner.r, 2, 2, source);
    let cornerdesc = '', cw1 = 0;
    if (sidecorner.type == 1) { cornerdesc = 'Clip Corner'; } else if (sidecorner.type == 2) { cornerdesc = 'Radius Corner'; }
    else if (sidecorner.type == 3) { cornerdesc = 'Notch Corner'; } else if (sidecorner.type == 4) { cornerdesc = 'Bump Out Corner'; }
    // console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
    if (sidecorner.type == 4) { ch = cr; } // for bump out use r/depth to cal. sq.ft
    if (sideindex > 0 && sidecorner.index == 1) {
        //   console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
        let fabmeasure = setfabmeasure31(sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
        fabmeasurelist.push(fabmeasure);
    } else {
        if (sidecorner.type == 1) {//bumpout corner , clip   
            let fabmeasure = setfabmeasure31(sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid);
            fabmeasurelist.push(fabmeasure);
        }
        else if (sidecorner.type == 4) {//bumpout corner , clip   
            let side = shape.sides[sideindex];
            let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source);
            let ch1 = calcsidecoderbumpoutwidth32(index, sideindex, source);
            let cw1 = w1 + h + ch1;
            console.log(sideindex, sidecorner.index, cw, ch, sidecorner.sindex, cornerdesc, sidecorner.typeid, cw1, ch1);
            let fabmeasure = setfabmeasure31(sidecorner.index, cw1, ch1, sidecorner.sindex, cornerdesc, sidecorner.typeid);
            fabmeasurelist.push(fabmeasure);
        }
    }
}
function setfabsideshapemeasures(side, fabmeasurelist) {
    /*3. side codes 0,3 : w = side height + max(sideshapeheight) 
      4. side codes 1,2 : w = side width +  max(sideshapeheight)  */
    let sideindex = side.index;
    if (sideindex == 0) { setfabsideshapemeasure(side, 0, fabmeasurelist); }
    setfabsideshapemeasure(side, 1, fabmeasurelist);
    setfabsideshapemeasure(side, 2, fabmeasurelist);
    if (sideindex == shape.sides.length - 1) { setfabsideshapemeasure(side, 3, fabmeasurelist); }
}
function setfabsidecornermeasures(side, fabmeasurelist, prsideheight) {
    for (let i = 0; i < side.corners.length; i++) {
        if (side.corners[i].type != 0) {
            setfabsidecornermeasure(i, side.index, side.corners[i], fabmeasurelist);
        }
    }
}
function calcsidecornerbumpoutheight32(index, sideindex, source) {
    let side = shape.sides[sideindex];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let corner = side.corners[index];
    let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1,
    type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
    let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
    let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
    let angle3 = calclineangle2(x11, y11, x12, y12), angle4 = 0;
    let rpt3 = rotate_point1(sx21, sy21, asign, angle3, r);
    let vpt3 = calcverticalvectorpoint(sx21, sy21, rpt3.dx, rpt3.dy, x2, y2);
    let ch3 = applymminchfact(calchyplen(x2, y2, vpt3.dx, vpt3.dy), 2, 2, source);
    // console.log(index, sideindex, sidecode, ch3);
    //  drawpointcircle(4, index, 1, 1, vpt3.dx, vpt3.dy, 10, 'F');
    return ch3;
}
function calcsideshapebumpoutheight32(sidecode, sideindex, source) {
    let side = shape.sides[sideindex];
    let sh = 0;
    if (side.sideshapes != undefined) {
        for (let i = 0; i < side.sideshapes.length; i++) {
            let sideshape = side.sideshapes[i];
            if (sideshape.isactive == 1 && sideshape.sidecode == sidecode && sideshape.typeid != 1 && sideshape.typeid != 2 && sideshape.typeid != 3) {//bump: in,out,angle             
                let h1 = applymminchfact1(sideshape.h, 2, 2, source);
                if (h1 > sh) { sh = h1; }
            }
        }
    }
    return sh;
}
function calcfabsidebumpoutmeasures32(sideindex, source) {
    let side = shape.sides[sideindex];
    let w1 = side.w1, w2 = side.w2, h = applymminchfact1(side.h, 2, 0, source), sindex = side.sindex;
    let ch1 = 0, ch2 = 0, ch3 = 0, ch4 = 0, sh1 = 0, sh2 = 0, sh3 = 0, sh4 = 0, sw = 0, sh = 0, measuredesc = "Bump Out", typeid = 4;

    if (side.corners[0].type == 4) { ch1 = calcsidecornerbumpoutheight32(0, sideindex, source); }
    if (side.corners[1].type == 4) { ch2 = calcsidecornerbumpoutheight32(1, sideindex, source); }
    if (sideindex == shape.sides.length - 1) {
        if (side.corners[2].type == 4) { ch3 = calcsidecornerbumpoutheight32(2, sideindex, source); }
        if (side.corners[3].type == 4) { ch4 = calcsidecornerbumpoutheight32(3, sideindex, source); }
    }
    if (sideindex == 0) { //sidecode =0
        sh1 = calcsideshapebumpoutheight32(0, sideindex, source);
    }
    sh2 = calcsideshapebumpoutheight32(1, sideindex, source);
    sh3 = calcsideshapebumpoutheight32(2, sideindex, source);
    if (sideindex == shape.sides.length - 1) { //sidecode =3
        sh4 = calcsideshapebumpoutheight32(3, sideindex, source);
    }
    let scw1 = 0, sch1 = 0, scw2 = 0, sch2 = 0;
    scw1 = Math.max(ch1, sh1, ch2);
    sch1 = Math.max(ch1, sh2, ch3);
    sch2 = Math.max(ch2, sh3, ch4);
    scw2 = Math.max(ch3, sh4, ch4);
    //console.log(ch1, ch2, ch3, ch4, sh1, sh2, sh3, sh4, scw1, sch1, sch2, scw2);
    return { scw1: scw1, scw2: scw2, sch1: sch1, sch2: sch2 };
}
function setfabsidemeasurelist32(fabmeasurelist) {
    let dflag = getversiondrawingflag(); 
    for (let i = 0; i < shape.sides.length; i++) {// side measurements   
        if (dflag == 1) {
            setfabmeasure30(i, fabmeasurelist);
        } else {
            setfabsidemeasure34(i, fabmeasurelist);
        }
    }
}
function setfabmeasure30(sideindex, fabmeasurelist) {
    let source = 'setfabmeasure30';
    let side = shape.sides[sideindex];
    //let w1 = side.w1, w2 = side.w2, sw = (w1 + w2) / 2, sh = side.h / 4;//version3.0

    let w1 = side.w1, w2 = side.w2, cangle = 0;//version3.2
    width = Math.max(w1, w2);
    height = rounddecimal(side.h / scale);
    if (sideindex == 0) {
        width = Math.max(w1, w2);
    } else {
        let angle = calcshapeangle(sideindex - 1);
        if (angle == 90) {
            if (shape.sides.length == 2) { width = Math.min(w1, w2); }
            else {
                if (sideindex == shape.sides.length - 1) { width = Math.max(w1, w2); } else { width = Math.min(w1, w2); }
            }
        } else { width = Math.max(w1, w2); }
    }
    let fabmeasure = setfabmeasure31(side.index, roundToTwo(width), roundToTwo(height), side.sindex, side.stype, side.stypeid);
    fabmeasurelist.push(fabmeasure);
}
function setfabshapemeasurelist() {
    let fabmeasurelist = [];
    setfabsidemeasurelist32(fabmeasurelist);
    return fabmeasurelist;
}

function getpartsplashbysplashshape(index, sidecode, sideindex, typeid, itemid, splashlist) {
    for (let i = 0; i < splashlist.length; i++) {
        let spl = splashlist[i];
        if (spl.SrNo == index && spl.SideIndex == sideindex && spl.SideCode == sidecode && spl.TypeID == typeid && spl.IsChg != 2) {//0-splash,1-apron,2-miter,4-laminated
            return spl;
        }
    }
}
function setshapesidesplash(sidesplash, part, splashlist) {
    //console.log(JSON.stringify(sidesplash));
    let width = sidesplash.width, height = sidesplash.height, type = sidesplash.spltype, itemid = sidesplash.typeid;
    let metric = getcompanyunittype();
    let sqft = roundToTwo(calcsqft1(width, height, metric));
    let lnft = calclinerfeet1(width, metric);
    if (type == undefined || type == '') { type = 0; }
    let itemname = type == 0 ? "Backsplash" : type == 1 ? ' Apron' : type == 2 ? ' Mitered' : ' Laminated';
    let coid = getcoid();
    //let psplash = getpartsplashbytype(height, splashlist, type);
    let psplash = getpartsplashbysplashshape(sidesplash.index, sidesplash.sidecode, sidesplash.sideindex, type, itemid, splashlist);  
    let issplashlf = getpricebooksplashlf();
    if (psplash == undefined) {
        psplash = setpartsplash311(part, type, sqft, sidesplash);
        psplash.SplashID = itemid;
        psplash.Shape = JSON.stringify(sidesplash);
        splashlist.push(psplash);
       
    } else {
        if (psplash.IsChg != 2) {
            psplash.Splash = psplash.Height != height ? itemname + " " + height + '"' + "tall" : psplash.Splash;
            psplash.Height = height;
            psplash.Width = roundToTwo(psplash.Width + width);
            psplash.Sqft = roundToTwo(psplash.Sqft + sqft);
            if (issplashlf == 1) { psplash.LF = roundToTwo(psplash.LF + lnft); }
            psplash.SplashID = itemid;
            psplash.Isactive = 1;
        }
    }
    psplash.SplashID = itemid;
    psplash.Shape = JSON.stringify(sidesplash);
}
function setshapesidesplashold(sidesplash, part, splashlist) {
    let width = sidesplash.width, height = sidesplash.height, type = sidesplash.spltype, typeid = sidesplash.typeid;
    let desc = height + '"splash';
    let metric = getcompanyunittype();
    let sqft = roundToTwo(calcsqft1(width, height, metric));
    let lnft = calclinerfeet1(width, metric);
    if (type == undefined) { type = 0; }
    let psplash = getpartsplashbytype(height, splashlist, type);
    //console.log(JSON.stringify(sidesplash));
    //console.log(JSON.stringify(splashlist));
    let issplashlf = getpricebooksplashlf();
    if (psplash == undefined) {
        psplash = setpartsplash31(part, type, width, height, sqft, desc, typeid);
        splashlist.push(psplash);
    } else {
        psplash.Width = roundToTwo(psplash.Width + width);
        psplash.Sqft = roundToTwo(psplash.Sqft + sqft);
        if (issplashlf == 1) { psplash.LF = roundToTwo(psplash.LF + lnft); }
        psplash.Isactive = 1;
    }
}
function getpartcutoutbyshapeindex(cutout, cutoutlist) {
    for (let i = 0; i < cutoutlist.length; i++) {
        //console.log("shapeid:" + cutoutlist[i].ShapeID, "shapeindex:" + cutout.shapeindex, "srno:" + cutoutlist[i].SrNo, "cindex:" + cutout.index, "SIndex:" + cutoutlist[i].SIndex, "sideindex:" + cutout.sideindex);
        if (cutoutlist[i].ShapeID == cutout.shapeindex && cutoutlist[i].SrNo == cutout.index && cutoutlist[i].SIndex == cutout.sideindex) {
            return cutoutlist[i];
        }
    }
}
function setpartcutout(cutout, part, cutoutlist) {
    //console.log(JSON.stringify(cutout));
    let drawflag = getversiondrawingflag(); 
    //let type = cutout.type, width = roundToTwo(cutout.w / 4), height = roundToTwo(cutout.h / 4);
    let type = cutout.type, width = applymminchfact(cutout.w, 2, 2), height = applymminchfact(cutout.h, 2, 2), holes = cutout.holes;
    let typeid = getcutouttypeid(type);
    let desc = getcutouttypedesc(type, width);
    let pcutout, pbcutout;
    //console.log(type, typeid, desc);
    //1. cutout exist or not in part cutoutlist - By typeid, by type, by desc   
    if (cutout.itemid != undefined) {
        pcutout = getpartcutoutbyitemid(cutout.itemid, cutoutlist);
        if (pcutout == undefined) { pcutout = getpartcutoutbytype(desc, height, cutoutlist); }
    } //itemid== typeid;
    else {
        pcutout = getpartcutoutbyshapeindex(cutout, cutoutlist);
        if (pcutout != undefined) { cutout.itemid = pcutout.TypeID;}
    }  
    //console.log(JSON.stringify(pcutout));
    if (pcutout == undefined) {
        pcutout = setpartcutout31(part, typeid, desc, width, height, cutout.shapeindex, cutout.index, cutout.sideindex);
        pcutout.TypeID = cutout.itemid;
        cutoutlist.push(pcutout);
    } else {
        pcutout.LF += 1; pcutout.Width = width; pcutout.Height = height; pcutout.Isactive = 1;
    }
    pcutout.NoOfHoles = holes;
    //2.set cutout product profile and price only when new cutout. pcutoutid==0 and/or unitprice=0;
    if (pcutout.ID == 0 && pcutout.Unitprice == 0) {
        if (cutout.itemid != undefined) { pbcutout = getpricebookcutouttypebyid(cutout.itemid); } //default 
        if (pbcutout != undefined) {
            let matid = getpartmaterialid(part.PartMaterialList); //material and pricing options
            if (matid > 0 && cutout.itemid > 0 && pbcutout != undefined) {
                desc = pbcutout.Description; pcutout.Type = desc; pcutout.TypeID = pbcutout.ID; pcutout.ProductItemID = pbcutout.ProductItemID;
                let pbcutout1 = getricebookpricerangeoptions(pbcutout.JsonOptions, matid, width, height); // priceing options
                if (pbcutout1 != undefined) { pbcutout = pbcutout1; }
                pbcutout.Description = desc;
            }
            //console.log(JSON.stringify(pcutout));
            if (pbcutout != undefined && pcutout.Unitprice == 0) {
                pcutout.Type = pbcutout.Description;
                pcutout.UnitCost = pbcutout.Cost;
                pcutout.Margin = pbcutout.Margin;
                pcutout.Unitprice = pbcutout.Price;
            }
        }
    }
}
function setpartcutoutholes(cutout, part, cutoutlist) {
    if (cutout.holes > 0) {
        let type = cutout.type;
        let typeid = getcutouttypeid(type);
        let metric = getcmpnymetricmode();
        let desc = metric == 1 ? 'Tap Holes' : 'Faucet Holes';
        let pcutout = getpartcutoutholebytype(desc, cutoutlist);
        //console.log(type, typeid, JSON.stringify(pcutout));

        if (pcutout == undefined) {
            pcutout = setpartcutout31(part, typeid, desc, 0, 0, -1, -1, -1);
            pcutout.LF = cutout.holes;
            cutoutlist.push(pcutout);
        } else {
            pcutout.LF += cutout.holes; pcutout.Isactive = 1;
        }
        let pbcutout = getpricebookcutoutholesbyid(0);
        if (pbcutout != undefined && cutout.itemid != undefined) {
            pcutout.UnitCost = pbcutout.Cost;
            pcutout.Margin = pbcutout.Margin;
            pcutout.Unitprice = pbcutout.Price;
        }
    }
}
function setshapesidesplashlist(side, part, splashlist) {
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].isactive == 1) { setshapesidesplash(side.splashs[i], part, splashlist); }
    }
}
function setpartshapesplashlist(part) {
    setsplashlistinactive(part.SplashList);
    let splashlist = part.SplashList;
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidesplashlist(shape.sides[i], part, splashlist); // side
    }
    return splashlist;
}
function setpartsideedge(edge, part, edgelist, source) {
    let etypes = [], type = edge.type;
    if (edge.type != '' && edge.type != null) { etypes = edge.type.split(':'); type = etypes[0]; }
    let width = convertToFloat(edge.width), height = convertToFloat(edge.height), typeid = edge.typeid, desc = 'Finished Edge';
    if (type == 'U' || type == 'S' || type == 'W' || width == 0) { return; }
    if (type == 0 || edge.type == undefined) { type = 'F'; }
    if (type == 'F') { desc = 'Finished Edge'; } else if (type == 'A') { desc = 'Appliance Edge'; } else if (type == 'E') { desc = 'Eased Edge'; } else if (type == 'M') { desc = 'Mitered Edge'; } else if (type == 'L') { desc = 'Laminate Edge'; } else { desc = type;}
    let pedge;
    let metric = getcompanyunittype();
    if (typeid != 0) { pedge = getpartedgebytypeid(typeid, edgelist); }
    else { pedge = getpartedgebydesc(desc, edgelist); }
    //console.log(type, typeid, desc, JSON.stringify(pedge));
    if (pedge == undefined) {
        pedge = setpartedge31(part, typeid, type, desc, width, height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = calcedgeqtybasedonunittype(pedge.Width, pedge.UnitTypeID);
        pedge.CopyQty = pedge.LF;
        edgelist.push(pedge);
    } else {
        if (typeid != 0) { pedge.Height = getedgeheightbyid(typeid); }//height
        pedge.Width = roundToTwo(pedge.Width + width);
        pedge.Height = roundToTwo(pedge.Height + height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = roundToTwo(pedge.LF + calcedgeqtybasedonunittype(width, pedge.UnitTypeID));
        pedge.CopyQty = pedge.LF;
        pedge.Inches = roundToTwo(pedge.Inches + width);
        pedge.Isactive = 1;
        //pedge.type = type;       
    }
}
function setpartsideshape(sideshape, part, edgelist) {
    let width = applymminchfact(sideshape.w, 2, 2), height = applymminchfact(sideshape.h, 2, 2);
    let edgewidth = width + (2 * height);
    let metric = getcompanyunittype();
    let pedge;
    //if (type == 'U' || type == 'S' || type == 'W' || width == 0) { return; }
    //if (type == 0) { type = 'F'; }
    //if (type == 'F') { desc = 'Finished Edge'; } else if (type == 'A') { desc = 'Appliance Edge'; } else if (type == 'E') { desc = 'Eased Edge'; } else if (type == 'M') { desc = 'Mitered Edge'; } else if (type == 'L') { desc = 'Laminate Edge'; }
    if (sideshape.type != 0) { pedge = getpartedgebytypeid(sideshape.type, edgelist); }

    if (pedge == undefined) {
        pedge = setpartedge31(part, 0, '', '', width, height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = calcedgeqtybasedonunittype(width, pedge.UnitTypeID);
        pedge.CopyQty = pedge.LF;
        edgelist.push(pedge);
    } else {
        if (sideshape.type != 0) { pedge.Height = getedgeheightbyid(sideshape.type); }//height
        pedge.Width = roundToTwo(pedge.Width + width);
        pedge.Height = roundToTwo(pedge.Height + height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = roundToTwo(pedge.LF + calcedgeqtybasedonunittype(width, pedge.UnitTypeID));
        pedge.Inches = roundToTwo(pedge.Inches + edgewidth);
        pedge.CopyQty = pedge.LF;
        pedge.Isactive = 1;
    }
    //pbook price
    let pbbump = getpricebookbumplistbyid(sideshape.type);
    if (pbbump != undefined) {
        pedge.Inches = roundToTwo(edgewidth);
        pedge.EdgeProfile = pbbump.Description;
        pedge.EdgeProfileID = pbbump.ID;
        pedge.ProductItemID = pbbump.ProductItemID;
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0) {
            let pricerange = getricebookpricerangeoptions(pbbump.JsonOptions, matid, width, height);
            if (pricerange != undefined) { pbbump = pricerange; }
        }
        pedge.UnitCost = pbbump.Cost;
        pedge.Margin = pbbump.Margin;
        pedge.UnitPrice = pbbump.Price;
    }
}
function setpartsidecorner1(sidecorner, part, edgelist) {
    let source = 'setpartsidecorner';
    let metric = getcompanyunittype();
    let width = applymminchfact(sidecorner.r, 2, 2, source), height = applymminchfact(sidecorner.h, 2, 2, source), rad = applymminchfact(sidecorner.r, 2, 2, source);
    let pedge, typeid = 0; type = 'F', desc = 'Finished Edge';
    //console.log(JSON.stringify(sidecorner));
    if (sidecorner.edges != undefined && sidecorner.edges.length > 2) {
        let scorneredge = sidecorner.edges[2];
        if (scorneredge.type != undefined) { type = scorneredge.type; }
        if (scorneredge.typeid != undefined) { typeid = scorneredge.typeid; }
    }
    if (type == 0) { type = 'F'; }
    if (type == 'F') { desc = 'Finished Edge'; } else if (type == 'A') { desc = 'Appliance Edge'; } else if (type == 'E') { desc = 'Eased Edge'; }
    else if (type == 'M') { desc = 'Mitered Edge'; } else if (type == 'L') { desc = 'Laminate Edge'; } else { desc = type;}
    if (sidecorner.type == 4) { height = rad; }
    //if (sidecorner.type != 0) { pedge = getpartedgebytypeid1(sidecorner.typeid, edgelist, height); }
    if (typeid != 0) { pedge = getpartedgebytypeid1(typeid, edgelist, height); }
    else { pedge = getpartedgebydesc(desc, edgelist); }
    //console.log(typeid, type, desc, JSON.stringify(pedge));
    if (pedge == undefined) {
        pedge = setpartedge31(part, sidecorner.typeid, '', '', width, height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = calcedgeqtybasedonunittype(width, pedge.UnitTypeID);
        pedge.CopyQty = pedge.LF;
        edgelist.push(pedge);
    } else {
        if (sidecorner.typeid != 0) { pedge.Height = getedgeheightbyid(sidecorner.typeid); }//height
        pedge.Width = roundToTwo(pedge.Width + width);
        pedge.Height = roundToTwo(pedge.Height + height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = roundToTwo(pedge.LF + calcedgeqtybasedonunittype(width, pedge.UnitTypeID));
        pedge.CopyQty = pedge.LF;
        pedge.Inches = roundToTwo(pedge.Inches + width);
        pedge.Isactive = 1;
    }
    //pbook price
    let pbcorner = getpricebookcornerlistbyid(sidecorner.typeid);
    if (pbcorner != undefined) {
        //pedge.Inches = roundToTwo(width);
        pedge.EdgeProfile = pbcorner.Description;
        pedge.EdgeProfileID = pbcorner.ID;
        pedge.ProductItemID = pbcorner.ProductItemID;
        let matid = getpartmaterialid(part.PartMaterialList);
        if (matid > 0) {
            let pricerange = getricebookpricerangeoptions(pbcorner.JsonOptions, matid, width, height);
            if (pricerange != undefined) { pbcorner = pricerange; }
        }
        pedge.UnitCost = pbcorner.Cost;
        pedge.Margin = pbcorner.Margin;
        pedge.UnitPrice = pbcorner.Price;
    }
}
function setpartsidecorner(sidecorner, part, edgelist) {
    let source = 'setpartsidecorner';
    let metric = getcompanyunittype();
    let width = applymminchfact(sidecorner.r, 2, 2, source), height = applymminchfact(sidecorner.h, 2, 2, source), rad = applymminchfact(sidecorner.r, 2, 2, source);
    let pedge;
    if (sidecorner.type == 4) { height = rad; }
    if (sidecorner.type != 0) { pedge = getpartedgebytypeid1(sidecorner.typeid, edgelist, height); }
    if (pedge == undefined) {
        pedge = setpartedge31(part, sidecorner.typeid, '', '', width, height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = calcedgeqtybasedonunittype(width, pedge.UnitTypeID);
        pedge.CopyQty = pedge.LF;
        edgelist.push(pedge);
    } else {
        if (sidecorner.typeid != 0) { pedge.Height = getedgeheightbyid(sidecorner.typeid); }//height
        pedge.Width = roundToTwo(pedge.Width + width);
        pedge.Height = roundToTwo(pedge.Height + height);
        pedge.Sqft = roundToTwo(calcsqft1(pedge.Width, pedge.Height, metric));
        pedge.LF = roundToTwo(pedge.LF + calcedgeqtybasedonunittype(width, pedge.UnitTypeID));
        pedge.CopyQty = pedge.LF;
        pedge.Inches = roundToTwo(pedge.Inches + width);
        pedge.Isactive = 1;
    }
    //pbook price
    let pbcorner = getpricebookcornerlistbyid(sidecorner.typeid);
    if (pbcorner != undefined) {
        //pedge.Inches = roundToTwo(width);
        pedge.EdgeProfile = pbcorner.Description;
        pedge.EdgeProfileID = pbcorner.ID;
        pedge.ProductItemID = pbcorner.ProductItemID;
        let matid = getpartmaterialid(part.PartMaterialList);
        //if (matid > 0) {
            let pricerange = getricebookpricerangeoptions(pbcorner.JsonOptions, matid, width, height);
            if (pricerange != undefined) { pbcorner = pricerange; }
        //}
        pedge.UnitCost = pbcorner.Cost;
        pedge.Margin = pbcorner.Margin;
        pedge.UnitPrice = pbcorner.Price;
    }
}
function setsidesideshapelist(side, part, edgelist) {
    for (let i = 0; i < side.sideshapes.length; i++) { if (side.sideshapes[i].isactive == 1) { setpartsideshape(side.sideshapes[i], part, edgelist); } }
}
function setsidesidecornerlist(side, part, edgelist) {
    if (side.corners != undefined) {
        for (let i = 0; i < side.corners.length; i++) {
            if (side.corners[i].type != 0) {
                setpartsidecorner(side.corners[i], part, edgelist);
            }
        }
    }
}
function setsidesplashedgelist(splash, part, edgelist) {
    if (splash.isactive == 1) {
        let dflag = getversiondrawingflag();
        for (let i = 0; i < splash.edges.length; i++) {
            if (dflag == 1) { let w1 = splash.width, w2 = splash.width, h = splash.height; splash.edges[i].width = getwidthbycode(splash.edges[i].index, w1, w2, h); }//old drawing
            setpartsideedge(splash.edges[i], part, edgelist, 'setsidesplashedgelist');
        }
    }
}
function setsidesplashsedgelist(side, part, edgelist) {
    if (side.splashs != undefined) { for (let i = 0; i < side.splashs.length; i++) { setsidesplashedgelist(side.splashs[i], part, edgelist); } }
}
function setsidecorneredgelist(corner, part, edgelist) {
    if (corner.edges != undefined) {
        for (let i = 0; i < corner.edges.length; i++) {
            setpartsideedge(corner.edges[i], part, edgelist, 'setsidecorneredgelist');
        }
    }
}

function setsideshapeedgelist(sideshape, part, edgelist, side) {
    if (sideshape.edges != undefined) {
        let dflag = getversiondrawingflag();
        for (let i = 0; i < sideshape.edges.length; i++) {
            if (dflag == 1) { let w1 = side.w1, w2 = side.w2, h = side.h / 4; sideshape.edges[i].width = getwidthbycode(sideshape.edges[i].code, w1, w2, h); }//old drawing
            setpartsideedge(sideshape.edges[i], part, edgelist, 'setsideshapeedgelist');
        }
    }
}
function getwidthbycode(code, w1, w2, h) {
    let w = 0;
    if (code == 0 || code == 3) {
        w = h;
    } else if (code == 1) {
        w = w1;
    }
    else if (code == 2) {
        w = w2;
    }
    return w;
}
function setshapesidecorneredgelist(side, part, edgelist) {
    for (let i = 0; i < side.corners.length; i++) {
        if (side.corners[i].type != 0) {
            setsidecorneredgelist(side.corners[i], part, edgelist);
        }
    }
}
function setsidesideshapeedgelist(side, part, edgelist) {
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].isactive == 1) { setsideshapeedgelist(side.sideshapes[i], part, edgelist, side); }
    }
}
function setshapesideedgelist(side, part, edgelist) {
    if (side.edges != undefined) {
        let dflag = getversiondrawingflag();
        for (let i = 0; i < side.edges.length; i++) {
            if (dflag == 1) { let w1 = side.w1, w2 = side.w2, h = side.h / 4; side.edges[i].width = getwidthbycode(side.edges[i].code, w1, w2, h); }//old drawing
            setpartsideedge(side.edges[i], part, edgelist, 'setshapesideedgelist');
        }
    }
}
function setpartshapeedgelist(part) {
    setedgelistinactive(part.EdgeList);
    let edgelist = part.EdgeList;
    //console.log(JSON.stringify(edgelist));
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesideedgelist(shape.sides[i], part, edgelist);
        setsidesideshapeedgelist(shape.sides[i], part, edgelist);
        setshapesidecorneredgelist(shape.sides[i], part, edgelist);
        setsidesplashsedgelist(shape.sides[i], part, edgelist);
        setsidesideshapelist(shape.sides[i], part, edgelist);//bumps
        setsidesidecornerlist(shape.sides[i], part, edgelist);//corners
    }
   // console.log(JSON.stringify(edgelist));
    return edgelist;
}
function setshapesidescutoutlist(side, part, cutoutlist) {
    let dflag = getversiondrawingflag(); 
    for (let i = 0; i < side.cutouts.length; i++) {
        if (side.cutouts[i].Isactive == 1) {
            setpartcutout(side.cutouts[i], part, cutoutlist, 'setshapesidescutoutlist');
            //cutout holes
            setpartcutoutholes(side.cutouts[i], part, cutoutlist, 'setshapesidescutoutlist');
        }
    }
}
function setpartshapecutoutlist(part) {
    setcutoutlistinactive(part.CutoutList);
    let cutoutlist = part.CutoutList;   
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidescutoutlist(shape.sides[i], part, cutoutlist);
    }
    return cutoutlist;
}
function setareasummary31() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);   
    //area summary
    calcareasummary31(area);
}
function setchangeorderitems(part) {
    //step1:set part material
    validatesetcopartmaterial(part);
    //step2:set part measurement item
    validatesetcopartmeasurement(part);
    //step3:set part splash
    validatesetcopartsplashs(part);
    //step4:set part edge
    validatesetcopartedges(part);
    //step5:set part template
    valiadtesetcoparttemplateinstall(part, 1);
    //step6:set part install
    valiadtesetcoparttemplateinstall(part, 2);
}

function onaddpartshape31(source) {
    let dflag = getversiondrawingflag1();
    //1:set Part   
    let index = shape.index, areaid = shape.areaid, partsrno = shape.partsrno, isnewpart = 0;
    let coid = getcoid();
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part == undefined) { isnewpart = 1; part = setpart31(shape.index, shape.partsrno); part.show = true; part.PartCheck = 1; }
    else if (coid > 0) { setchangeorderitems(part); }
    //2: Assign shape to part
    //console.log(shape.index, shape.tx, shape.ty, shape.x, shape.y, source);
    part.Shape = shape;
    //3.set part material
    let partmat = setpartmaterial31(part);
    //3.1 duplicate shape
    if (source == "setduplicateshape31") { partmat.MaterialID = shape.materialid; let material = getmaterialbyid(partmat.MaterialID); resetpartmaterial32(partmat, material); }
    //3.2:set fab   
    let fab = setpartfab31(part, 'shape');
    //4: set shape measurements to part 
    //part.MeasureList = setfabshapemeasurelist();  //should be part.Measurelist. check with Raghu
    fab.MeasureList = setfabshapemeasurelist();
    //5: set shape splahses to part
    part.SplashList = setpartshapesplashlist(part);
    //6: set shape edges to part
    part.EdgeList = setpartshapeedgelist(part);
    //7: set shape cutouts to part   
    part.CutoutList = setpartshapecutoutlist(part);
    //8: set shape fabrication to part     
    fab.PartSqft = calcpartfabsqft31(fab);
    fab.SplashSqft = calcpartsplashstotalsqft31(part.SplashList);
    fab.EdgeSqft = calcpartedgetotalsqft31(part.EdgeList);
    partmat.Sqft = fab.PartSqft + fab.SplashSqft + fab.EdgeSqft; partmat.Qty = partmat.Sqft; fab.JobSplashSf = fab.SplashSqft; fab.JobEdgeSF = fab.EdgeSqft;
    let fsplashsqft = fab.SplashSqft;
    if (dflag == 1) { // isflag 1 for old quotes
        fab.SplashSqft = 0; fab.JobSplashSf = 0;
    }    
    //8.default labor
    setpricebookdefaultlaborlist33(part.AreaID);
    //9: set shape template to part
    let ptemp = checkandsetparttempinstall31(part.LaborList, 1);//template
    if (ptemp == true) { setparttemplateinstall31(part, 1, fab.PartSqft + fsplashsqft + fab.EdgeSqft); }
    //10:set shape install to part.    
    let pinstall = checkandsetparttempinstall31(part.LaborList, 2);//install
    if (pinstall == true) { setparttemplateinstall31(part, 2, fab.PartSqft + fsplashsqft + fab.EdgeSqft); }
    //11.labor unitytpe sqft
    restsetpartlaborqty31(part.LaborList, part.AreaID, fab.PartSqft + fsplashsqft + fab.EdgeSqft);
    //12.set unused materials
    //setunusedmaterial32();
    //13.set part area summary
    if (_quotelayout == 0) { calcpartversionsummary(part); }
    //14:flag
    setchangeflag();
    selectpartbysrno(shape.partsrno);
    //15:jason string
    part.Shape = jasonpartshape(shape);
    //check and add area material
    let area = getareabyid(partmat.AreaID);
    if (coid > 0 && partmat != undefined) {
        let areamat = getareamaterialbymateriald34(area.AreaMaterialList, partmat.MaterialID, coid);
        if (areamat == undefined) { addcomaterialtoarea34(area, partmat.MaterialID, partmat.MaterialID, partmat.CoID); }
    }
    if (partmat.PriceByID == 1) { resetpartmatslabsqft34(partmat.MaterialID, area); }
    //16:set area summary
    if (_quotelayout == 1) { setshapeareaitems34(part, isnewpart); }
}
function setpricebookdefaultlaborlist33(areaid) {    
    let area = getareabyid(areaid);
    if (area.laborList != null && area.laborList.length == 0) {
        let parts = getactiveparts(area.PartList);
        if (parts.length == 1) {
            let pricebook = getpricebook();
            if (pricebook.laborlist != null) {
                for (let i = 0; i < pricebook.laborlist.length; i++) {
                    if (pricebook.laborlist[i].IsDefault == 1) {
                        setdefaultlabor33(pricebook.laborlist[i], area);
                    }
                }
            }
        }
    }
}
function getactiveparts(partlist) {
    let parts = [];
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            parts.push(partlist[i]);
            if (parts.length > 1) { return parts; }
        }
    }
    return parts;
}
function setdefaultlabor33(labor, area) {
    let plabor = initlabor();
    let coid = getcoid();
    let cosrno = getcosrno();
    let taxperc = gettaxpercent();
    let userId = getloginuserId();
    plabor.ViewTypeID = 0;
    plabor.CoID = coid;
    plabor.CoSrNo = cosrno;
    plabor.UserID = userId;
    plabor.Tax = taxperc > 0 ? 1 : 0;
    plabor.AreaID = area.ID;
    plabor.AreaUnits = area.NoOfUnits;
    plabor.RoundUp = area.SqftRoundUp;
    plabor.VersionID = area.VersionID;
    plabor.IsOptional = labor.IsOptional;
    plabor.LaborTypeID = labor.ProTypeID;
    plabor.ProductItemID = labor.ProductItemID;
    plabor.UnitTypeID = labor.UnitTypeID;
    plabor.Description = labor.Description;
    plabor.JobDes = labor.Description;
    plabor.UnitCost = labor.Cost;
    plabor.Margin = labor.Margin;
    plabor.UnitPrice = labor.Price;
    plabor.Amount = calcitemamt(plabor.Qty, plabor.UnitPrice);
    if (area.laborList == null || area.laborList.length == 0) { area.laborList = []; }
    area.laborList.push(plabor);
}


function verifydefaultchecklist(typeid) {
    let pricebook = getpricebook();
    let checkList = getqscopechecklist();
    for (let i = 0; i < checkList.length; i++) {
        let chkitem = checkList[i];  
        //10.set part Template
        if (chkitem.TypeID == 11 && typeid == 1) { return true; }
        //11.set part install
        if (chkitem.TypeID == 12 && typeid == 2) { return true; }      
    }
    return false;
}
function checkandsetparttempinstall31(laborlist, typeid) {
    return verifydefaultchecklist(typeid);
    //let verifycheck = verifydefaultchecklist(typeid);
    //if (verifycheck) {
    //let desc = typeid == 1 ? 'Template' : "Install";
    //for (let i = 0; i < laborlist.length; i++) {
    //    if (laborlist[i].Description == desc && laborlist[i].ViewTypeID == 1 && laborlist[i].Isactive == 1) {
    //        return true;
    //    }
    //}
    //if (laborlist.length == 0) { return true; }
    //return true;
    // }
    // return false;
}
function onupdatepartshape31(source) {    
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let area = getareabyid(areaid);  
    if (part != undefined) {
        part.Shape = jasonpartshape(shape); part.SaveFlag = 1; area.SaveFlag = 1;     
        setchangeflag();
    }  
}
function onpartshapeactive31(source) {
    setpartactive(shape.index);
    resetareapartssrno();
    setchangeflag();
    selectpartbysrno(shape.partsrno);
}
function onpartshaperemove31(index, source) {
    setpartinactive(index);
    resetareapartssrno();
    setchangeflag();
    selectpartbysrno(-1);
    if (_quotelayout == 1) { resetpartsrnoinareaitems34(index); }
    else { setareasummary31();}
}
function onaddpartsinkcutout31(sinkId, source) {
    let sinkinfo = getpricebooksinkcutoutbyid(sinkId);
    let part = getpartbyareapartsrno(shape.partsrno, shape.areaid);
    if (part != undefined) {
        let coid = getcoid();
        let cosrno = getcosrno();
        let sinkpercent = getsinktaxpercent();
        let cutoutsrno = 0;
        for (let i = 0; i < shape.sides.length; i++) {
            let cutouts = shape.sides[i].cutouts;
            for (let j = 0; j < cutouts.length; j++) { if (sinkinfo.CutoutInfo.ID == cutouts[j].itemid) { sinkinfo.cutoutsrno = cutouts[j].index; } }
        }
        setpartsink2(part, sinkinfo, coid, cosrno, sinkpercent);
    }
}
function reorderpartshapesideseams32(partshape, source) {
    for (let i = 0; i < partshape.sides.length; i++) {        
        let psideseams = JSON.parse(JSON.stringify(partshape.sides[i].seams));
        psideseams = psideseams.sort((a, b) => (a.sw > b.sw) ? 1 : -1);
        let index1 = 0, tmpsideseams = [];
        for (let i = 0; i < psideseams.length; i++) {
            if (psideseams[i].isactive == 1) {
                psideseams[i].index = index1;
                psideseams[i].spseamindex = index1;
                tmpsideseams.push(psideseams[i]);
                index1++;
            }
        }
        //console.log("sideindex:" + i, "source:" + source, JSON.stringify(partshape.sides[i].seams), JSON.stringify(tmpsideseams));
        partshape.sides[i].seams = tmpsideseams;
        
    }
}
function onaddpartshapeseam32(index, sideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno, startseamindex = shape.startseamindex, startsideindex = shape.startsideindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape;    
    let slabpartseam = JSON.parse(JSON.stringify(shape.sides[sideindex].seams[index]));
    let spsideindex = slabpartseam.spsideindex, spseamindex = slabpartseam.spseamindex;
    if (partshape != null) {
        let pshapeside = partshape.sides[spsideindex];
        //console.log("index:" + index, "sideindex:" + sideindex, "spsideindex:" + spsideindex, "startseamindex:" + startseamindex, "startsideindex:" + startsideindex, "partsrno:" + partsrno, "areaid:" + areaid, "source:" + source);
        if (startsideindex == spsideindex && startseamindex != -1) { slabpartseam.sw += pshapeside.seams[startseamindex].sw; }
        pshapeside.seams.push(slabpartseam);
        reorderpartshapesideseams32(partshape, source);
        setchangeflag();
        let area = getareabyid(areaid);
        setareasaveflag(area);
    }
 //   console.log(JSON.stringify(partshape.slabparts));
}
function onupdatepartshapeseam32(index, sideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno, startseamindex = shape.startseamindex, startsideindex = shape.startsideindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape;
    let slabpartseam = JSON.parse(JSON.stringify(shape.sides[sideindex].seams[index]));
    let spsideindex = slabpartseam.spsideindex, spseamindex = slabpartseam.spseamindex;   
    let pshapeside = partshape.sides[spsideindex];
    if (startsideindex == spsideindex && startseamindex != -1) { slabpartseam.sw += pshapeside.seams[startseamindex].sw; }
    //console.log("index:" + index, "sideindex:" + sideindex, "spsideindex:" + spsideindex, "spseamindex:" + spseamindex, "startseamindex:" + startseamindex, "startsideindex:" + startsideindex,
    //    "partsrno:" + partsrno, "areaid:" + areaid, "source:" + source, JSON.stringify(slabpartseam));
    pshapeside.seams[spseamindex] = slabpartseam;
    reorderpartshapesideseams32(partshape, source);
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
}
function ondeletepartshapeseam32(index, sideindex, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape;
    let slabpartseam = JSON.parse(JSON.stringify(shape.sides[sideindex].seams[index]));
    let spsideindex = slabpartseam.spsideindex, spseamindex = slabpartseam.spseamindex;
   // console.log("index:" + index, "sideindex:" + sideindex, "spsideindex:" + spsideindex, "partsrno:" + partsrno, "areaid:" + areaid, "source:" + source);
    let pshapeside = partshape.sides[spsideindex];
    pshapeside.seams[spseamindex].isactive = 0;
    reorderpartshapesideseams32(partshape, source);
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
}

function onseampartshape32(seamindex, sideindex, spseamindex, spsideindex, seamtype, source) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape; 
    if (partshape != null) {
        partshape.sides[spsideindex].seams[spseamindex].split = 1;
        partshape.slabparts = JSON.parse(JSON.stringify(pshapeslabparts));
        setchangeflag();
        let area = getareabyid(areaid);
        setareasaveflag(area);
    } else {
        //console.log(JSON.stringify(part));
    }
    //console.log(JSON.stringify(partshape.slabparts));   
}
function onunseampartshape32(index, sideindex, spindex, startseamindex, startsideindex, source) {    
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape;
    //console.log(index, spindex, startseamindex, startsideindex, partshape.sides.length);
    partshape.sides[startsideindex].seams[startseamindex].split = 0;   
    let tmpslabparts = [], tmpslabparts1 = JSON.parse(JSON.stringify(partshape.slabparts));
    for (let i = 0; i < tmpslabparts1.length; i++) {        
        if (!(tmpslabparts1[i].startseamindex == startseamindex && tmpslabparts1[i].startsideindex == startsideindex)) {
            tmpslabparts.push(tmpslabparts1[i]);
            tmpslabparts[tmpslabparts.length - 1].index = tmpslabparts.length - 1;
        }
    }
    partshape.slabparts = tmpslabparts;
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);    
}
function updatepartshapeslabparts32(partsrno, areaid, npshapeslabparts, source) {
    let part = getpartbyareapartsrno(partsrno, areaid);
    let partshape = part.Shape;
    if (partshape.slabparts == undefined) { partshape.slabparts = []; }   
    partshape.slabparts = JSON.parse(JSON.stringify(npshapeslabparts));
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
    //console.log(partsrno, areaid, partshape.partsrno, partshape.areaid, JSON.stringify(npshapeslabparts));
}
function reordershapesplashseams32(pshapesplash, source) {
    let pslabsplashseams = JSON.parse(JSON.stringify(pshapesplash.seams));
    pslabsplashseams = pslabsplashseams.sort((a, b) => (a.sw > b.sw) ? 1 : -1);
    let index1 = 0, tmpslabsplashseams = [];
    for (let i = 0; i < pslabsplashseams.length; i++) {
        if (pslabsplashseams[i].isactive == 1) {
            pslabsplashseams[i].index = index1;
            pslabsplashseams[i].spseamindex = index1;
            tmpslabsplashseams.push(pslabsplashseams[i]);
            index1++;
        }
    }
    pshapesplash.seams = tmpslabsplashseams;
}
function onaddpartshapesplashseam32(index, spseamindex, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, startseamindex = shapeslabsplash.startseamindex, spsideindex = shapeslabsplash.spsideindex,
        splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    if (isNaN(startseamindex)) { startseamindex = -1; }
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index]));    
    if (isNaN(startseamindex)) { startseamindex = -1; }
    //console.log(index, splashindex, startseamindex, spsplashindex, source);    
    if (startseamindex != -1) { slabsplashseam.sw += pshapesplash.seams[startseamindex].sw; }
    pshapesplash.seams.push(slabsplashseam);
    if (pshapesplash.seams.length > 1) { reordershapesplashseams32(pshapesplash, source); }
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
   // console.log(JSON.stringify(pshapesplash.seams));
}
function onupdatepartshapesplashseam32(index, spseamindex, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, startseamindex = shapeslabsplash.startseamindex, spsideindex = shapeslabsplash.spsideindex,
       splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;    
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index]));   
    if (isNaN(startseamindex)) { startseamindex = -1; }
   // console.log(index, splashindex, startseamindex, slabsplashseam.sw, pshapesplash.seams[spseamindex].sw);
    if (startseamindex != -1) { slabsplashseam.sw += pshapesplash.seams[startseamindex].sw; }
    pshapesplash.seams[spseamindex] = slabsplashseam;
    if (pshapesplash.seams.length > 1) { reordershapesplashseams32(pshapesplash, source); }
   
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
  //  console.log(JSON.stringify(pshapesplash.seams));
}
function ondeletepartshapesplashseam32(index, spseamindex, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, startseamindex = shapeslabsplash.startseamindex, spsideindex = shapeslabsplash.spsideindex,
        splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index]));    
    if (isNaN(startseamindex)) { startseamindex = -1; }
    if (startseamindex != -1) { slabsplashseam.sw += pshapesplash.seams[startseamindex].sw; }
    pshapesplash.seams[spseamindex].isactive = 0;
    reordershapesplashseams32(pshapesplash, source);
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
   // console.log(JSON.stringify(pshapesplash.seams));
}
function updatepartshapeslabsplashs32(partsrno, areaid, npshapeslabsplashs, source) {    
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    //console.log(partsrno, areaid, spsideindex,  JSON.stringify(part.Shape.sides[spsideindex]))
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    pshapesplash.slabsplashs = JSON.parse(JSON.stringify(npshapeslabsplashs));
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
   // console.log(JSON.stringify(pshapesplash));
}
function onseampartshapesplash32(index, spseamindex, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex,
       splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    pshapesplash.seams[spseamindex].split = 1;
    pshapesplash.slabsplashs = pshapeslabsplashs;
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
   // console.log(JSON.stringify(pshapesplash.slabsplashs));
}
function onunseampartshapesplash32(index, splashindex, source) {
    let  startseamindex = shapeslabsplash.startseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    pshapesplash.seams[startseamindex].split = 0;
    let tmpslabsplashs = [], tmpslabsplashs1 = JSON.parse(JSON.stringify(pshapesplash.slabsplashs));
    for (let i = 0; i < tmpslabsplashs1.length; i++) {
        if (!(tmpslabsplashs1[i].startseamindex == startseamindex)) {
            tmpslabsplashs.push(tmpslabsplashs1[i]);
            tmpslabsplashs[tmpslabsplashs.length - 1].index = tmpslabsplashs.length - 1;
        }
    }
    pshapesplash.slabsplashs = tmpslabsplashs;
    setchangeflag();
    let area = getareabyid(areaid);
    setareasaveflag(area);
}
function setpartshapeslabpart31(source) {
    //1. getpartby part id and area id
    //2. update slabaprt from shape 
    let areaid = shape.areaid, partsrno = shape.partsrno, spindex = shape.spindex, spseamindex = shape.spseamindex, spsideindex = shape.spsideindex;
    //console.log(spindex, spseamindex, spsideindex, areaid, partsrno, source);
    let part = getpartbyareapartsrno(partsrno, areaid);
    let slabpart = part.Shape.slabparts[spindex];
    if (slabpart != undefined) {        
        slabpart.tx = shape.tx;
        slabpart.ty = shape.ty;
        slabpart.angle = shape.angle;
        slabpart.color = shape.color;
        slabpart.slabindex = shape.slabindex;
        slabpart.slabsrno = shape.slabsrno;
        slabpart.slabid = shape.slabid;
        slabpart.slabx = shape.slabx;
        slabpart.slaby = shape.slaby;
        slabpart.clipx = shape.clipx;
        slabpart.clipy = shape.clipy;
        setchangeflag();
        let area = getareabyid(areaid);
        setareasaveflag(area);
    }
}
function ispartsideseamsplit(spsideindex) {
    let areaid = shape.areaid, partsrno = shape.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);
    if (part != undefined) {
        let pshapeside = part.Shape.sides[spsideindex];
        for (let j = 0; j < pshapeside.seams.length; j++) {
            if (pshapeside.seams[j].isactive == 1 && pshapeside.seams[j].split == 1) {
                return true;
            }
        }
    }
    return false;
}
function setpartshapeslabsplash31(source) {
    //1. getpartby part id and area id
    //2. update slabaprt from shape 
    let  startseamindex = shapeslabsplash.startseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);    
    if (part != undefined) {
        //console.log(JSON.stringify(part.Shape.sides[spsideindex].splashs[spsplashindex].slabsplashs));
        let pshapeslabsplash = part.Shape.sides[spsideindex].splashs[spsplashindex].slabsplashs[splindex];
        pshapeslabsplash.tx = shapeslabsplash.tx;
        pshapeslabsplash.ty = shapeslabsplash.ty;
        pshapeslabsplash.angle = shapeslabsplash.angle;
        pshapeslabsplash.spseamindex = startseamindex;
        pshapeslabsplash.startseamindex = startseamindex;
        pshapeslabsplash.spsplashindex = spsplashindex;
        pshapeslabsplash.spsideindex = spsideindex;
        pshapeslabsplash.splindex = splindex;
        pshapeslabsplash.partsrno = partsrno;
        pshapeslabsplash.areaid = areaid;
        pshapeslabsplash.color = shapeslabsplash.color;
        pshapeslabsplash.slabindex = shapeslabsplash.slabindex;
        pshapeslabsplash.slabsrno = shapeslabsplash.slabsrno;
        pshapeslabsplash.slabid = shapeslabsplash.slabid;
        pshapeslabsplash.slabx = shapeslabsplash.slabx;
        pshapeslabsplash.slaby = shapeslabsplash.slaby;
        pshapeslabsplash.clipx = shapeslabsplash.clipx;
        pshapeslabsplash.clipy = shapeslabsplash.clipy;
        pshapeslabsplash.rtx = shapeslabsplash.rtx;
        pshapeslabsplash.rty = shapeslabsplash.rty;
        setchangeflag();      
    }
    //console.log(shapeslabsplash.tx, shapeslabsplash.ty, pshapeslabsplash.tx, pshapeslabsplash.ty);
}
function onaddpartsplashseam31(index, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index]));
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    let psplashseams = [];
    let sw = 0;
    for (let i = 0; i < pshapesplash.seams.length; i++) {
        if (pshapesplash.seams[i].isactive == 1 && pshapesplash.seams[i].sw < slabsplashseam.sw) {
            pshapesplash.seams[i].index = i;
            pshapesplash.seams[i].spseamindex = i;
            if (pshapesplash.seams[i].split == 1) { sw = pshapesplash.seams[i].sw; }
            psplashseams.push(pshapesplash.seams[i]);
        }
    }
    slabsplashseam.index = psplashseams.length;
    slabsplashseam.spseamindex = psplashseams.length;
    psplashseams.push(slabsplashseam);
    if (sw > 0) { slabsplashseam.sw += sw; }
    for (let i = 0; i < pshapesplash.seams.length; i++) {
        if (pshapesplash.seams[i].isactive == 1 && pshapesplash.seams[i].sw > slabsplashseam.sw) {
            pshapesplash.seams[i].index = i;
            pshapesplash.seams[i].spseamindex = i;
            psplashseams.push(pshapesplash.seams[i]);
        }
    }
  //  console.log(index, splashindex, spsplashindex, spsideindex, splindex, areaid, partsrno, pshapesplash.seams.length);
    pshapesplash.seams = psplashseams;
    //console.log(JSON.stringify(pshapesplash));
    setchangeflag();
}
function onupdatepartsplashseam31(index, sideindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashseam = JSON.parse(JSON.stringify(shapeslabsplash.seams[index])), spseamindex = slabsplashseam.spseamindex;
    let part = getpartbyareapartsrno(partsrno, areaid);
    let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
    pshapesplash.seams[spseamindex] = slabsplashseam;
   // console.log(index, spseamindex,  sideindex, pshapesplash.seams.length, source);
    setchangeflag();
}
function onseampartsplash31(spseamindex, spsideindex, source) {
    //console.log(spseamindex, spsideindex, source);
    let spsplashindex = shapeslabsplash.spsplashindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let slabsplashs = JSON.parse(JSON.stringify(shapeslabsplash.slabsplashs));
    let part = getpartbyareapartsrno(partsrno, areaid);
    //let slabsplash = shapeslabsplash.slabsplashs[index];
    part.Shape.sides[spsideindex].splashs[spsplashindex].seams[spseamindex].split = 1;
    part.Shape.sides[spsideindex].splashs[spsplashindex].slabsplashs = slabsplashs;
    setchangeflag();
}
function onupdatepartshapeszoom32() {
    let areaindex = getareaindex();
    let partlist = getpartlist(areaindex);
    if (partlist != null && partlist.length > 0) {
        for (let i = 0; i < partlist.length; i++) {
            if (partlist[i].IsActive == 1 && partlist[i].Shape != null && partlist[i].Shape != 'null') {
                partlist[i].Shape.tscale = zscale;
            }
        }
    }
    setchangeflag();
}
function ondeletepartslabsplash32(source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spseamindex = shapeslabsplash.spseamindex, splindex = shapeslabsplash.splindex, spsideindex = shapeslabsplash.spsideindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let part = getpartbyareapartsrno(partsrno, areaid);   
    if (part != undefined) {
        let pshapesplash = part.Shape.sides[spsideindex].splashs[spsplashindex];
        pshapesplash.seams[spseamindex].split = 0;
        let pslabsplashs = [];
        //console.log(JSON.stringify(pshapesplash.slabsplashs));
        for (let i = 0; i < pshapesplash.slabsplashs.length; i++) {
            //console.log(partshape.slabparts[i].index, spindex);
            if (pshapesplash.slabsplashs[i].index != splindex) {
                pshapesplash.slabsplashs[i].index = i;
                pslabsplashs.push(pshapesplash.slabsplashs[i]);
            }
        }
        pshapesplash.slabsplashs = pslabsplashs;
        setchangeflag();
       // console.log(JSON.stringify(pshapesplash.slabsplashs));
    }
}
function onupdatearealabels() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    if (area.labels == undefined) { area.labels = []; }   
    area.labels = arealabels;
    //prepare and save area label
    let amodel = { ID: area.ID, labels: area.labels};
    qpsavearealabel(amodel);
    //flag
    setchangeflag();    
    setareasaveflag(area);   
}

/********************************* Copy Area **************************************/
function setcopyarea31(area) {
    //set area part
    setcopypart(area);
    //set Labor
    setcopypartitems(area.laborList, area.ID);
    //set other
    setcopypartitems(area.otherList, area.ID);
    //set tiles
    setcopypartitems(area.tileList, area.ID);
    //set cabinet
    setcopypartitems(area.cabinetList, area.ID);
    //set customer items
    setcopypartitems(area.responseList, area.ID);
    //set area discounts
    setcopypartitems(area.QuoteAreaDiscountList, area.ID);
    //set unused material
    setunusedmaterial32();
    //set area summary
    calcareasummary31(area);
    //set version summary
    calcversionsummary31();
}
function setcopypart(area) {
    for (let i = 0; i < area.PartList.length; i++) {
        let part = area.PartList[i];
        part.ID = 0; part.AreaID = area.ID;
        //set part shape
        setcopypartshape(part, area);
        //set partmaterial
        setcopypartitems(part.PartMaterialList, part.AreaID);
        //set fabrication
        setcopypartitems(part.PartFabList, part.AreaID);
        //set splash
        setcopypartitems(part.SplashList, part.AreaID);
        //set edge
        setcopypartitems(part.EdgeList, part.AreaID);
        //set cutouts
        setcopypartitems(part.CutoutList, part.AreaID);
        //set template,install,Labor
        setcopypartitems(part.LaborList, part.AreaID);
        //set sink
        setcopypartitems(part.SinkList, part.AreaID);
        //set faucet
        setcopypartitems(part.FaucetList, part.AreaID);
        //set other
        setcopypartitems(part.OtherList, part.AreaID);
        //set appliance
        setcopypartitems(part.ApplianceList, part.AreaID);
        //set toos
        setcopypartitems(part.ToolList, part.AreaID);
        //set tiles
        setcopypartitems(part.TileList, part.AreaID);
        //set tconsumble
        setcopypartitems(part.ConsumableList, part.AreaID);
        //set abinet
        setcopypartitems(part.CabinetList, part.AreaID);
        //set customer items
        setcopypartitems(part.CustomerItemList, part.AreaID);
        //set part discounts
        setcopypartitems(part.PartDiscountList, part.AreaID);
        //set part summary
        //calcpartsummary31(part);
    }
}
function setcopyAreaItems34(area) {
    // set part
    setcopypart34(area.PartList, area);
    //set area material
    setcopyareamatitems34(area.AreaMaterialList, area.NoOfUnits, area.ID);
    //set partmaterial
    setcopypartitems34(area.partMaterialList, area.PartList, area.NoOfUnits, area.ID);
    //set fabrication
    setcopypartitems34(area.FabList, area.PartList, area.NoOfUnits, area.ID);
    //set splash
    setcopypartitems34(area.SplashList, area.PartList, area.NoOfUnits, area.ID);
    //set edge
    setcopypartitems34(area.EdgeList, area.PartList, area.NoOfUnits, area.ID);
    //set cutouts
    setcopypartitems34(area.CutList, area.PartList, area.NoOfUnits, area.ID);
    //set cutouts
    setcopypartitems34(area.OutletCutoutList, area.PartList, area.NoOfUnits, area.ID);
    //set cutouts
    setcopypartitems34(area.ApplianceCutoutList, area.PartList, area.NoOfUnits, area.ID);
    //set template
    setcopypartitems34(area.TemplateList, area.PartList, area.NoOfUnits, area.ID);
    //set install
    setcopypartitems34(area.InstallList, area.PartList, area.NoOfUnits, area.ID);
    //set Labor
    setcopypartitems34(area.laborList, area.PartList, area.NoOfUnits, area.ID);
    //set sink
    setcopypartitems34(area.sinkfaucetList, area.PartList, area.NoOfUnits, area.ID);
    //set faucet
    setcopypartitems34(area.faucetList, area.PartList, area.NoOfUnits, area.ID);
    //set other
    setcopypartitems34(area.otherList, area.PartList, area.NoOfUnits, area.ID);
    //set appliance
    setcopypartitems34(area.ApplianceList, area.PartList, area.NoOfUnits, area.ID);
    //set toos
    setcopypartitems34(area.ToolList, area.PartList, area.NoOfUnits, area.ID);
    //set tiles
    setcopypartitems34(area.TileList, area.PartList, area.NoOfUnits, area.ID);
    //set tconsumble
    setcopypartitems34(area.ConsumableList, area.PartList, area.NoOfUnits, area.ID);
    //set abinet
    setcopypartitems34(area.CabinetList, area.PartList, area.NoOfUnits, area.ID);
    //set customer items
    setcopypartitems34(area.responseList, area.PartList, area.NoOfUnits, area.ID);
    //set part discounts
    setcopypartitems34(area.QuoteAreaDiscountList, area.PartList, area.NoOfUnits, area.ID);
    //remove inactive parts
    removeinactiveparts34(area.PartList);
    //area total 
    area.TotalAmt = area.TotalAmt * area.NoOfUnits
}
function setcopypartshape(part, area) {
    let pshape = parsepartshape(part.Shape);
    if (pshape != null && pshape != 'null' && pshape != '' && pshape != undefined) {
        let partsrno = getlastactivepartsrno() + 1;
        let index = area.PartList.length;
        let areaindex = getareaindex();

        pshape.areaid = area.ID;
        pshape.unitcount = area.NoOfUnits;
        pshape.partsrno = partsrno;
        pshape.index = index;
        pshape.id = index;
        pshape.areaindex = areaindex;
        pshape.slabparts = [];
        pshape.slabsplashs = [];
    }
}
function setcopyareamatitems34(items, units, areaid) {
    if (items != undefined && items.length != null) {
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            if (item.IsActive == 0 || item.Isactive == 0) {
                items.splice(i, 1);
            } else {
                item.ID = 0; item.AreaUnits = units;
                item.PartID = 0;
                item.AreaID = areaid;
            }
        }
    }
}
function setcopypartitems34(items, partlist, units, areaid) {
    if (items != undefined && items.length != null) {
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            if (item.IsActive == 0 || item.Isactive == 0) {
                items.splice(i, 1);
            } else {
                item.ID = 0; item.AreaUnits = units;
                item.PartID = 0;
                item.AreaID = areaid;
                if (item.PartSrNo > 0) {
                    let part = getpartbypartprevsrno34(partlist, items[i].PartSrNo);
                    item.PartSrNo = part.SrNo;
                }
            }
        }
    }
}
function setcopypartitems(items, areaid, units) {
    if (items != undefined && items.length != null) {
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            item.ID = 0; item.AreaUnits = units;
            item.PartID = 0;
            item.AreaID = areaid;
        }
    }
}
function setcopypart34(parts, area) {
    if (parts != undefined && parts.length != null) {
        for (let i = parts.length - 1; i >= 0; i--) {
            let part = parts[i];
            if (part.IsActive == 1) {
                part.ID = 0;
                part.AreaID = area.ID; part.AreaUnits = area.NoOfUnits;
                part.PrevSrNo = part.PrevSrNo == undefined || part.PrevSrNo == null ? part.SrNo : part.PrevSrNo;
                //copy Shape
                setcopypartshape(part, area);
                //part items
                setcopyareapartitems33(part, area.NoOfUnits);
            }
        }
    }
}
function setcopyareapartitems33(part, units) {
    //set partmaterial
    setcopypartitems(part.PartMaterialList, part.AreaID, units);
    //set fabrication
    setcopypartitems(part.PartFabList, part.AreaID, units);
    //set splash
    setcopypartitems(part.SplashList, part.AreaID, units);
    //set edge
    setcopypartitems(part.EdgeList, part.AreaID, units);
    //set cutouts
    setcopypartitems(part.CutoutList, part.AreaID, units);
    //set template,install,Labor
    setcopypartitems(part.LaborList, part.AreaID, units);
    //set sink
    setcopypartitems(part.SinkList, part.AreaID, units);
    //set faucet
    setcopypartitems(part.FaucetList, part.AreaID, units);
    //set other
    setcopypartitems(part.OtherList, part.AreaID, units);
    //set appliance
    setcopypartitems(part.ApplianceList, part.AreaID, units);
    //set toos
    setcopypartitems(part.ToolList, part.AreaID, units);
    //set tiles
    setcopypartitems(part.TileList, part.AreaID, units);
    //set tconsumble
    setcopypartitems(part.ConsumableList, part.AreaID, units);
    //set abinet
    setcopypartitems(part.CabinetList, part.AreaID, units);
    //set customer items
    setcopypartitems(part.CustomerItemList, part.AreaID, units);
    //set part discounts
    setcopypartitems(part.PartDiscountList, part.AreaID, units);
}
function removeinactiveparts34(parts) {
    if (parts != undefined && parts.length != null) {
        for (let i = parts.length - 1; i >= 0; i--) {
            let part = parts[i];
            if (part.IsActive == 0) {
                parts.splice(i, 1);
            }
        }
    }
}
function setinactivepartitems(items,partid, partsrno, isactive) {
    if (items != undefined && items.length != null) {
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            if (item.PartID == partid) {
                item.Isactive = isactive;
                item.IsActive = isactive;
            }
        }
    }
}
function setinactivepart34(items, partid, partsrno, isactive) {
    if (items != undefined && items.length != null) {
        for (let i = 0; i < items.length; i++) {
            let item = items[i];
            if (item.ID == partid) {
                item.IsActive = isactive;
                return item.IsActive;
            }
        }
    }
}
function resetareapartssrno34(partlist) {
    let partsrno = 1;
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].IsActive == 1) {
            partlist[i].PrevSrNo = partlist[i].SrNo;
            partlist[i].SrNo = partsrno;
            partsrno++;
        }
    }
}
function activeinactiveareapartItems34(area, partid, partsrno, isactive) {
    //set parts
    setinactivepart34(area.PartList, partid, partsrno, isactive);
    //re arrange part 
    resetareapartssrno34(area.PartList);
    //set partmaterial
    setinactivepartitems(area.partMaterialList, partid, partsrno, isactive);
    //set fabrication
    setinactivepartitems(area.FabList, partid, partsrno, isactive);
    //set splash
    setinactivepartitems(area.SplashList, partid, partsrno, isactive);
    //set edge
    setinactivepartitems(area.EdgeList, partid, partsrno, isactive);
    //set cutouts
    setinactivepartitems(area.CutList, partid, partsrno, isactive);
    //set cutouts
    setinactivepartitems(area.OutletCutoutList, partid, partsrno, isactive);
    //set cutouts
    setinactivepartitems(area.ApplianceCutoutList, partid, partsrno, isactive);
    //set template
    setinactivepartitems(area.TemplateList, partid, partsrno, isactive);
    //set install
    setinactivepartitems(area.InstallList, partid, partsrno, isactive);
    //set Labor
    setinactivepartitems(area.laborList, partid, partsrno, isactive);
    //set sink
    setinactivepartitems(area.sinkfaucetList, partid, partsrno, isactive);
    //set faucet
    setinactivepartitems(area.faucetList, partid, partsrno, isactive);
    //set other
    setinactivepartitems(area.otherList, partid, partsrno, isactive);
    //set appliance
    setinactivepartitems(area.ApplianceList, partid, partsrno, isactive);
    //set toos
    setinactivepartitems(area.ToolList, partid, partsrno, isactive);
    //set tiles
    setinactivepartitems(area.TileList, partid, partsrno, isactive);
    //set tconsumble
    setinactivepartitems(area.ConsumableList, partid, partsrno, isactive);
    //set abinet
    setinactivepartitems(area.CabinetList, partid, partsrno, isactive);
    //set customer items
    setinactivepartitems(area.responseList, partid, partsrno, isactive);
    //set part discounts
    setinactivepartitems(area.QuoteAreaDiscountList, partid, partsrno, isactive);
    // area summary
    Preparenewareaitemssummary34(area);
    // cal Summary
    calcpartareaversionsummary34(area);
    return area;
}
function Preparenewareaitemssummary34(area) {
   //summay shape items
    prepareareasummarygroup34(area);
    //set Labor
    resetareaadditionalsummary34(area.laborList);
    //set sink
    resetareaadditionalsummary34(area.sinkfaucetList);
    //set faucet
    resetareaadditionalsummary34(area.faucetList);
    //set other
    resetareaadditionalsummary34(area.otherList);
    //set appliance
    resetareaadditionalsummary34(area.ApplianceList);
    //set toos
    resetareaadditionalsummary34(area.ToolList);
    //set tiles
    resetareaadditionalsummary34(area.TileList);
    //set tconsumble
    resetareaadditionalsummary34(area.ConsumableList);
    //set abinet
    resetareaadditionalsummary34(area.CabinetList);
    //set customer items
    resetarearesponsesummary34(area.responseList);
    //set part discounts
   // setinactivepartitems(area.QuoteAreaDiscountList);
}
///////////////////////////////////////////////New Code Area Summary////////////////////////////////////////////////
function setshapeareaitems34(part, isnewpart) {
    // get area
    let area = getareabyid(part.AreaID);
    area.SaveFlag = 1;
    // remove current part items
    removepartitems34(area, part.SrNo, isnewpart);
    // assign new items to area
    resetpartitemsinarea34(area, part);
    // area summary
    prepareareasummarygroup34(area);
    //cal version summary
    //calcpartareaversionsummary34(area);
    setareaqtyround34(area);
}
function removepartitems34(area, srno, isnewpart) {
    if (isnewpart == 0) {
        //remove part material
        removeareapartItems34(area.partMaterialList, srno);
        //remove part fab
        removeareapartItems34(area.FabList, srno);
        //remove part splashs
        removeareapartItems34(area.SplashList, srno);
        //remove part template
        removeareapartItems34(area.TemplateList, srno);
        //remove part install
        removeareapartItems34(area.InstallList, srno);
        //remove part edges
        removeareapartItems34(area.EdgeList, srno);
        //remove part cutouts
        removeareapartItems34(area.CutList, srno);
        //remove part cutouts
        removeareapartItems34(area.OutletCutoutList, srno);
        //remove part cutouts
        removeareapartItems34(area.ApplianceCutoutList, srno);
        //remove part sinks
        removeareapartItems34(area.sinkfaucetList, srno);
    }
}
function removeareapartItems34(itemlist, srno) {
    itemlist = itemlist == null ? [] : itemlist;
    for (let i = itemlist.length - 1; i >= 0; i--) {
        if (itemlist[i].PartSrNo == srno) {
            itemlist.splice(i, 1);
        }
    }
}
function removeareapartaddItems34(itemlist, srno) {
    itemlist = itemlist == null ? [] : itemlist;
    for (let i = itemlist.length - 1; i >= 0; i--) {
        if (itemlist[i].PartSrNo == srno) {
            itemlist[i].Isactive = 0;
        }
    }
}
function resetpartitemsinarea34(area, part) {
    area.partMaterialList = area.partMaterialList.concat(part.PartMaterialList);
    area.FabList = area.FabList.concat(part.PartFabList);
    area.SplashList = area.SplashList.concat(part.SplashList);
    area.EdgeList = area.EdgeList.concat(part.EdgeList);
    if (part.SinkList != null) { assignpartsinkstoarea34(area, part.SinkList); }
    if (part.FaucetList != null) { assignpartfaucetstoarea34(area, part.FaucetList); }
    if (part.OtherList != null) { assignpartaddonstoarea34(area, part.OtherList); }
    if (part.TileList != null) { assignparttilestoarea34(area, part.TileList); }
    if (part.LaborList != null) { assignpartlaborstoarea34(area, part.LaborList); }
    if (part.ApplianceList != null) { assignpartappliancetoarea34(area, part.ApplianceList); }
    if (part.CabinetList != null) { assignpartcabinetstoarea34(area, part.CabinetList); }
    if (part.ToolList != null) { assignparttooltoarea34(area, part.ToolList); }
    if (part.ConsumableList != null) { assignpartconsumabletoarea34(area, part.ConsumableList); }
    if (part.CustomerItemList != null) { assignpartcustitemstoarea34(area, part.CustomerItemList); }
    if (part.LaborList != null) { assigntempandinsttoarea34(area, part.LaborList); }
    if (part.CutoutList != null) { assigncutoutstoarea34(area, part.CutoutList); }
}
function resetpartitemsinarea344(area, part) {
    area.partMaterialList = area.partMaterialList.concat(part.PartMaterialList);
    area.FabList = area.FabList.concat(part.PartFabList);
    area.SplashList = area.SplashList.concat(part.SplashList);
    area.EdgeList = area.EdgeList.concat(part.EdgeList);
    //assignpartsinkstoarea34(area, part.SinkList);
    assigntempandinsttoarea34(area, part.LaborList);
   // assigncutoutstoarea34(area, part.CutoutList);
}
function assignpartsinkstoarea34(area, sinks) {
    for (let i = 0; i < sinks.length; i++) {
        if (sinks[i].ID == 0 && sinks[i].Isactive == 1) {
            if (area.sinkfaucetList.length == 0) { area.sinkfaucetList.push(sinks[i]); }
        }
        else if (sinks[i].ID > 0) {
            area.sinkfaucetList.push(sinks[i]);
        } 
    }
    area.AreaItems.SinkList = resetareaadditionalsummary34(area.sinkfaucetList);
}
function assignpartfaucetstoarea34(area, faucets) {
    for (let i = 0; i < faucets.length; i++) {
        if (faucets[i].ID == 0 && faucets[i].Isactive == 1) {
            if (area.faucetList.length == 0) { area.faucetList.push(faucets[i]); }
        }
        else if (faucets[i].ID > 0) {
            area.faucetList.push(faucets[i]);
        }
    }
    area.AreaItems.FaucetList = resetareaadditionalsummary34(area.faucetList);
}
function assignpartaddonstoarea34(area, addons) {
    for (let i = 0; i < addons.length; i++) {
        if (addons[i].ID == 0 && addons[i].Isactive == 1) {
            if (area.otherList.length == 0) { area.otherList.push(addons[i]); }
        }
        else if (addons[i].ID > 0) {
            area.otherList.push(addons[i]);
        }
    }
    area.AreaItems.OtherList = resetareaadditionalsummary34(area.otherList);
}
function assignparttilestoarea34(area, tiles) {
    for (let i = 0; i < tiles.length; i++) {
        if (tiles[i].ID == 0 && tiles[i].Isactive == 1) {
            if (area.TileList.length == 0) { area.TileList.push(tiles[i]); }
        }
        else if (tiles[i].ID > 0) {
            area.TileList.push(tiles[i]);
        }
    }
    area.AreaItems.TileList = resetareaadditionalsummary34(area.TileList);
}
function assignpartlaborstoarea34(area, labors) {
    for (let i = 0; i < labors.length; i++) {
        if (labors[i].ID == 0 && labors[i].Isactive == 1 && labors[i].ViewTypeID != 1) {
            if (area.laborList.length == 0) { area.laborList.push(labors[i]); }
        }
        else if (labors[i].ID > 0 && labors[i].ViewTypeID != 1) {
            area.laborList.push(labors[i]);
        }
    }
    area.AreaItems.LaborList = resetareaadditionalsummary34(area.laborList);
}
function assignpartappliancetoarea34(area, appliances) {
    for (let i = 0; i < appliances.length; i++) {
        if (appliances[i].ID == 0 && appliances[i].Isactive == 1) {
            if (area.ApplianceList.length == 0) { area.ApplianceList.push(appliances[i]); }
        }
        else if (appliances[i].ID > 0) {
            area.ApplianceList.push(appliances[i]);
        }
    }
    area.AreaItems.ApplianceList = resetareaadditionalsummary34(area.ApplianceList);
}
function assignpartcabinetstoarea34(area, cabinets) {
    for (let i = 0; i < cabinets.length; i++) {
        if (cabinets[i].ID == 0 && cabinets[i].Isactive == 1) {
            if (area.CabinetList.length == 0) { area.CabinetList.push(cabinets[i]); }
        }
        else if (cabinets[i].ID > 0) {
            area.CabinetList.push(cabinets[i]);
        }
    }
    area.AreaItems.CabinetList = resetareaadditionalsummary34(area.CabinetList);
}
function assignparttooltoarea34(area, tools) {
    for (let i = 0; i < tools.length; i++) {
        if (tools[i].ID == 0 && tools[i].Isactive == 1) {
            if (area.ToolList.length == 0) { area.ToolList.push(tools[i]); }
        }
        else if (tools[i].ID > 0) {
            area.ToolList.push(tools[i]);
        }
    }
    area.AreaItems.ToolList = resetareaadditionalsummary34(area.ToolList);
}
function assignpartconsumabletoarea34(area, consumables) {
    for (let i = 0; i < consumables.length; i++) {
        if (consumables[i].ID == 0 && consumables[i].Isactive == 1) {
            if (area.ConsumableList.length == 0) { area.ConsumableList.push(consumables[i]); }
        }
        else if (consumables[i].ID > 0) {
            area.ConsumableList.push(consumables[i]);
        }
    }
    area.AreaItems.ConsumableList = resetareaadditionalsummary34(area.ConsumableList);
}

function assignpartcustitemstoarea34(area, custitems) {
    for (let i = 0; i < custitems.length; i++) {
        if (custitems[i].ID == 0 && custitems[i].Isactive == 1) {
            area.responseList.push(custitems[i]);
        }
        else if (custitems[i].ID > 0) {
            area.responseList.push(custitems[i]);
        }
    }
    area.AreaItems.ResponseList = resetareaadditionalsummary34(area.responseList);
}
function assigntempandinsttoarea34(area, fablaborlist) {
    let templatelist = [], installlist = [];
    for (let i = 0; i < fablaborlist.length; i++) {
        if (fablaborlist[i].ViewTypeID == 1) {
            if (fablaborlist[i].Description == "Template") {
                templatelist.push(fablaborlist[i]);
            } else if (fablaborlist[i].Description == "Install") {
                installlist.push(fablaborlist[i]);
            }
        }
    }
    area.TemplateList = area.TemplateList.concat(templatelist);
    area.InstallList = area.InstallList.concat(installlist);
}
function assigncutoutstoarea34(area, cutoutlist) {
    let partSinkcolist = [], otletcolist = [], appcolist = [];
    area.OutletCutoutList = area.OutletCutoutList == null ? [] : area.OutletCutoutList;
    area.ApplianceCutoutList = area.ApplianceCutoutList == null ? [] : area.ApplianceCutoutList;
    var cutouts = groupitemswithInactive34(cutoutlist, function (item) {
        return [item.CutOutTypeID];
    });
    Object.keys(cutouts).map(function (group) {
        // for (let i = 0; i < cutouts.length; i++) {
        let list = cutouts[group];
        if (list[0].CutOutTypeID == 1) {
            partSinkcolist = list;
        }
        if (list[0].CutOutTypeID == 2) {
            otletcolist = list;
        }
        if (list[0].CutOutTypeID == 3) {
            appcolist = list;
        }
    });
    area.CutList = area.CutList.concat(partSinkcolist);
    area.OutletCutoutList = area.OutletCutoutList.concat(otletcolist);
    area.ApplianceCutoutList = area.ApplianceCutoutList.concat(appcolist);
}
function resetareamaterialsummary34(partmatlist) {
    //group items
    let summaryitems = groupitems34(partmatlist, function (item) {
        return [item.MaterialID, Number(item.UnitPrice), item.IsOptional, item.CoID, item.CoSrNo];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartmaterialstotalamt34(items, items[0].CoID);
        let obj = {
            MaterialID: items[0].MaterialID, MaterialName: items[0].MaterialName, UnitPrice: items[0].UnitPrice, IsOptional: items[0].IsOptional, IsChg: items[0].IsChg, CoID: items[0].CoID,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoSrNo: items[0].CoSrNo, Qty: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt,
            ProductDescription: items[0].ProductDescription, ChildList: items, IsActive: items[0].IsActive,
        }
        return obj;
    })
}
function resetareafabsummary34(fablist) {
    //group items
    let summaryitems = groupitems34(fablist, function (item) {
        return [item.Description,Number(item.LaborUnitPrice), item.IsOptional, item.CoID, item.CoSrNo, item.FabIsActive];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartfabtotalamt34(items);
        let obj = {
            Description: items[0].Description,LaborUnitPrice: items[0].LaborUnitPrice, IsOptional: items[0].IsOptional, UnitCost: items[0].UnitCost, Margin: items[0].Margin, IsChg: items[0].IsChg,FabIsActive: items[0].FabIsActive,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoID: items[0].CoID, CoSrNo: items[0].CoSrNo, PartSqft: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt,
            ProductDescription: items[0].ProductDescription, ChildList: items, FabIsActive: items[0].FabIsActive, Isactive: items[0].Isactive,
        }
        return obj;
    })
}
function resetareasplashsummary34(splashlist) {
    //group items
    let summaryitems = groupitems34(splashlist, function (item) {
        return [item.Splash, convertToFloat(item.SFPrice), item.IsOptional, item.CoID, item.CoSrNo, item.TypeID];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartsplashtotalamt34(items);
        let obj = {
            Splash: items[0].Splash, TypeID: items[0].TypeID, SFPrice: items[0].SFPrice, SFCost: items[0].SFCost, SFMargin: items[0].SFMargin, IsOptional: items[0].IsOptional, IsChg: items[0].IsChg, CoID: items[0].CoID,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoSrNo: items[0].CoSrNo, Qty: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt, TotalLFUnitAmt: itemobj.TotalLFUnitAmt,
            UnitPrice: items[0].UnitPrice, UnitCost: items[0].UnitCost, LFMargin: items[0].LFMargin, LF: items[0].LF, ProductDescription: items[0].ProductDescription, ChildList: items, Isactive: items[0].Isactive
        }
        return obj;
    })
}
function resetareasplashlfsummary34(splashlist) {
    //group items
    let summaryitems = groupitems34(splashlist, function (item) {
        return [item.Splash, convertToFloat(item.UnitPrice), item.IsOptional, item.CoID, item.CoSrNo, item.TypeID];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartsplashtotallfamt34(items);
        let obj = {
            Splash: items[0].Splash, TypeID: items[0].TypeID, UnitPrice: items[0].UnitPrice, UnitCost: items[0].UnitCost, LFMargin: items[0].LFMargin,IsOptional: items[0].IsOptional, IsChg: items[0].IsChg, CoID: items[0].CoID,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoSrNo: items[0].CoSrNo, Qty: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt, ProductDescription: items[0].ProductDescription, ChildList: items, Isactive: items[0].Isactive
        }
        return obj;
    })
}
function resetareaedgesummary34(edgelist) {
    //group items
    let summaryitems = groupitems34(edgelist, function (item) {
        return [ item.EdgeProfile, Number(item.UnitPrice), item.IsOptional, item.CoID, item.CoSrNo];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartedgestotalamt34(items);
        let obj = {
            EdgeProfile: items[0].EdgeProfile, UnitPrice: items[0].UnitPrice, UnitCost: items[0].UnitCost, Margin: items[0].Margin, IsOptional: items[0].IsOptional,  IsChg: items[0].IsChg,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoID: items[0].CoID, CoSrNo: items[0].CoSrNo, LF: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt, ProductDescription: items[0].ProductDescription, ChildList: items, Isactive: items[0].Isactive
        }
        return obj;
    })
}
function resetareacutoutsummary34(cutoutlist) {
    //group items
    let summaryitems = groupitems34(cutoutlist, function (item) {
        return [item.Type, Number(item.Unitprice), item.IsOptional, item.CoID, item.CoSrNo, item.CutoutTypeID];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartcutoutstotalamt34(items);
        let obj = {
            Type: items[0].Type, Unitprice: items[0].Unitprice, UnitCost: items[0].UnitCost, Margin: items[0].Margin, CutOutTypeID: items[0].CutOutTypeID, IsOptional: items[0].IsOptional, IsChg: items[0].IsChg,
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoID: items[0].CoID, CoSrNo: items[0].CoSrNo, LF: itemobj.Qty, Amt: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt, Isactive: items[0].Isactive,
            ProductDescription: items[0].ProductDescription, ChildList: items
        }

        return obj;
    })
}
function resetareaadditionalsummary34(itemlist) {
    //group items
    let summaryitems = groupitems34(itemlist, function (item) {
        return [item.Description, Number(item.UnitPrice), item.IsOptional, item.CoID, item.CoSrNo];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let itemobj = calcpartadditionalstotalamt34(items);
        let obj = {
            Description: items[0].Description, UnitPrice: items[0].UnitPrice, UnitCost: items[0].UnitCost, Margin: items[0].Margin, TypeID: items[0].TypeID, IsOptional: items[0].IsOptional, IsChg: items[0].IsChg, Price: items[0].Price, RoundUp: items[0].RoundUp, UnitTypeID: items[0].UnitTypeID, ViewTypeID: items[0].ViewTypeID, 
            Tax: items[0].Tax, IsPrint: items[0].IsPrint, CoID: items[0].CoID, CoSrNo: items[0].CoSrNo, Qty: itemobj.Qty, Amount: itemobj.Amt, AreaUnits: items[0].AreaUnits, TotalUnitAmt: itemobj.TotalUnitAmt, ProductDescription: items[0].ProductDescription, ChildList: items, Isactive: items[0].Isactive,
        }
        return obj;
    })
}
function resetarearesponsesummary34(itemlist) {
    //group items
    let summaryitems = groupitems34(itemlist, function (item) {
        return [item.Description, item.CoID, item.CoSrNo, item.IsChg];
    });
    // preparing of summary object
    return Object.keys(summaryitems).map(function (group) {
        let items = summaryitems[group];
        let obj = {
            Description: items[0].Description, IsChg: items[0].IsChg,
            CoID: items[0].CoID, CoSrNo: items[0].CoSrNo,
        }
        return obj;
    })
}

function prepareshapeareasummarygroup34(area) {
    // grouping of material
    area.AreaItems.PartMaterialList = resetareamaterialsummary34(area.partMaterialList);
    resetareamaterialsqft34(area);
    // grouping of spalsh
    area.AreaItems.SplashList = resetareasplashsummary34(area.SplashList);
    // grouping of spalsh
    //area.AreaItems.SplashLFList = resetareasplashlfsummary34(area.SplashList);
    // grouping of fabs
    area.AreaItems.FabList = resetareafabsummary34(area.FabList);
    // grouping of template
    area.AreaItems.TemplateList = resetareaadditionalsummary34(area.TemplateList);
    // grouping of template
    area.AreaItems.InstallList = resetareaadditionalsummary34(area.InstallList);
     // grouping of labor
    area.AreaItems.LaborList = resetareaadditionalsummary34(area.laborList);
}
function prepareareasummarygroup34(area) {
    // shape replated
    prepareshapeareasummarygroup34(area);
    //others
    // grouping of edge
    area.AreaItems.EdgeList = resetareaedgesummary34(area.EdgeList);
    // grouping of sink cutout
    area.AreaItems.SinkCutoutList = resetareacutoutsummary34(area.CutList);
    // grouping of outlet cutout
    area.AreaItems.OutletCutoutList = resetareacutoutsummary34(area.OutletCutoutList);
    // grouping of app cutout
    area.AreaItems.ApplianceCutoutList = resetareacutoutsummary34(area.ApplianceCutoutList);;
}
function groupitems34(array, f) {
    var groups = {};
    array.forEach(function (o) {
        if (o.IsActive == 1 || o.Isactive == 1) {
            var group = JSON.stringify(f(o));
            groups[group] = groups[group] || [];
            groups[group].push(o);
        }
    });
    return groups;

}
function groupitemswithInactive34(array, f) {
    var groups = {};
    array.forEach(function (o) {
            var group = JSON.stringify(f(o));
            groups[group] = groups[group] || [];
            groups[group].push(o);
    });
    return groups;

}
function resetpartsrnoinareaitems34() {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);   
    //set partmaterial
    resetpartsrno34(area.partMaterialList, area.PartList,1);
    //set fabrication
    resetpartsrno34(area.FabList, area.PartList,1);
    //set splash
    resetpartsrno34(area.SplashList, area.PartList,1);
    //set edge
    resetpartsrno34(area.EdgeList, area.PartList,2);
    //set cutouts
    resetpartsrno34(area.CutList, area.PartList,2);
    //set cutouts
    resetpartsrno34(area.OutletCutoutList, area.PartList,2);
    //set cutouts
    resetpartsrno34(area.ApplianceCutoutList, area.PartList,2);
    //set template
    resetpartsrno34(area.TemplateList, area.PartList,0);
    //set install
    resetpartsrno34(area.InstallList, area.PartList,0);
    //set Labor
    resetpartsrno34(area.laborList, area.PartList,0);
    //set sink
    resetpartsrno34(area.sinkfaucetList, area.PartList,0);
    //set faucet
    resetpartsrno34(area.faucetList, area.PartList,0);
    //set other
    resetpartsrno34(area.otherList, area.PartList,0);
    //set appliance
    resetpartsrno34(area.ApplianceList, area.PartList,0);
    //set toos
    resetpartsrno34(area.ToolList, area.PartList,0);
    //set tiles
    resetpartsrno34(area.TileList, area.PartList,0);
    //set tconsumble
    resetpartsrno34(area.ConsumableList, area.PartList,0);
    //set abinet
    resetpartsrno34(area.CabinetList, area.PartList,0);
    //set customer items
    resetpartsrno34(area.responseList, area.PartList,0);
    //set part discounts
    resetpartsrno34(area.QuoteAreaDiscountList, area.PartList,0);
    // area summary
    Preparenewareaitemssummary34(area);
    //cal version summary
    calcpartareaversionsummary34(area);
}
function getpartbypartprevsrno34(partlist, partsrno) {
    for (let i = 0; i < partlist.length; i++) {
        if (partlist[i].PrevSrNo == partsrno && partlist[i].IsActive == 1) {
            return partlist[i];
        }
    }
}
function resetpartsrno34(items,partlist,typeId) {
    if (items != undefined && items.length != null) {
        for (let i = 0; i < items.length; i++) {
            if (items[i].PartSrNo > 0) {
                let part = getpartbypartprevsrno34(partlist, items[i].PartSrNo);
                if (part != undefined && part != "") {
                    items[i].PartSrNo = part.SrNo;
                } else {
                    items[i].Isactive = 0; items[i].IsActive = 0; items[i].Qty = 0; items[i].LF = 0;
                    if (typeId == 1) { items[i].PartSqft = 0; items[i].SplashSqft = 0; items[i].Sqft = 0 }
                }
            }
        }
    }
}
function getnondrawingpartbypartsrno(partlist) {
    for (let i = 0; i < partlist.length; i++) {
        if ((partlist[i].Shape == "" || partlist[i].Shape == null)&& partlist[i].IsActive == 1) {
            return partlist[i];
        }
    }
}