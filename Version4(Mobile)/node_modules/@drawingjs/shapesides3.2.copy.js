function initshapeside(index) {
    var side = {
        index: index, spsideindex: index, sindex: shape.index, angle: 0, atype: 1, asign: 1, dsign: 1, h: shape.h, w: 0, w1: 0, w2: 0, x1: 0, y1: 0, x2: 0, y2: 0, stype: '', stypeid: 0, note: '',
        x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, cline: 0, edges: [], corners: [], sideshapes: [], cutouts: [], seams: [], splashs: [], sidesegs: []
    };
    shape.sides.push(side);   
    initsidecorners(index);
    initsidesegs(side);
}
function initsidesegs(side) {
    side.sidesegs = [];
    side.sidesegs.push({ sidecode: 0, segs: [] });
    side.sidesegs.push({ sidecode: 1, segs: [] });
    side.sidesegs.push({ sidecode: 2, segs: [] });
    side.sidesegs.push({ sidecode: 3, segs: [] });   
}
function setnewshapeside(x2, y2) {
    let dh = shape.h / 2;
    let x1 = 0, y1 = 0;
    let index = shape.opoints.length - 1;
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];   
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
    let npt2 = offsetline(x1, y1, x2, y2, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;
    setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22);
    for (var j = 0; j < shape.sides.length; j++) {
        shapesideintrpoints(j);
        shapesideintrpoints1(j);
        shapesideintrpoints2(j);
    }
    setshapesidesegs(index);
    setsideedges(index);
}
function setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22) {
    if (index > shape.sides.length - 1) { initshapeside(index); }
    setsidecenterline(index, x1, y1, x2, y2);
    setsideouterline1(index, x11, y11, x12, y12);
    setsideouterline2(index, x21, y21, x22, y22);
}
function setsidecenterline(index, x1, y1, x2, y2) {
    var side = shape.sides[index];
    side.x1 = Math.round(x1), side.y1 = Math.round(y1), side.x2 = Math.round(x2), side.y2 = Math.round(y2);
    if (x1 == x2) { side.w = Math.abs(y1 - y2) / scale; } else if (y1 == y2) { side.w = Math.abs(x1 - x2) / scale; }
    else { side.w = calchyplen(x1, y1, x2, y2) / scale; }
}
function setsideouterline1(index, x11, y11, x12, y12) {
    var side = shape.sides[index];
    side.x11 = Math.round(x11), side.y11 = Math.round(y11), side.x12 = Math.round(x12), side.y12 = Math.round(y12);
    if (x11 == x12) { side.w1 = Math.abs(y11 - y12) / scale; } else if (y11 == y12) { side.w1 = Math.abs(x11 - x12) / scale; }
    else { side.w1 = calchyplen(x11, y11, x12, y12) / scale; }
}
function setsideouterline2(index, x21, y21, x22, y22) {
    var side = shape.sides[index];
    side.x21 = Math.round(x21), side.y21 = Math.round(y21), side.x22 = Math.round(x22), side.y22 = Math.round(y22);
    if (x21 == x22) { side.w2 = Math.abs(y21 - y22) / scale; } else if (y21 == y22) { side.w2 = Math.abs(x21 - x22) / scale; }
    else { side.w2 = calchyplen(x21, y21, x22, y22) / scale; }
}
function sidestartpos(sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let x1 = 0, y1 = 0;
    if (sidecode == 0) { x1 = side.x11, y1 = side.y11; } else if (sidecode == 1) { x1 = side.x11, y1 = side.y11; }
    else if (sidecode == 2) { x1 = side.x21, y1 = side.y21; } else if (sidecode == 3) { x1 = side.x12, y1 = side.y12; }   
    let cindex = sidecornerindex(sideindex, x1, y1);
    if (cindex != -1) {
        let corner = side.corners[cindex];
        if (corner.type != 0) {if (sidecode == 0 || sidecode == 3) { x1 = corner.x3, y1 = corner.y3; } else {
                x1 = corner.x2, y1 = corner.y2;
            }           
        }
    }
    return { dx: x1, dy: y1 };
}
function sideendpos1(sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0;
    if (sidecode == 1) { x2 = side.x12, y2 = side.y12; } else if (sidecode == 2) { x2 = side.x22, y2 = side.y22; }  
    if (sideindex == shape.sides.length - 1) {
        let cindex2 = sidecornerindex(sideindex, x2, y2);
        if (cindex2 != -1) {
            let corner1 = side.corners[cindex2];
            if (corner1.type != 0) { x2 = corner1.x2, y2 = corner1.y2; }
        }
    } else if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];        
        if (sidecode == 1) { x2 = side1.x11, y2 = side1.y11; } else if (sidecode == 2) { x2 = side1.x21, y2 = side1.y21; }        
        let cindex1 = sidecornerindex(sideindex + 1, x2, y2);
        if (cindex1 != -1) {
            let corner1 = side1.corners[cindex1];
            if (corner1.type != 0) { x2 = corner1.x3, y2 = corner1.y3; }
        }
    }
    return { dx: x2, dy: y2 };
}
function sideendpos2(sideindex, sidecode) {  
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0, corner1;
    if (sidecode == 0) { x2 = side.x21, y2 = side.y21; corner1 = side.corners[1]; } else if (sidecode == 3) { x2 = side.x22, y2 = side.y22; corner1 = side.corners[3]; }   
    if (corner1 != undefined && corner1.type != 0) { x2 = corner1.x3, y2 = corner1.y3; }
    return { dx: x2, dy: y2 };
}
function resetallshapesidesesgs(index) {
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidesegs(i);
    }
}
function setshapesidesegs(sideindex) {   
    if (sideindex == 0) {setsidesegs(sideindex, 0);}
    setsidesegs(sideindex, 1);
    setsidesegs(sideindex, 2);   
    if (sideindex == shape.sides.length - 1) {setsidesegs(sideindex, 3);}
}
function setsidesegs(sideindex, sidecode) {   
    let side = shape.sides[sideindex];   
    if (side.sidesegs == undefined || side.sidesegs.length==0) { initsidesegs(side); }
    let sidecodeseg = side.sidesegs[sidecode];
    sidecodeseg.segs = [];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, angle=0;
    let npt = sidestartpos(sideindex, sidecode);
    sx1 = npt.dx, sy1 = npt.dy;
    if (sidecode == 0) { angle = calclineangle2(x11, y11, x21, y21) }
    else if (sidecode == 1) { angle = calclineangle2(x11, y11, x12, y12); }
    else if (sidecode == 2) { angle = calclineangle2(x21, y21, x22, y22); }
    else if (sidecode == 3) { angle = calclineangle2(x12, y12, x22, y22); }    
    for (let j = 0; j < side.sideshapes.length; j++) {
        let sideshape = side.sideshapes[j];
        //3- Full arc, 4- Bump out arc, 7-Bump in Arc, 6- Bumpout, 5-Bump in,1-Bumpout Angle, 2- Bumpin Angle        
        if (sideshape.isactive == 1 && sideshape.sidecode == sidecode) {
            if (sideshape.type == 1 || sideshape.type == 4 || sideshape.type == 6) {               
                sx2 = sideshape.x11, sy2 = sideshape.y11, sw = sideshape.w;
                setsidecodeseg(sx1, sy1, sx2, sy2, sidecodeseg);
                npt = rotate_point1(sx2, sy2, -1, angle, sw); //second point on side
                sx1 = npt.dx, sy1 = npt.dy;
                //drawpointcircle(j, j, sideindex, sidecode, sx1, sy1, 10, 'U')
                //drawpointcircle(j+1, j, sideindex, sidecode, sx2, sy2, 10, 'U')
            }
        }
    }   
    if (sidecode == 0 || sidecode == 3) { npt = sideendpos2(sideindex, sidecode); } else { npt = sideendpos1(sideindex, sidecode);}   
    sx2 = npt.dx, sy2 = npt.dy;
    setsidecodeseg(sx1, sy1, sx2, sy2, sidecodeseg);
}
function sidesegswidth(sideindex, sidecode) {
    let sw = 0;
    let side = shape.sides[sideindex];
    let sidecodeseg = side.sidesegs[sidecode];
    for (let i = 0; i < sidecodeseg.segs.length; i++) {sw += sidecodeseg.segs[i].sw;}
    return roundToTwo(sw);
}
function setsidecodeseg(sx1, sy1, sx2, sy2, sidecodeseg) {
    let segw = roundToTwo(calchyplen(sx1, sy1, sx2, sy2) / scale);
    let seg = { x1: sx1, y1: sy1, x2: sx2, y2: sy2, sw: segw };
    sidecodeseg.segs.push(seg);
}
function onshapeside() {    
    removeshapetools();
    d3.event.stopPropagation();
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        if (editmode == 1) { editmode = 0; drawshapesides(shape.index, 'onshapeside'); }
        let m = d3.mouse(this);
        let index = parseInt(this.getAttribute("index"));        
        let code = parseInt(this.getAttribute("code"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapeside');
        if (drawmode == 3) {
            onsetsideshape(m[0], m[1], -1, index, code);
        } else if (drawmode == 4) {
            onsetsidesplash(index, code, 1);
        } else if (drawmode == 5) {           
            onsetsideedge(index, code, edgetype, edgetypeid);
        } else if (drawmode == 8) {
            onsetsideapron(index, code, 1, edgetype, edgetypeid);
        }
    }
}
function oneditshapeside() {
    let objVal = $(this).val().split(" ");    
    let neww = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));   
    if (isNaN(neww)) { return; }  
    let mode = this.getAttribute("smode");
    let index = parseInt(this.getAttribute("index"));
    let code = parseInt(this.getAttribute("code"));  
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'oneditshapeside');
    drawlogservice.beforeupdate(shape, 'oneditshapeside', 3);
    let side = shape.sides[index];
    let w = side.w, w1 = side.w1, w2 = side.w2, h = side.h, dw = 0, dh = 0, asign = side.asign, dsign = side.dsign;
    //neww = neww * scale;   
    if (code == 0) {
        side.h = neww * scale;
        resetsideonsizechange1(index, code);
    } else if (code == 1 || code == 2) {
        if (code == 1) { dw = neww - w1; } else if (code == 2) { dw = neww - w2; }
        dw = dw * scale;
        if (index == 0) { resetsideonsizechange2(index, code, dw); } else { resetsideonsizechange3(index, code, dw); }
        for (let j = index + 1; j < shape.sides.length; j++) {
            resetsideonsizechange4(j);
        }
    } else if (code == 3) {
        side.h = neww * scale;
        resetsideonsizechange5(index, code);
    } else if (code == 4) {
        side.h = neww * scale;
        resetsideonsizechange6(index, code);
    }
    setshapesidesegs(index);
    shapesides('oneditshapeside');
    onsetsidesplashs(index);
    ActionShape('oneditshapeside');
    selectnextsideinputcontrol(sindex, index, code);
    drawlogservice.update(shape, 'oneditshapeside', 3);     
}
function resetsideonsizechange1(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side.x2 = x2, side.y2 = y2; side1.x1 = x2, side1.y1 = y2;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x22 = ipt1.dx, y22 = ipt1.dy;
            side.x22 = x22, side.y22 = y22, side1.x21 = x22, side1.y21 = y22;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function resetsideonsizechange2(index, code, dw) {
    let side = shape.sides[index];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x2, y2, x1, y1, 'resetsideonsizechange2');
    let nw = w + dw, nw1 = w1 + dw, nw2 = w2 + dw;

    let npt = rotate_point1(x2, y2, -1, angle, nw);
    x1 = npt.dx, y1 = npt.dy;
    side.x1 = x1; side.y1 = y1;

    let npt1 = rotate_point1(x12, y12, -1, angle, nw1);
    x11 = npt1.dx, y11 = npt1.dy;
    side.x11 = x11; side.y11 = y11;

    let npt2 = rotate_point1(x22, y22, -1, angle, nw2);
    x21 = npt2.dx, y21 = npt2.dy;
    side.x21 = x21; side.y21 = y21;

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;

}
function resetsideonsizechange3(index, code, dw) {
    let side = shape.sides[index];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x1, y1, x2, y2, 'resetsideonsizechange3');
    let nw = w + dw, nw1 = w1 + dw, nw2 = w2 + dw;
   // console.log(index, code, dw, nw, nw1, nw2);
    let npt = rotate_point1(x1, y1, -1, angle, nw);
    x2 = npt.dx, y2 = npt.dy;
    side.x2 = x2; side.y2 = y2;

    let npt1 = rotate_point1(x11, y11, -1, angle, nw1);
    x12 = npt1.dx, y12 = npt1.dy;
    side.x12 = x12; side.y12 = y12;

    let npt2 = rotate_point1(x21, y21, -1, angle, nw2);
    x22 = npt2.dx, y22 = npt2.dy;
    side.x22 = x22; side.y22 = y22;

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;

}
function resetsideonsizechange4(index) {
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x1, y1, x2, y2, 'resetsideonsizechange2');
    x1 = side1.x2, y1 = side1.y2, x11 = side1.x12, y11 = side1.y12, x21 = side1.x22, y21 = side1.y22;

    let npt = rotate_point1(x1, y1, -1, angle, w);
    x2 = npt.dx, y2 = npt.dy;
    side.x1 = x1, side.y1 = y1, side.x2 = x2; side.y2 = y2;

    let npt1 = rotate_point1(x11, y11, -1, angle, w1);
    x12 = npt1.dx, y12 = npt1.dy;
    side.x11 = x11, side.y11 = y11, side.x12 = x12; side.y12 = y12;

    let npt2 = rotate_point1(x21, y21, -1, angle, w2);
    x22 = npt2.dx, y22 = npt2.dy;
    side.x21 = x21, side.y21 = y21, side.x22 = x22; side.y22 = y22;

    let nw = roundToTwo(calchyplen(x1, y1, x2, y2));
    let nw1 = roundToTwo(calchyplen(x11, y11, x12, y12));
    let nw2 = roundToTwo(calchyplen(x21, y21, x22, y22));

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;
}
function resetsideonsizechange5(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side.x1 = x1, side.y1 = y1; side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side.x21 = x21, side.y21 = y21, side1.x22 = x21, side1.y22 = y21;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function resetsideonsizechange6(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index - 1], side2 = shape.sides[index + 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side.x1 = x1, side.y1 = y1; side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side.x21 = x21, side.y21 = y21, side1.x22 = x21, side1.y22 = y21;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    if (side2 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side.x2 = x2, side.y2 = y2; side2.x1 = x2, side2.y1 = y2;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x22 = ipt1.dx, y22 = ipt1.dy;
            side.x22 = x22, side.y22 = y22, side2.x21 = x22, side2.y21 = y22;
        }
        side2.w = roundToTwo(calchyplen(side2.x1, side2.y1, side2.x2, side2.y2) / scale);
        side2.w2 = roundToTwo(calchyplen(side2.x21, side2.y21, side2.x22, side2.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function shapesides(action) {
    if (!bdraw) { drawshapecorners(shape.index, 'shapesides'); }   
    drawshapesides(shape.index, 'shapesides');
    drawshapeangles();
}
function shapesideintrpoints(index) {
    let side = shape.sides[index];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    if (index > 0) { let side1 = shape.sides[index - 1]; x1 = side1.x2; y1 = side1.y2; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt.dx != 0 && ipt.dy != 0) { x2 = ipt.dx, y2 = ipt.dy; }
    }
    setsidecenterline(index, x1, y1, x2, y2);
}
function shapesideintrpoints1(index) {
    let side = shape.sides[index];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    if (index > 0) { let side1 = shape.sides[index - 1]; x11 = side1.x12; y11 = side1.y12; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x11, y11, x12, y12, side2.x11, side2.y11, side2.x12, side2.y12);
        if (ipt.dx != 0 && ipt.dy != 0) { x12 = ipt.dx, y12 = ipt.dy; }
    }
    setsideouterline1(index, x11, y11, x12, y12);
}
function shapesideintrpoints2(index) {
    let side = shape.sides[index];
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    if (index > 0) { let side1 = shape.sides[index - 1]; x21 = side1.x22; y21 = side1.y22; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt1 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) { x22 = ipt1.dx, y22 = ipt1.dy; }
    }
    setsideouterline2(index, x21, y21, x22, y22);
}

function drawshapesides(index, source) {
    if (shape.sides != null) {       
        for (let j = 0; j < shape.sides.length; j++) {           
            drawshapeside(j);
            if (shape.mode != 'slabpart') { drawsidemarkers(j); }
            drawsidesplashs(j);
            drawsideshapes(j);
            drawsidecutouts(j);
            drawsideseams(j);          
            if (shape.partsrno != undefined) { drawshapesidetext(j);}
        }
    }
}
function drawshapeside(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        if (shape.mode == 'shape') { side.spsideindex = index;}//used to seam slabparts.
        let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let w = side.w * scale, h = side.h / scale, stwidth = 15, w1 = side.w1, w2 = side.w2;
        let lncode1 = 1, lncode2 = 2;
        let edge1type = sideedgetype(index, lncode1), edge2type = sideedgetype(index, lncode2);
        let sidegindex = shape.mode + "sideg" + shape.index + index;
        let sideg = sidesg.select("#" + sidegindex);
        if (!sideg.empty()) { sideg.selectAll('*').remove(); } else { sideg = sidesg.append("g").attr("id", sidegindex); }      
        if (index == 0) { drawshapestartside(); }        
        if (w <= 16 || h <= 16) { stwidth = 5; }
        drawsideline(index, lncode1, x11, y11, x12, y12, edge1type, stwidth);
        drawsideline(index, lncode2, x21, y21, x22, y22, edge2type, stwidth);
        if (index == shape.sides.length - 1 && !bdraw) { drawshapeendside(); }        
        drawshapesidepath(index, x11, y11, x12, y12, x21, y21, x22, y22);
    }
}
function drawshapeside1(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, lncode1 = 1;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        let etype = sideedgetype(index, 1);      
        drawsideline(index, lncode1, x11, y11, x12, y12, etype, stwidth);
    }
}
function drawshapeside2(index) {
    var side = shape.sides[index];
    if (side != undefined) {
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, lncode2 = 2;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        var etype = sideedgetype(index, 2);
        drawsideline(index, lncode2, x21, y21, x22, y22, etype, stwidth);
    }
}
function drawshapestartside() {
    if (shape.sides.length > 0) {
        let index = 0;
        let side = shape.sides[index];
        let x11 = side.x11, y11 = side.y11, x21 = side.x21, y21 = side.y21, lncode = 0;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        let etype = sideedgetype(index, 0);
        drawsideline(index, lncode, x11, y11, x21, y21, etype, stwidth);
    }
    removedrawhandles();
}
function drawshapeendside() {
    if (shape.sides.length > 0) {
        let index = shape.sides.length - 1;
        let side = shape.sides[index];
        let x12 = side.x12, y12 = side.y12, x22 = side.x22, y22 = side.y22, lncode = 3;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        let etype = sideedgetype(index, 3);
        drawsideline(index, lncode, side.x12, side.y12, side.x22, side.y22, etype, stwidth);
        drawendsidecorners();
    }
    removedrawhandles();
}
function drawshapesidepath(index, x11, y11, x12, y12, x21, y21, x22, y22) {
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";  
    let sclass = 'shapepath', sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex, spsideindex = shape.spsideindex;
    //console.log(index, sindex, smode, partsrno, areaid, spindex);
    let sidepathindex = index + "" + sindex;
    let shapesidepath = shapepathg.select("#" + smode + "sidepath" + sidepathindex);
    if (shapesidepath.empty()) { shapesidepath = shapepathg.append("path").attr("id", smode + "sidepath" + sidepathindex); }
    shapesidepath.attr("index", index).attr("spsideindex", spsideindex).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("d", spath).on("click", onshape).on("contextmenu", onshapecontextmenu).on("dblclick", ondblshape);
    shapesidepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");   
}
function ondblshape() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    return;
   // console.log('ondblshape');
}
function drawsideline(index, code, x1, y1, x2, y2, edgetype, stwidth) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = sideedgeclass(edgetype);
    let sidegindex = smode + "sideg" + sindex + index;
    let sidelineindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (!sideg.empty()) {
        let sideline = sideg.select("#side" + sidelineindex);
        if (sideline.empty()) { sideline = sideg.append("line").attr("id", "side" + sidelineindex); }
        sideline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("code", code).attr("edgetype", edgetype)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        if (shape.mode == 'shape') {
            // sideline.on("click", onshapeside).on("mouseover", showshapeside).on("mouseout", hideshapeside);
            let shapebandline = sideg.select("#sideband" + sidelineindex);
            if (shapebandline.empty()) { shapebandline = sideg.append("line").attr("id", "sideband" + sidelineindex).on("click", onshapeside); }
            shapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("code", code).attr("edgetype", edgetype).attr("stwidth", stwidth)
                .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
            shapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth)
                .on("mouseover", showshapeside).on("mouseout", hideshapeside);
        }
    }
}
function drawsidemarkers(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, dh = 10;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let mtx = 0, mty = 0, mtx1 = 0, mty1 = 0, mtx2 = 0, mty2 = 0, mtext = side.w, mtext1 = side.w1, mtext2 = side.w2, h = side.h / scale;
        let lncode = 0, lncode1 = 1, lncode2 = 2, dsign = 1;
        let angle = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
        let npt1 = offsetline(x11, y11, x12, y12, dh);
        x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
        let npt2 = offsetline(x21, y21, x22, y22, -dh);
        x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;        
        mtx1 = (x11 + x12) / 2, mty1 = (y11 + y12) / 2;
        mtx2 = (x21 + x22) / 2, mty2 = (y21 + y22) / 2;
        if (index == 0) { drawsidestartendmarker(index, 0, x11, y11, x21, y21, h); }
        drawsidemarkerline(index, lncode1, x11, y11, x12, y12);
        drawsidemarkerline(index, lncode2, x21, y21, x22, y22);
        if (editmode == 1) {
            drawsideinputmarker(index, lncode1, mtx1, mty1, rounddecimal(mtext1));
            drawsideinputmarker(index, lncode2, mtx2, mty2, rounddecimal(mtext2));
        } else {
            drawsidemarkertext(index, lncode1, mtx1, mty1, decimaltofraction(mtext1), angle);
            drawsidemarkertext(index, lncode2, mtx2, mty2, decimaltofraction(mtext2), angle);
        }
        if (index == shape.sides.length - 1) { drawsidestartendmarker(index, 3, x12, y12, x22, y22, h); }
        if ((index) > 0 && (index < shape.sides.length - 1)) {
            drawsidecentermarker(index, '4', x11, y11, x12, y12, x21, y21, x22, y22, h);
        }
    }
}
function drawsidestartendmarker(index, lncode, x1, y1, x2, y2, mtext) {
    let mtx = 0, mty = 0, mtx1 = 0, mty1 = 0, mtx2 = 0, mty2 = 0, dh = 10;   
    if (lncode == 0) { dh = -dh;}
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let angle = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
    mtx1 = (x1 + x2) / 2, mty1 = (y1 + y2) / 2;

    drawsidemarkerline(index, lncode, x1, y1, x2, y2);
    if (editmode == 1) {
        drawsideinputmarker(index, lncode, mtx1, mty1, rounddecimal(mtext));
    } else {
        drawsidemarkertext(index, lncode, mtx1, mty1, decimaltofraction(mtext), angle);
    }
}
function drawsidecentermarker(index, lncode, x11, y11, x12, y12, x21, y21, x22, y22, mtext) {
    let side = shape.sides[index], w1 = side.w1 * scale, w2 = side.w2 * scale;
    let mx1 = 0, my1 = 0, mx2 = 0, my2 = 0, mtx = 0, mty = 0;

    let angle = calclineangle2(x11, y11, x12, y12, 'calcshapeangle');    
    let npt1 = rotate_point1(x11, y11, -1, angle, w1/2); //first point on side
    mx1 = npt1.dx, my1 = npt1.dy;
    let npt2 = rotate_point1(x21, y21, -1, angle, w2/2); //first point on side
    mx2 = npt2.dx, my2 = npt2.dy;

    let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, mx1, my1);
    mx2 = npt3.dx, my2 = npt3.dy;
    
    mtx = (mx1 + mx2) / 2, mty = (my1 + my2) / 2;
    drawsidemarkerline(index, lncode, mx1, my1, mx2, my2);
    if (editmode == 1) {
        drawsideinputmarker(index, lncode, mtx, mty, rounddecimal(mtext));
    } else {
        drawsidemarkertext(index, lncode, mtx, mty, decimaltofraction(mtext));
    }    
}
function drawsidemarkerline(index, code, x1, y1, x2, y2) {    
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let mindex = shape.index + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (sideg.empty()) { sideg = sidesg.append("g").attr("id", sidegindex); }
    let markerline = sideg.select("#mline" + mindex);
    if (markerline.empty()) { markerline = sideg.append("line").attr("id", "mline" + mindex); }
    let arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    let arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("class", "sidearrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
}
function drawsidemarkertext(index, code, mtx, mty, mtext, angle) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etype = sideedgetext(index, code);
    let sidegindex =  smode + "sideg" + sindex + index;
    let mindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);   
    if (!sideg.empty()) {
        let markertext = sideg.select("#mtext" + mindex);
        if (!markertext.empty()) { markertext.remove(); }
        markertext = sideg.append("text").attr("id", "mtext" + mindex);
        markertext.attr("x", mtx).attr("y", mty).attr("index", index).attr("code", code)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        markertext.attr("x", mtx).attr("y", mty).append("tspan").attr("id", "mtextspan1" + mindex).style("fill", "black").text(mtext);
        if (etype.length > 0) { markertext.append("tspan").attr("id", "mtextspan2" + mindex).style("fill", "goldenrod").text(" | " + etype); }
        if (smode == 'shape') { markertext.on("click", onsidemarkertext); }
        let angseg = Math.floor(angle / 180);
        let angle1 = angle - (angseg * 180);
        if (angle1 > 90) { angle1 = angle1 + 180; }
        if (angle1 > 0) { markertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")"); }
    }
}
function updatesidemarkertext(index, code, mtext) {
    let etype = sideedgetext(index, code);
    let sindex = this.getAttribute("sindex");
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let mindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (!sideg.empty()) {
        var markertext = sideg.select("#mtext" + mindex);
        if (!markertext.empty()) {
            var mtx = markertext.getAttribute("x");
            var mty = markertext.getAttribute("y");
            var mtexttspan = markertext.select("#mtextspan1" + mindex);
            var mtext = mtexttspan.text();
            drawsidemarkertext(index, code, mtx, mty, mtext);
        }
    }
}
function onsidemarkertext() {
    if (bdraw) { onendshapedraw(); }
    if (editmode == 1) { editmode = 0; drawshapesides(shape.index, 'onsidemarkertext-1'); } //check drawshapesides() called twice??
    let index = parseInt(this.getAttribute("index"));
    let code = this.getAttribute("code");    
    let type = this.getAttribute("stype");
    let mode = this.getAttribute("smode");
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onsidemarkertext');
    editmode = 1;
    drawshapesides(sindex, 'onsidemarkertext-2');
    selectsideinputcontrol(sindex, index, code);
}
function drawsideinputmarker(index, code, mtx, mty, mtext) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let sidegindex = smode + "sideg" + sindex + index;
    let mindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);    
    if (!sideg.empty()) {
        var markertext = sideg.select("#mfotext" + mindex);
        if (markertext.empty()) { markertext = sideg.append("foreignObject").attr("id", "mfotext" + mindex); }
        markertext.attr("x", mtx).attr("y", mty).attr("width", "60").attr("height", "30");
        var markerinputtext = markertext.select("#mitext" + mindex);
        if (markerinputtext.empty()) { markerinputtext = markertext.append('xhtml:input').attr("id", "mitext" + mindex); }
        markerinputtext.attr("style", "padding-left:5px;width:60px;height:20px;").attr("type", "text").property("value", mtext).attr("index", index).attr("code", code)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
            .on("change", oneditshapeside).on("keydown", oneditsidekeydown).on("click", onsideinputcontrol);
    }
}
function oneditsidekeydown() {
    var keycode = d3.event.keyCode;
    var inputctl;
    if (keycode == 9) {
        d3.event.preventDefault();
        var index = parseInt(this.getAttribute("index"));
        var code = parseInt(this.getAttribute("code"));        
        var sindex = parseInt(this.getAttribute("sindex"));
        selectnextsideinputcontrol(sindex, index, code);
    }
    if (bdraw) { onendshapedraw(); }
}

function onsideinputcontrol() {
    var index = parseInt(this.getAttribute("index"));
    var code = parseInt(this.getAttribute("code"));    
    var sindex = parseInt(this.getAttribute("sindex"));
    selectsideinputcontrol(sindex, index, code);
    if (bdraw) { onendshapedraw(); }
}
function selectnextsideinputcontrol(sindex, index, code) {
    var index1 = 0, code1 = 0;
    if (code == 0) {index1 = index, code1 = 1;
    } else if (code == 1) {
        if (index < shape.sides.length - 1) {
            if ((index) > 0 && (index < shape.sides.length - 1)) {
                index1 = index, code1 = 4;
            } else {
                index1 = index + 1, code1 = code;
            }
        } else if (index == shape.sides.length - 1) { index1 = index, code1 = 3; }
    } else if (code == 2) {
        if (index > 0) {
            index1 = index - 1, code1 = code;
        }else if (index == 0) {
            index1 = index, code1 = 0;
        }
    } else if (code == 3) {
        index1 = index, code1 = 2;
    } else if (code == 4) {
        index1 = index + 1, code1 = 1;
    }
    selectsideinputcontrol(sindex, index1, code1);
}
function selectsideinputcontrol(sindex, index, code) {
    let mindex = sindex + "" + index + "" + code;
    inputctl = $("#mitext" + mindex);
    if (inputctl != undefined) {
        inputctl.focus();
        inputctl.select();
    }
}

function showshapeside() {
    if (drawmode == 3 || drawmode == 4 || drawmode == 5 || drawmode == 8) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
        d3.select(this).attr("class", "shapesideblue");
    } else if (drawmode == 1) {
       
    }
}
function hideshapeside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));  
    if (drawmode == 3 || drawmode == 4 || drawmode == 5 || drawmode == 8) {//splash/edge mode
        let edgetype = this.getAttribute("edgetype");
        let scolor = d3.select(this).attr('scolor');
        d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
        d3.select(this).attr("class", sideedgeclass(edgetype));
    }
}
function removeshapesclipimages() {
    for (let i = 0; i < shapes.length; i++) {        
        removeshapeclipimages(i);
    }
}
function setshapesopacity(fillopacity) {
    for (let i = 0; i < shapes.length; i++) {
        setshapepathopacity(i, fillopacity);       
    }
}
function removeshapeclipimages(sindex) {
    let shapeslabimagesg = d3.select("#shapeslabimgsg" + sindex);
    if (!shapeslabimagesg.empty()) { shapeslabimagesg.selectAll('*').remove(); }
}
function setshapepathopacity(sindex, fillopacity) {    
    if (shapes[sindex] != undefined) {
        for (let i = 0; i < shapes[sindex].sides.length; i++) {
            let sidepathindex = i + "" + sindex;
            let shapesidepath = d3.select("#shape" + "sidepath" + sidepathindex);
            if (!shapesidepath.empty()) { shapesidepath.style("fill-opacity", fillopacity); }
        }
    }
}
