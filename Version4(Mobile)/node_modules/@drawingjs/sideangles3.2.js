function calcshapeangle(index) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12;
    let x3 = side1.x11, y3 = side1.y11, x4 = side1.x12, y4 = side1.y12;
    let angle=0, angle1 = 0, angle2 = 0;
    angle1 = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
    angle2 = calclineangle2(x3, y3, x4, y4, 'calcshapeangle');   
    angle = Math.abs(angle1 - angle2);    
    let angseg = parseFloat(angle / 22.5).toFixed(1);
    angseg = (angseg - Math.floor(angseg)) > 0.5 ? Math.round(angseg) : Math.floor(angseg);
    angle = angseg * 22.5;
    if (angle > 90 && angle < 180) { angle = angle - 90; } else if (angle == 180) { angle = 0; }
    else if (angle > 180 && angle <= 270) { angle = angle - 180; } else if (angle > 270 && angle < 360) { angle = 360 - angle; }
    angseg = parseFloat(angle / 22.5).toFixed(1);
    angseg = (angseg - Math.floor(angseg)) > 0.5 ? Math.round(angseg) : Math.floor(angseg);
    angle = angseg * 22.5;
   // console.log(index, angle1, angle2, angle);
    return angle;
}
function onshapeangle() {
    if (bdraw) { onendshapedraw(); }
    removeanglehandles();
    d3.event.preventDefault();
    if (editmode == 1) { editmode = 0; drawshapesides(); }
    let mode = this.getAttribute("smode");   
    let m = d3.mouse(this);
    let index = parseInt(this.getAttribute("index"));
    let dsign = parseInt(this.getAttribute("dsign"));
    let cangle = parseInt(this.getAttribute("cangle"));    
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    if (shape.mode == 'slabpart') {
        onsetslabpartshape31(sindex, spindex, partsrno, areaid, 'onshapeangle');
        if (drawmode == 7) { if (seamtype == 2) { onsetsideseam31(m[0], m[1], -1, index, sindex, seamtype, 'onshapeangle'); } }
        setdrawmode(0);
    } else {
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapeangle');
        if (mode == 'shape') { drawcorneranglehandles(index); }
    }    
}
function drawcorneranglehandles(index) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2, cw = 72;

    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;

    let angle1 = 0, angle2 = 0;
    angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    let hangle1 = 0, hangle2 = 0;
    if (angle1 >= 180) { hangle1 = angle1 - 180; } else { hangle1 = angle1 + 180; }
    if (angle2 >= 180) { hangle2 = angle2 - 180; } else { hangle2 = angle2 + 180; }
   // console.log(hangle1, hangle2, angle1, angle2);
    for (let i = 0; i < 16; i++) {
        let hangle = i * 22.5;
        if (hangle != hangle1 && hangle != hangle2) {
          //  console.log(hangle, hangle1, hangle2, angle1,angle2);
            let npt1 = rotate_point1(cx, cy, -1, hangle, cw);
            let hx2 = npt1.dx, hy2 = npt1.dy;
            drawshapeanglehandle(index, cx, cy, hx2, hy2, hangle, 2);
        }
    }

    let npt1 = rotate_point1(cx, cy, -1, angle1, cw);
    let hx1 = npt1.dx, hy1 = npt1.dy;
    drawshapeanglehandle2(index, cx, cy, hx1, hy1, angle1, 1);

    npt1 = rotate_point1(cx, cy, -1, angle2, cw);
    hx1 = npt1.dx, hy1 = npt1.dy;
    drawshapeanglehandle2(index, cx, cy, hx1, hy1, angle2, 2);
}
function onshapeanglehandle(index, sindex, angle, atype) {
    let source='onshapeanglehandle';
    drawlogservice.beforeupdate(shape, source, 8);
    if (angle == 360) { angle = 0; }
    let changetype = 1, sideindex = 0;
    if (shape.sides[0].w1 < shape.sides[0].w2) { changetype = 2; }    
    if (atype == 1) {
        sideindex = index;
        let side = shape.sides[sideindex];
        let angle1 = calclineangle2(side.x2, side.y2, side.x1, side.y1, source);
        let anglediff = angle - angle1; 
        for (let i = index; i >= 0; i--) {
            //console.log(index, angle1, angle, anglediff, shape.sides[0].w1, shape.sides[0].w2);
            if (shape.sides[i].w1 >= shape.sides[i].w2) { onshapeanglehandle1(i, sideindex, angle, anglediff); } else { onshapeanglehandle3(i, sideindex, angle, anglediff); }
        }      
    } else if (atype == 2) {
        sideindex = index + 1;
        let side = shape.sides[sideindex];
        let angle1 = calclineangle2(side.x1, side.y1, side.x2, side.y2, source);
        let anglediff = angle - angle1;              
        for (let i = sideindex; i < shape.sides.length; i++) {
            //console.log(index, angle1, angle, anglediff, shape.sides[0].w1, shape.sides[0].w2);
            if (shape.sides[i].w1 >= shape.sides[i].w2) { onshapeanglehandle2(i, sideindex, angle, anglediff); } else { onshapeanglehandle4(i, sideindex, angle, anglediff); }           
        }       
    }
    resetshapecorners(source);
    resetsideshapes(index, source);
    ressetshapesidesegs(source);
    resetshapecutouts(source);
    resetshapesplashs(source);
    shapesides(source);
    removeanglehandles(source);
    drawcorneranglehandles(index, source);
    drawlogservice.update(shape, source, 8);
    
}
function onshapeanglehandle1(index, sideindex, angle, anglediff) {
    let source = 'onshapeanglehandle1';
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, h =  side.h;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, w1 = applymminchfact(side.w1, 1, 2, source);
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    
    let angle1 = calclineangle2(x2, y2, x1, y1, source);
  
    if (index == sideindex) { angle1 = angle; } else { angle1 += anglediff; }
  //  console.log(index, angle1, angle, anglediff);
    if (side1 != undefined) { x12 = side1.x11, y12 = side1.y11;}
    // console.log(index, sideindex, angle);
    let npt = rotate_point1(x12, y12, -1, angle1, w1);
    x11 = npt.dx, y11 = npt.dy;
    let npt1 = offsetline(x11, y11, x12, y12, -h /2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let npt2 = offsetline(x11, y11, x12, y12, -h);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
           x2 = ipt.dx, y2 = ipt.dy;
           side1.x1 = x2, side1.y1 = y2;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt.dy != 0) {
           x22 = ipt1.dx, y22 = ipt1.dy;
           side1.x21 = x22, side1.y21 = y22;
        }
    }   
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;

    side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
    side.w2 = applymminchfact(calchyplen(x21, y21, x22, y22), 2, 2, source);
    if (side1 != undefined) {
        side1.w = applymminchfact(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2), 2, 2, source);
        side1.w2 = applymminchfact(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22), 2, 2, source);
    }
}
function onshapeanglehandle2(index, sideindex, angle, anglediff) {
    let source = 'onshapeanglehandle2';
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, h = side.h;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, w1 = applymminchfact(side.w1, 1, 2, source);
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle1 = calclineangle2(x1, y1, x2, y2, source); 
    if (index == sideindex) { angle1 = angle; } else { angle1 += anglediff; }
    //console.log(index, angle1, angle, anglediff);
    if (side1 != undefined) {x11 = side1.x12, y11 = side1.y12;}
   // console.log(index, sideindex, angle);
    let npt = rotate_point1(x11, y11, -1, angle1, w1);
    x12 = npt.dx, y12 = npt.dy;
    let npt1 = offsetline(x11, y11, x12, y12, -h / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let npt2 = offsetline(x11, y11, x12, y12, -h);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side1.x22 = x21, side1.y22 = y21;
        }
    }  
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
  
    side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
    side.w2 = applymminchfact(calchyplen(x21, y21, x22, y22), 2, 2, source);
    if (side1 != undefined) {
        side1.w = applymminchfact(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2), 2, 2, source);
        side1.w2 = applymminchfact(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22), 2, 2, source);
    }
}
function onshapeanglehandle3(index, sideindex, angle, anglediff) {
    let source = 'onshapeanglehandle3';
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, h = side.h;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w2 = applymminchfact(side.w2, 1, 2, source);

    let angle1 = calclineangle2(x2, y2, x1, y1, source);

    if (index == sideindex) { angle1 = angle; } else { angle1 += anglediff; }
    //  console.log(index, angle1, angle, anglediff);
    if (side1 != undefined) { x22 = side1.x21, y22 = side1.y21;}
    // console.log(index, sideindex, angle);
    let npt = rotate_point1(x22, y22, -1, angle1, w2);
    x21 = npt.dx, y21 = npt.dy;
    let npt1 = offsetline(x21, y21, x22, y22, h / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let npt2 = offsetline(x21, y21, x22, y22, h);
    x11 = npt2.dx1, y11 = npt2.dy1, x12 = npt2.dx2, y12 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side1.x1 = x2, side1.y1 = y2;
        }
        let ipt1 = calintersection1(x11, y11, x12, y12, side1.x11, side1.y11, side1.x12, side1.y12);
        if (ipt1.dx != 0 && ipt.dy != 0) {
            x12 = ipt1.dx, y12 = ipt1.dy;
            side1.x11 = x12, side1.y11 = y12;
        }
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;

    side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
    side.w1 = applymminchfact(calchyplen(x11, y11, x12, y12), 2, 2, source);
    if (side1 != undefined) {
        side1.w = applymminchfact(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2), 2, 2, source);
        side1.w1 = applymminchfact(calchyplen(side1.x11, side1.y11, side1.x12, side1.y12), 2, 2, source);
    }
}
function onshapeanglehandle4(index, sideindex, angle, anglediff) {
    let source = 'onshapeanglehandle4';
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, h = side.h;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w2 = applymminchfact(side.w2, 1, 2, source);

    let angle1 = calclineangle2(x1, y1, x2, y2, source);
    if (index == sideindex) { angle1 = angle; } else { angle1 += anglediff; }
    //console.log(index, angle1, angle, anglediff, side.w1, side.w2);
    if (side1 != undefined) { x21 = side1.x22, y21 = side1.y22; }
    // console.log(index, sideindex, angle);
    let npt = rotate_point1(x21, y21, -1, angle1, w2);
    x22 = npt.dx, y22 = npt.dy;
    let npt1 = offsetline(x21, y21, x22, y22, h / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let npt2 = offsetline(x21, y21, x22, y22, h);
    x11 = npt2.dx1, y11 = npt2.dy1, x12 = npt2.dx2, y12 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x11, y11, x12, y12, side1.x11, side1.y11, side1.x12, side1.y12);
        if (ipt1.dx != 0 && ipt.dy != 0) {
            x11 = ipt1.dx, y11 = ipt1.dy;
            side1.x12 = x11, side1.y12 = y11;
        }
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;

    side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
    side.w1 = applymminchfact(calchyplen(x11, y11, x12, y12), 2, 2, source);
    //console.log(index, angle1, angle, anglediff, side.w1, side.w2);
    if (side1 != undefined) {
        side1.w = applymminchfact(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2), 2, 2, source);
        side1.w1 = applymminchfact(calchyplen(side1.x11, side1.y11, side1.x12, side1.y12), 2, 2, source);
    }
}
function drawshapeangles() {
    if (shape.sides != null) {      
        for (let j = 0; j < shape.sides.length - 1; j++) {
            drawshapeangle(j);
        }
    }
}
function drawshapeangle(index) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let side = shape.sides[index];
    let cx = side.x2, cy = side.y2, cr = 24;
    let cangle = calcshapeangle(index);
    let caclass = 'shapesplash';
    let shapepathg = shapeg.select("#" + smode + "pathg" + index);
    if (shapepathg.empty()) { shapepathg = shapeg.append("g").attr("id", smode + "pathg" + index); }
    canglecircle = shapepathg.select("#canglecircle" + index);
    if (canglecircle.empty()) {canglecircle = shapepathg.append("circle").attr("id", "canglecircle" + index); }
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr).attr("class", caclass).attr("index", index)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode != 'slabpartdg') { canglecircle.on("click", onshapeangle); }
    let cangletext = shapepathg.select("#cangletext" + sindex + "" + index);
    if (cangletext.empty()) { cangletext = shapepathg.append("text").attr("id", "cangletext" + sindex + "" + index); }
    cx = cx - 7; cy = cy + 5;
    cangletext.attr("x", cx).attr("y", cy).text(cangle).attr("index", index)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode != 'slabpartdg') { canglecircle.on("click", onshapeangle); }
    let angle1 = shape.angle;
    // console.log(index, code, mtx, mty, mtext, angle, angle1);
    cangletext.attr("transform", "rotate(" + -angle1 + "," + [cx, cy] + ")");
}
function drawshapeanglehandle(index, x1, y1, x2, y2, angle, atype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let hindex = index + angle.toFixed() + atype;
    let canglehandle = anglehandlesg.select("#canglehandle" + hindex);
    if (canglehandle.empty()) { canglehandle = anglehandlesg.append("line").attr("id", "canglehandle" + hindex); }
    canglehandle.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("marker-end", "url(#circle-end)").attr("class", "shapeside");
    let canglehandlecircle = anglehandlesg.select("#canglehandlecircle" + hindex);
    if (canglehandlecircle.empty()) { canglehandlecircle = anglehandlesg.append("circle").attr("id", "canglehandlecircle" + hindex); }
    canglehandlecircle.attr("cx", x2).attr("cy", y2).attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("r", 8).attr("cindex", index).attr("sindex", sindex)
    .attr("smode", smode).attr("angle", angle).attr("atype", atype).attr("style", "fill:gray").style("stroke-opacity", "0.2");
}
function drawshapeanglehandle2(index, x1, y1, x2, y2, angle, atype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let hindex = index + atype;
    let canglehandle = anglehandlesg.select("#canglehandledrag" + hindex);
    if (canglehandle.empty()) { canglehandle = anglehandlesg.append("line").attr("id", "canglehandledrag" + hindex); }
    canglehandle.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", smode).attr("marker-end", "url(#circle-end)").attr("class", "shapeside");
    let canglehandlecircle = anglehandlesg.select("#canglehandledragcircle" + hindex);
    if (canglehandlecircle.empty()) { canglehandlecircle = anglehandlesg.append("circle").attr("id", "canglehandledragcircle" + hindex); }
    canglehandlecircle.attr("cx", x2).attr("cy", y2).attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("r", 8).attr("cindex", index)
        .attr("class", "arrowcircle").attr("angle", angle).attr("atype", atype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).call(anglehandledrag);
}
function anglehandledragstarted() {
    let index = parseInt(this.getAttribute("cindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let atype = parseInt(this.getAttribute("atype"));
    let quardrant = parseInt(this.getAttribute("quardrant"));   
    let mode = this.getAttribute("smode");
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));   
    if (mode == 'shape') {setdrawshape31(sindex, partsrno, areaid, mode, 'onsidemarkertext'); bdrag = true; }
}
function anglehandledragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("cindex"));
        let atype = parseInt(this.getAttribute("atype"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let x1 = parseInt(this.getAttribute("x1"));
        let y1 = parseInt(this.getAttribute("y1"));
        let x2 = parseInt(this.getAttribute("x2"));
        let y2 = parseInt(this.getAttribute("y2"));
        let nx2 = d3.event.x;
        let ny2 = d3.event.y;
        let angle = calclineangle2(x1, y1, nx2, ny2, 'anglehandledragged');
        // onshapeanglehandle(index, sindex, x1, y1, nx2, ny2, angle, atype);
        drawshapeanglehandle2(index, x1, y1, nx2, ny2, angle, atype);
    }
}
function anglehandledragended() {
    if (bdrag) {
        bdrag = false;
        let index = parseInt(this.getAttribute("cindex"));
        let atype = parseInt(this.getAttribute("atype"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let x1 = parseInt(this.getAttribute("x1"));
        let y1 = parseInt(this.getAttribute("y1"));
        let x2 = parseInt(this.getAttribute("x2"));
        let y2 = parseInt(this.getAttribute("y2"));
        let nx2 = d3.event.x;
        let ny2 = d3.event.y;
        let angle = calclineangle2(x1, y1, nx2, ny2, 'anglehandledragged');
        let angseg = parseFloat(angle / 22.5).toFixed(1);
        angseg = (angseg - Math.floor(angseg)) > 0.5 ? Math.round(angseg) : Math.floor(angseg);
        let angle1 = angseg * 22.5;
        angle1 = checkanglediff(index, angle1, atype);
        onshapeanglehandle(index, sindex, angle1, atype);
        drawcorneranglehandles(index);
        ActionShape('anglehandledragended');
    }
}
function checkanglediff(index, angle, atype) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2;

    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;
    let angle3 = 0;
    let angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    let angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    let hangle = 0, hangle1 = 0, hangle2 = 0, minangle = 0, maxangle = 0;
    if (angle1 >= 180) { hangle1 = angle1 - 180; } else { hangle1 = angle1 + 180; }
    if (angle2 >= 180) { hangle2 = angle2 - 180; } else { hangle2 = angle2 + 180; }
    if (angle != hangle1 && angle != hangle2) { hangle = angle; } else { hangle = angle + 22.5; }
    if (atype == 1) {
        hangle1 = angle2 - 90, hangle2 = angle2 + 90;
        if (hangle1 > 360) { hangle1 =  Math.abs(hangle1 - 360); } if (hangle2 > 360) { hangle2 = Math.abs(hangle2 - 360); }
        minangle = Math.min(hangle1, hangle2), maxangle = Math.max(hangle1, hangle2);
        if (minangle < angle && angle < maxangle) { hangle = angle1; } else { hangle = angle; }
       // console.log(atype, hangle1, hangle2, minangle, maxangle, hangle, angle, angle1, angle2);
    } else {
        hangle1 = angle1 - 90, hangle2 = angle1 + 90;
        if (hangle1 > 360) { hangle1 = Math.abs(hangle1 - 360); } if (hangle2 > 360) { hangle2 = Math.abs(hangle2 - 360); }
        minangle = Math.min(hangle1, hangle2), maxangle = Math.max(hangle1, hangle2);
        if (minangle < angle && angle < maxangle) { hangle = angle2; } else { hangle = angle;}
     //   console.log(atype, hangle1, hangle2, minangle, maxangle, hangle, angle, angle1, angle2);
    }  
    return hangle;
}
function checkanglediff1(index, angle, atype) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2;
   
    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;
    let angle1 = 0, angle2 = 0, angle3 = 0;
    angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    angle3 = Math.abs(angle1 - angle2);
    if (angle > 90 && angle < 180) { angle = angle - 90; } else if (angle == 180) { angle = 0; }
    else if (angle > 180 && angle <= 270) { angle = angle - 180; } else if (angle > 270 && angle < 360) { angle = 360 - angle; }
    let angseg = parseFloat(angle / 22.5).toFixed(1);
    angseg = (angseg - Math.floor(angseg)) > 0.5 ? Math.round(angseg) : Math.floor(angseg);

    angle = angseg * 22.5;
    return hangle;
}