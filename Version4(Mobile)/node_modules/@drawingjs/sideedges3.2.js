function initsideedge(index, sideindex, code, type, typeid, text) {   
    let edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function initsplashedge(index, sideindex, code, type, typeid, text) {
    let edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function sideedgeindex1(side, code) {
    var edgeindex = -1;// rect shape 1 side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    if (side != undefined) {
        for (var i = 0; i < side.edges.length; i++) { if (side.edges[i].code == code) { edgeindex = i; break; } }
    }
    return edgeindex;
}
function sideedgeindex(sideindex, code) {
    var edgeindex = -1;// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { edgeindex = i; break; } }
    return edgeindex;
}
function sideedgetype(sideindex, code) {
    var etype = linetxt;// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { etype = shape.sides[sideindex].edges[i].type; break; } }
    return etype;
}
function sideedgetext(sideindex, code) {
    let etype = '';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (let i = 0; i < shape.sides[sideindex].edges.length; i++) {
        if (shape.sides[sideindex].edges[i].code == code) {
            if (shape.sides[sideindex].edges[i].typeid != 0) {
                etype = shape.sides[sideindex].edges[i].type;
                if (etype != '' && etype != null) { let types = etype.split(':'); etype = types[0]; }
            }
            break;
        }
    }
    return etype;
}
function sideedgetext1(sideindex, code) {
    let etype = '';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (let i = 0; i < shape.sides[sideindex].edges.length; i++) {
        if (shape.sides[sideindex].edges[i].code == code) {
            if (shape.sides[sideindex].edges[i].typeid != 0) {
                etype = shape.sides[sideindex].edges[i].type;
                if (etype != '' && etype != null) { let types = etype.split(':'); etype = types[0]; }
            } else {
                etype = shape.sides[sideindex].edges[i].type;
            }
            break;
        }
    }
    return etype;
}
function setsideedges(index, edgetype, source) {
    source += ':setsideedges';
    if (index == 0) { setsideedge(index, 0, edgetype, 0, source); }
    setsideedge(index, 1, edgetype, 0, source);
    setsideedge(index, 2, edgetype, 0, source);
}
function setsideedge(sideindex, code, type, typeid, source) {
    //console.log("sideindex:" + sideindex, "code:" + code, "type:" + type, "typeid:" + typeid, source);
    let side = shape.sides[sideindex], w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
    if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }    
    let edgeindex = sideedgeindex(sideindex, code);  
    if (edgeindex == -1) { side.edges.push(initsideedge(code, sideindex, code, type, typeid, type)); edgeindex = side.edges.length - 1; }  
    let edge = side.edges[edgeindex];    
    edge.type = type, edge.typeid = typeid, edge.code = code, edge.text = type, edge.sideindex = side.index, edge.width = sidesegswidth(sideindex, code);
    if (shapetype != 0 && edge.width == 0) { edge.width = w; }//default shapes
}
function setsideedge1(index, code, type, typeid, source) {
    source += ':setsideedge1';
    setsideedge(index, code, type, typeid, source);
   // console.log(index, code, type, typeid);
    drawshapeside32(index, source);
}
function onsetsideedge(index, code, type, typeid, source) {
    source += ':onsetsideedge';   
    setsideedge(index, code, type, typeid, source);
    setsideshapesedges(index, code, type, typeid);
    drawshapeside32(index, source);
    //ondeleteshapesidesplash1(-1, index, code);
    ActionEdge(index);    
}
function onsetsideedge2(side, code, type, typeid) {
    if (side != undefined) {
        w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
        let edgeindex = sideedgeindex1(side, code);
        if (edgeindex == -1) { side.edges.push(initsideedge(code, sideindex, code, type, typeid, type)); edgeindex = side.edges.length - 1; }
        let edge = side.edges[edgeindex];
        if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }
        edge.type = type, edge.typeid = typeid, edge.code = code, edge.text = type, edge.sideindex = side.index, edge.width = sidesegswidth(sideindex, code);
        if (shapetype != 0 && edge.width == 0) { edge.width = w; }//default shapes
    }
}
function resetshapesideedgeswidth34(source) {
    for (let i = 0; i < shape.sides.length; i++) {
        setsideedgeswidth(i);
    }
}
function setsideedgeswidth(index) {
    let side = shape.sides[index];
    if (side.index == 0) { setsideedgewidth(side, 0); }
    setsideedgewidth(side, 1);
    setsideedgewidth(side, 2);
    if (side.index == shape.sides.length -1) { setsideedgewidth(side, 3); }
}
function setsideedgewidth(side, code) {
    let w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
    let edgeindex = sideedgeindex1(side, code);
    let edge = side.edges[edgeindex];
    if (edge != undefined) {
        if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }
      //  console.log(w, code, w1, w2, h, edgeindex);
        edge.width = sidesegswidth(side.index, code);
        if (shapetype != 0 && edge.width == 0) { edge.width = w; }//default shapes
    }
}
function sidesplashedges(splash, sidecode, source) {
    let edge1type = linetxt, edge2type = 'U', edge3type = linetxt, edge4type = linetxt;   
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 0, edge1type, 0, edge1type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 1, edge2type, 0, edge2type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 2, edge3type, 0, edge3type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 3, edge4type, 0, edge4type));
}
function onsetsplashsideedge(index, splashindex, sideindex, sidecode) {
    let source = 'onsetsplashsideedge';  
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let spledge = splash.edges[index];
    spledge.type = edgetype, spledge.typeid = edgetypeid, spledge.text = edgetype;
    setsidesplashedgeswidth(splash);
    drawsidesplash(splashindex, sideindex, source);
    ActionSplash(source);  
}
function setsidesplashedgeswidth(splash) {
    setsidesplashedgewidth(splash, 0);
    setsidesplashedgewidth(splash, 1);
    setsidesplashedgewidth(splash, 2);
    setsidesplashedgewidth(splash, 3);
}
function setsidesplashedgewidth(splash, code) {
    let w = splash.width, h= splash.height;    
    let edge = splash.edges[code];  
    if (edge != undefined) {
        if (code == 0 || code == 3) { w = h; }
        edge.width = w;
    }   
}
function sideedgeclass(type) {
    let eclass = colorflag == 1 ? 'shapeside' : 'shapeside1';
    if (type == 'A') {
        eclass = 'shapesidepurple';
    } else if (type == 'U') {
        eclass = 'shapesidered';
    } else if (type == 'S') {
        eclass = 'shapesidered';
    } else if (type == 'E' || type == 'M') {
        eclass = colorflag == 0 ? 'shapesideblue1' : 'shapesideorange';
    } else if (type == 'C') {
        eclass = 'shapeseam';
    } else if (type == 'F') {
        //eclass = 'shapeside';
    } else if (type == 'W') {
        eclass = 'shapesidewhite';
    } else {
        eclass = 'shapesideblack';
    }
    return eclass;
}
function sideedgecolor32(type) {
    let ecolor = 'blue';
    if (type == 'A') {
        ecolor = 'purple';
    } else if (type == 'U') {
        ecolor = 'red';
    } else if (type == 'S') {
        ecolor = 'red';
    } else if (type == 'E' || type == 'M') {
        ecolor = 'orange';
    } else if (type == 'C') {
        ecolor = 'red';
    } else if (type == 'F') {
        ecolor = 'blue';
    } else if (type == 'W') {
        ecolor = 'white';
    } else {
        ecolor = 'lightblue';
    }
    return ecolor;
}