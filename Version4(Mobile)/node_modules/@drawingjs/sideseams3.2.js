function initsideseam(x, y, sideindex, type) {
    let side = shape.sides[sideindex];
    let seam = {}; index = side.seams.length;
    seam.index = index, seam.type = type, seam.sideindex = sideindex, seam.spsideindex = side.spsideindex, seam.spseamindex = index,
    seam.x = x, seam.y = y, seam.w = 0, seam.h = 0, seam.x1 = 0, seam.y1 = 0, seam.x2 = 0, seam.y2 = 0, seam.sx1 = 0, seam.sy1 = 0, seam.sx2 = 0, seam.sy2 = 0,
    seam.sx = 0, seam.sy = 0, seam.split = 0, seam.isactive = 1;
    //console.log(JSON.stringify(seam));
    side.seams.push(seam);
}
function setsideseam31(x, y, index, sideindex, type, source) {    
    let side = shape.sides[sideindex];
    if (index == -1) { index = side.seams.length, initsideseam(x, y, sideindex, type); }    
    let seam = side.seams[index];
    if (x > 0 && y > 0) { seam.x = x, seam.y = y; }
    //1 - Vertical seam, 2- Corner, 3- Horizontal
    //console.log(x, y, index, sideindex, type, source)
    if (type == 1) { setshapesideseam1(index, sideindex); applyseamtosideshapes31(index, sideindex, source); }
    else if (type == 2) { setshapesideseam2(index, sideindex); applyseamtocornershapes32(index, sideindex, sideindex + 1,  source); }
    else if (type == 3) { setshapesideseam3(index, sideindex); applyseamtosideshapes33(index, sideindex, source); }
    return index;
}
function setshapesideseam1(index, sideindex) {
    let side = shape.sides[sideindex];
    let seam = side.seams[index];
    if (seam != undefined) {
        let smtype = seam.type, x = seam.x, y = seam.y, h = seam.h, x1 = 0, y1 = 0, x2 = 0, y2 = 0, sw = 0;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let npt1 = calcverticalvectorpoint(x11, y11, x12, y12, x, y);
        x1 = npt1.dx, y1 = npt1.dy;
        let ipt = calcverticalvectorpoint(x21, y21, x22, y22, x1, y1);
        x2 = ipt.dx, y2 = ipt.dy;
        sw = applymminchfact1(calchyplen(x11, y11, x1, y1), 2, 2, 'setshapesideseam1');
        //console.log(index, sideindex, sw, smtype, x11, y11, x1, y1, calchyplen(x11, y11, x1, y1));
        seam.x1 = x1, seam.y1 = y1, seam.x2 = x2, seam.y2 = y2, seam.sw = sw;
        seam.sx1 = x1, seam.sy1 = y1, seam.sx2 = x2, seam.sy2 = y2;        
    }
}
function setshapesideseam2(index, sideindex) {
    let side = shape.sides[sideindex];
    if (index == -1) { index = side.seams.length, initsideseam(x, y, sideindex, type); }
    let seam = side.seams[index];
    if (seam != undefined) {
        let smtype = seam.type, x = seam.x, y = seam.y, h = seam.h, x1 = 0, y1 = 0, x2 = 0, y2 = 0, sw = 0;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        x1 = x12, y1 = y12, x2 = x22, y2 = y22;
        sw = applymminchfact1(calchyplen(x11, y11, x1, y1), 2, 2, 'setshapesideseam2');
        seam.x1 = x1, seam.y1 = y1, seam.x2 = x2, seam.y2 = y2, seam.sw = sw;
        seam.sx1 = x1, seam.sy1 = y1, seam.sx2 = x2, seam.sy2 = y2;        
    }
}
function setshapesideseam3(index, sideindex) {
    let side = shape.sides[sideindex];     
    let seam = side.seams[index];  
    if (seam != undefined) {        
        let smtype = seam.type, x = seam.x, y = seam.y, h = seam.h, x1 = 0, y1 = 0, x2 = 0, y2 = 0, dw = 0, sw = 0;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let npt1 = calcverticalvectorpoint(x11, y11, x12, y12, x, y);
        x1 = npt1.dx, y1 = npt1.dy, x2 = x, y2 = y;
        dw = calchyplen(x1, y1, x2, y2);
        let npt2 = offsetline(x11, y11, x12, y12, -dw);
        x1 = npt2.dx1, y1 = npt2.dy1, x2 = npt2.dx2, y2 = npt2.dy2;
        sw = applymminchfact1(calchyplen(x11, y11, x1, y1), 2, 2, 'setshapesideseam3');
        seam.x1 = x1, seam.y1 = y1, seam.x2 = x2, seam.y2 = y2, seam.sw = sw;
        seam.sx1 = x1, seam.sy1 = y1, seam.sx2 = x2, seam.sy2 = y2;        
    }
}
function onsetsideseam31(x, y, index, sideindex, sindex, type, source) {
    source += ':onsetsideseam31';
    let areaid = shape.areaid, partsrno = shape.partsrno, spsideindex = shape.sides[sideindex].spsideindex;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);   
    let pshapeside = partshape.sides[spsideindex];
    if (index == -1) {
        let x11 = pshapeside.x11, y11 = pshapeside.y11, x12 = pshapeside.x12, y12 = pshapeside.y12;
        let angle = calclineangle2(x11, y11, x12, y12, source);        
        angle = Math.abs(angle - shape.angle);
        //console.log(x, y, index, sideindex, sindex, type, angle, shape.sides.length, source);
        if (partshape.sides.length == 1) {
            if (angle == 90 || angle == 270) { if (type == 3) { type = 1; } else if (type == 1) { return; }}
        } else {type = 1;}
        //console.log(x, y, index, sideindex, sindex, type, angle, shape.sides.length, source);
        for (let j = 0; j < pshapeside.seams.length; j++) {
            if (pshapeside.seams[j].type != 2 && pshapeside.seams[j].isactive == 1 && pshapeside.seams[j].type != type) { return false; }
        }
    }   
    let index1 = setsideseam31(x, y, index, sideindex, type, source);
    if (index == -1) { ActionAddSeam32(index1, sideindex, source); }
}
function onsetsidecornerseam31(x, y, index, sideindex, sindex, type, source) {
    source +=':onsetsidecornerseam31';
    let areaid = shape.areaid, partsrno = shape.partsrno, spsideindex = shape.sides[sideindex].spsideindex;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    let pshapeside = partshape.sides[spsideindex];
    if (index == -1){
        for (let j = 0; j < pshapeside.seams.length; j++) {
            if (pshapeside.seams[j].isactive == 1 && pshapeside.seams[j].type == type) { return false;}
        }
    }
    let index1 = setsideseam31(x, y, index, sideindex, type, source);
    if (index == -1) { ActionAddSeam32(index1, sideindex, source); }
}
function onsetsideseam32(x, y, index, sideindex, type, source) {    
    setsideseam31(x, y, index, sideindex, type, source);   
    drawsideseam(index, sideindex, type, source);    
}
function resetshapeseams32(source) {
    for (let i = 0; i < shape.sides.length; i++) {       
        resetsideseams32(i, source);
    }
}
function resetsideseams32(sideindex, source) {
    let side = shape.sides[sideindex];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    for (let i = 0; i < side.seams.length; i++) {       
        let seam = side.seams[i];        
        if (seam.type == 1 && seam.sw > 0) {
            let sw = applymminchfact1(seam.sw, 1, 2), asign = -1;
            let angle = calclineangle2(x11, y11, x12, y12, source);
            let npt = rotate_point1(x11, y11, asign, angle, sw);           
            seam.x = npt.dx; seam.y = npt.dy;
        }
        setsideseam31(0, 0, i, sideindex, seam.type, source);
        drawsideseam(i, sideindex, seam.type, source);
    }
}
function onsetsideseams32(sideindex, source) {
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.seams.length; i++) {
        setsideseam31(0, 0, i, sideindex, side.seams[i].type, source);
        drawsideseam(i, sideindex, side.seams[i].type, source);
    }
}
function getseamindexbytype(side, type){
    let seamindex=-1;
    for (let i = 0; i < side.seams.length; i++) {       
        if(side.seams[i].type==type){
            seamindex = i;
            break;
        }        
    }
    return seamindex;
}
function onsetcornerseam32(cornerindex, sideindex, source) {   
    if (sideindex == 0) { return;}
    let type = 2, seamsideindex = sideindex - 1;
    let side = shape.sides[seamsideindex];
    let seamindex = getseamindexbytype(side, type);    
    if (seamindex != -1) {        
        let seam = side.seams[seamindex];
        let corner = shape.sides[sideindex].corners[cornerindex];
        applyseamtocornershape32(side, corner, seam, source);        
        drawsideseam(seamindex, seamsideindex, type, source);
    }
}
function applyseamtosideshapes31(seamindex, sideindex, source) {
    let side = shape.sides[sideindex];
    let seam = side.seams[seamindex];
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].isactive == 1) {
            applyseamtosideshape31(side, side.sideshapes[i], seam, source);
        }
    }
}
function applyseamtosideshapes33(seamindex, sideindex) {
    let side = shape.sides[sideindex];
    let seam = side.seams[seamindex];
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].isactive == 1) {
            applyseamtosideshape33(side, side.sideshapes[i], seam);
        }
    }
}
function applyseamtocornershapes32(seamindex, seamsideindex, cornersideindex, source) {   
    let seamside = shape.sides[seamsideindex];   
    let seam = seamside.seams[seamindex];
    let cornerside = shape.sides[cornersideindex];
    for (let i = 0; i < 2; i++) {
       // console.log(i, seamindex, seamsideindex, cornersideindex, JSON.stringify(cornerside.corners[i]));
        applyseamtocornershape32(seamside, cornerside.corners[i], seam);
    }
}
function applyseamtosideshape31(side, sideshape, seam, source) {
    source = ':applyseamtosideshape31';
    let sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22,
         sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sidecode = sideshape.sidecode, sw = sideshape.w;
    let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, smtype = seam.type, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2;
  //  console.log(side.index, seam.index, sidecode, type, typeid);
    if (sidecode == 1) {
        let angle = calclineangle2(x2, y2, x1, y1, source);
        let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
        let npt = rotate_point1(x1, y1, asign, angle, 1);
        //drawpointcircle(4, 1, 1, 1, npt.dx, npt.dy, 10, 'U');
        let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
        //console.log(sidecode, type, angle, isinpoly, typeid);
        //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
        if (isinpoly) {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                let npt1 = calccurveintersectpoint32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, source);
                // console.log(sidecode, type, angle, npt1.dx, npt1.dy, typeid);
                if (npt1.dx != 0 && npt1.dy != 0) {
                    seam.sx1 = npt1.dx, seam.sy1 = npt1.dy;
                }
            } else {
                let npt1 = rotate_point1(x1, y1, asign, angle, sh);
                sx1 = npt1.dx, sy1 = npt1.dy;
                let ipt1 = calintersection1(x2, y2, sx1, sy1, sx11, sy11, sx21, sy21);
                let ipt2 = calintersection1(x2, y2, sx1, sy1, sx12, sy12, sx22, sy22);
                let sh1 = calchyplen(x1, y1, ipt1.dx, ipt1.dy);
                let sh2 = calchyplen(x1, y1, ipt2.dx, ipt2.dy);
                if (sh1 < sh) { sx1 = ipt1.dx, sy1 = ipt1.dy; } else if (sh2 < sh) { sx1 = ipt2.dx, sy1 = ipt2.dy; }
                seam.sx1 = sx1, seam.sy1 = sy1;
            }
        }
    } else if (sidecode == 2) {
        let angle = calclineangle2(x1, y1, x2, y2, source);
        let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
        let npt = rotate_point1(x2, y2, asign, angle, 1);
        let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
        if (isinpoly) {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                let npt1 = calccurveintersectpoint32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw, source);
                if (npt1.dx != 0 && npt1.dy != 0) { seam.sx2 = npt1.dx, seam.sy2 = npt1.dy; }
            } else {
                let npt1 = rotate_point1(x2, y2, asign, angle, sh);
                sx2 = npt1.dx, sy2 = npt1.dy;
                let ipt1 = calintersection1(x2, y2, sx2, sy2, sx11, sy11, sx21, sy21);
                let ipt2 = calintersection1(x2, y2, sx2, sy2, sx12, sy12, sx22, sy22);
                let sh1 = calchyplen(x2, y2, ipt1.dx, ipt1.dy);
                let sh2 = calchyplen(x2, y2, ipt2.dx, ipt2.dy);
                if (sh1 < sh) { sx2 = ipt1.dx, sy2 = ipt1.dy; } else if (sh2 < sh) { sx2 = ipt2.dx, sy2 = ipt2.dy; }
                seam.sx2 = sx2, seam.sy2 = sy2;
            }
        }
    }
}
function applyseamtocornershape32(side, corner, seam, source) {
    source = ':applyseamtosideshape32';
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let cindex = corner.index, cx1 = corner.x1, cy1 = corner.y1, cx2 = corner.x2, cy2 = corner.y2, cx3 = corner.x3, cy3 = corner.y3, cw = corner.w, ch = corner.h,
    cr = corner.r, ctype = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype;
    let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, seamsideindex=seam.sideindex;
    let asign = -1;
    //console.log(cindex, side.index, sidecode, seam.index, seamsideindex, corner.index, ctype, ch, cr);
    //1- clip corner, 2- Curve corner, 3- Notch corner, 4- Bumpout corner
    if (ctype == 0) {
        if (sidecode == 1) {            
            seam.sx1 = x1, seam.sy1 = y1;
        } else if (sidecode == 2) {
            seam.sx2 = x2, seam.sy2 = y2;
        }
    }else if (ctype == 1) {
        if (sidecode == 1) {
            let ipt1 = calintersection1(x2, y2, x1, y1, cx2, cy2, cx3, cy3);             
            seam.sx1 = ipt1.dx, seam.sy1 = ipt1.dy;            
        } else if (sidecode == 2) {
            let ipt1 = calintersection1(x2, y2, x1, y1, cx2, cy2, cx3, cy3);                    
            seam.sx2 = ipt1.dx, seam.sy2 = ipt1.dy;      
        }
    } else if (ctype == 2) {
        if (sidecode == 1) {
            let angle = calclineangle2(x2, y2, x1, y1, source);
            let npt1 = calccurveintersectpoint33(cx3, cy3, cx1, cy1, cx2, cy2, x2, y2, angle, asign, cw, source);
            //console.log(seamsideindex, sidecode, angle, x2, y2, npt1.dx, npt1.dy);
            if (npt1.dx != 0 && npt1.dy != 0) {seam.sx1 = npt1.dx, seam.sy1 = npt1.dy; }
        } else if (sidecode == 2) {
            let angle = calclineangle2(x1, y1, x2, y2, source);
            let npt1 = calccurveintersectpoint33(cx3, cy3, cx1, cy1, cx2, cy2, x1, y1, angle, asign, cw, source);
            // console.log(sidecode, type, angle, npt1.dx, npt1.dy, typeid);
            if (npt1.dx != 0 && npt1.dy != 0) {seam.sx2 = npt1.dx, seam.sy2 = npt1.dy; }
        }
    } else if (ctype == 3) {          
        if (sidecode == 1) {            
            let angle = calclineangle2(cx1, cy1, cx2, cy2);
            let npt1 = rotate_point1(cx3, cy3, asign, angle, cw); 
            let ipt1 = calintersection1(x2, y2, x1, y1, cx3, cy3, npt1.dx, npt1.dy);
            let ipt2 = calintersection1(x2, y2, x1, y1, cx2, cy2, npt1.dx, npt1.dy);
            let isinline = ispointinline(cx3, cy3, npt1.dx, npt1.dy, ipt1.dx, ipt1.dy);
            let isinline1 = ispointinline(cx2, cy2, npt1.dx, npt1.dy, ipt2.dx, ipt2.dy);
            if (isinline) { seam.sx1 = ipt1.dx, seam.sy1 = ipt1.dy; }
            else if (isinline1) { seam.sx1 = ipt2.dx, seam.sy1 = ipt2.dy; }
            //console.log(cx3, cy3, npt1.dx, npt1.dy, ipt1.dx, ipt1.dy, isinline);
            //console.log(cx2, cy2, npt1.dx, npt1.dy, ipt2.dx, ipt2.dy, isinline1);           
        } else if (sidecode == 2) {
            let angle = calclineangle2(cx1, cy1, cx2, cy2);
            let npt1 = rotate_point1(cx3, cy3, asign, angle, cw);
            let ipt1 = calintersection1(x1, y1, x2, y2, cx3, cy3, npt1.dx, npt1.dy);
            let ipt2 = calintersection1(x1, y1, x2, y2, cx2, cy2, npt1.dx, npt1.dy);
            let isinline = ispointinline(cx3, cy3, npt1.dx, npt1.dy, ipt1.dx, ipt1.dy);
            let isinline1 = ispointinline(cx2, cy2, npt1.dx, npt1.dy, ipt2.dx, ipt2.dy);
            if (isinline) { seam.sx2 = ipt1.dx, seam.sy2 = ipt1.dy; }
            else if (isinline1) { seam.sx2 = ipt2.dx, seam.sy2 = ipt2.dy; }
            //console.log(seam.sx1, seam.sy1, isinline, isinline1);
        }
    } else if (ctype == 4) {
        let sx11 = cx2, sy11 = cy2, sx12 = cx3, sy12 = cy3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
        let npt1 = calcTranslationExact1(cr, cx2, cy2, cx3, cy3);
        let dx1 = npt1.dx, dy1 = npt1.dy;
        sx21 = cx2 + dx1, sy21 = cy2 + dy1, sx22 = cx3 + dx1, sy22 = cy3 + dy1;
        let x23 = (cx2 + cx3) / 2, y23 = (cy2 + cy3) / 2;
        let ipt1 = calintersection1(x23, y23, cx1, cy1, sx21, sy21, sx22, sy22);
        let angle1 = Math.floor(calclineangle2(x23, y23, cx1, cy1));
        let angle2 = Math.floor(calclineangle2(x23, y23, ipt1.dx, ipt1.dy));
        if (angle1 != angle2) {
            npt1 = calcTranslationExact1(-cr, cx2, cy2, cx3, cy3);
            dx1 = npt1.dx, dy1 = npt1.dy;
            sx21 = cx2 + dx1, sy21 = cy2 + dy1, sx22 = cx3 + dx1, sy22 = cy3 + dy1;
            ipt1 = calintersection1(x23, y23, cx1, cy1, sx21, sy21, sx22, sy22);
        }       
        let d1 = calchyplen(x1, y1, ipt1.dx, ipt1.dy);
        let d2 = calchyplen(x2, y2, ipt1.dx, ipt1.dy);
        if (d1 < d2) { seam.sx1 = ipt1.dx, seam.sy1 = ipt1.dy; } else { seam.sx2 = ipt1.dx, seam.sy2 = ipt1.dy; }       
    }
    if (sidecode == 1) { corner.sx1 = seam.sx1, corner.sy1 = seam.sy1; } else if (sidecode == 2) { corner.sx1 = seam.sx2, corner.sy1 = seam.sy2; }
}
function applyseamtosideshape33(side, sideshape, seam) {
    let source = 'applyseamtosideshape33';
    let sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22,
        sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sidecode = sideshape.sidecode, sw = sideshape.w;
    let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, smtype = seam.type, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2;
    if (sidecode == 0) {
        let angle = 0, asign = 1;
        if (typeid == 1 || typeid == 2 || typeid == 3) { asign = -1; angle = calclineangle2(x1, y1, x2, y2, source); }
        else { angle = calclineangle2(x2, y2, x1, y1, source); }       
        let npt = rotate_point1(x1, y1, asign, angle, 1);
     //   drawpointcircle(4, 1, 1, 1, npt.dx, npt.dy, 10, 'U');
        let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
        //console.log(sidecode, typeid, angle, isinpoly, asign, smtype);
        //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
        if (isinpoly) {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                let npt1 = calccurveintersectpoint32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, source);
               // console.log(sidecode, typeid, angle, npt1.dx, npt1.dy);
                if (npt1.dx != 0 && npt1.dy != 0) {
                    seam.sx1 = npt1.dx, seam.sy1 = npt1.dy;
                }
            } else {
                let npt1 = rotate_point1(x1, y1, asign, angle, sh);
                sx1 = npt1.dx, sy1 = npt1.dy;
                let ipt1 = calintersection1(x2, y2, sx1, sy1, sx11, sy11, sx21, sy21);
                let ipt2 = calintersection1(x2, y2, sx1, sy1, sx12, sy12, sx22, sy22);               
                let sh1 = calchyplen(x1, y1, ipt1.dx, ipt1.dy);
                let sh2 = calchyplen(x1, y1, ipt2.dx, ipt2.dy);                
                if (sh1 < sh) { sx1 = ipt1.dx, sy1 = ipt1.dy; } else if (sh2 < sh) { sx1 = ipt2.dx, sy1 = ipt2.dy; }
                seam.sx1 = sx1, seam.sy1 = sy1;
            }
        }
    } else if (sidecode == 3) {
        let angle = 0, asign = -1;
        if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; angle = calclineangle2(x2, y2, x1, y1, source); }
        else { angle = calclineangle2(x1, y1, x2, y2, source); }
        let npt = rotate_point1(x2, y2, asign, angle, 1);
        //drawpointcircle(4, 1, 1, 1, npt.dx, npt.dy, 10, 'U');
        let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
        //console.log(sidecode, typeid, angle, isinpoly, asign, smtype);
        if (isinpoly) {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                let npt1 = calccurveintersectpoint32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw);
                if (npt1.dx != 0 && npt1.dy != 0) { seam.sx2 = npt1.dx, seam.sy2 = npt1.dy; }
            } else {
                let npt1 = rotate_point1(x2, y2, asign, angle, sh);
                sx2 = npt1.dx, sy2 = npt1.dy;
                let ipt1 = calintersection1(x2, y2, sx2, sy2, sx11, sy11, sx21, sy21);
                let ipt2 = calintersection1(x2, y2, sx2, sy2, sx12, sy12, sx22, sy22);
                let sh1 = calchyplen(x2, y2, ipt1.dx, ipt1.dy);
                let sh2 = calchyplen(x2, y2, ipt2.dx, ipt2.dy);
                if (sh1 < sh) { sx2 = ipt1.dx, sy2 = ipt1.dy; } else if (sh2 < sh) { sx2 = ipt2.dx, sy2 = ipt2.dy; }
                seam.sx2 = sx2, seam.sy2 = sy2;
            }
        }
    }
}
function onseamshapesideseam(index, sideindex, sindex) {
    let side = shapes[sindex].sides[sideindex];
    if (side != undefined) {
        let sideseam = side.seams[index];
        if (sideseam != null) {
            sideseam.split = 1;
        }
    }
}
function unsplitshapeseams(sindex) {
    for (let i = 0; i < shape.sides.length; i++) {
        unsplitshapesideseams(i, sindex);
    }
}
function unsplitshapesideseams(sideindex, sindex) {
    if (shapes[sindex] != undefined) {
        let side = shapes[sindex].sides[sideindex];
        if (side != undefined) {
            for (let i = 0; i < side.seams.length; i++) {
                side.seams[i].split = 0;
            }
        }
    }
}
function onshapesideseamcontextmenu() {
    removeshapetools();
    let m = d3.mouse(this);
    d3.event.preventDefault();
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));    
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let spseamindex = parseInt(this.getAttribute("spseamindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let startseamindex = parseInt(this.getAttribute("startseamindex"));
    let startsideindex = parseInt(this.getAttribute("startsideindex"));
    let endseamindex = parseInt(this.getAttribute("endseamindex"));
    let endsideindex = parseInt(this.getAttribute("endsideindex"));
    let seamtype = this.getAttribute("smtype");
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    //console.log("index:" + index, "sideindex:" + sideindex, "spseamindex:" + spseamindex, "spsideindex:" + spsideindex, "sindex:" + sindex, "spindex:" + spindex, "seamtype:" + seamtype, "mode:" + mode);   
    if (mode == 'slabpart') {
        onsetslabpartshape31(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, 'onshapesideseamcontextmenu');
        drawshapeseamcontrols(index, sideindex, spseamindex, spsideindex, m[0], m[1], seamtype);        
    }
}
function ondeleteslabpartseam(index, sideindex, spseamindex, spsideindex, sindex, type) {
    removeshapetools();
    resetsideseams(index, sideindex);
    removesideseam(index, sideindex);
    drawsideseams(sideindex);   
}
function resetsideseams(index, sideindex) {
    let side = shape.sides[sideindex];
    if (side != undefined) {
        let sideseams = [];
        for (let i = 0; i < side.seams.length; i++) {
            if (side.seams[i].isactive == 1 && side.seams[i].index != index) {
                side.seams[i].index = i;
                sideseams.push(side.seams[i]);
            }
        }
        side.seams = sideseams;
    }
}
function removesideseam(index, sideindex) {
    let seamindex = shape.index + "" + sideindex + "" + index;
    if (seamsg != undefined) {
        let seamg = seamsg.select("#" + shape.mode + "seamg" + seamindex);
        if (seamg != undefined) { seamg.remove(); }
        let seammarkerg = seamsg.select("#" + shape.mode + "smarkerg" + seamindex);
        if (seammarkerg != undefined) { seammarkerg.remove(); }
    }
}
function drawsideseams(index) {
    let side = shape.sides[index];   
    if (side != undefined) {
        if (side.seams != undefined) {
            for (let j = 0; j < side.seams.length; j++) {
                if (side.seams[j].isactive == 1) {                    
                    if (shape.mode == 'slabpart') {if (side.seams[j].split == 0) { drawsideseam(j, index, side.seams[j].type); }                        
                    }else { drawsideseam(j, index, side.seams[j].type); }
                   
                }
            }
        }
    }
}
function drawsideseam(index, sideindex, type) {
    let side = shape.sides[sideindex];
    let seam = side.seams[index];   
    let smtype = seam.type, x = seam.x, y = seam.y, h = seam.h, x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, sw = seam.sw, spsideindex = seam.spsideindex, spseamindex = seam.spseamindex;
    let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0;
    if (seam.sx1 == undefined) { sx1 = x1, sy1 = y1, sx2 = x2, sy2 = y2; } else { sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2; }
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let mtx = 0, mty = 0, msw = 0, dw = 5;
    if (spsideindex == undefined) { spsideindex = sideindex; seam.spsideindex = sideindex; }
    if (spseamindex == undefined) { spseamindex = index; seam.spseamindex = spseamindex;}
    sw = applymminchfact1(calchyplen(x11, y11, x1, y1), 2, 2, 'drawsideseam');
    //console.log(shape.index, index, sx1, sy1, sx2, sy2, JSON.stringify(seam));
    drawshapesideseamline(index, sideindex, spsideindex, spseamindex, sx1, sy1, sx2, sy2, smtype);
    if (smtype != 2) {
        let index1 = -1, prevsw = 0;        
        for (let i = 0; i < side.seams.length; i++) {
            if (side.seams[i].isactive == 1 && side.seams[i].sw < sw) {
                if (side.seams[i].sw > prevsw) {
                    prevsw = parseInt(side.seams[i].sw);
                    index1 = i;
                }
            }
        }
        msw = sw;       
        if (smtype == 1) { mtx = sx1 + dw, mty = sy1 - dw; } else if (smtype == 3) { mtx = sx1 + (2 * dw), mty = sy1 - (2 * dw); }
        if (shape.mode != 'slabpartdg') {
            drawseammarkerline(index, sideindex, x11, y11, x1, y1, Math.round(mtx), Math.round(mty), roundToPlaces(msw, 2));
        }
    }
}
function drawshapesideseamline(index, sideindex, spsideindex, spseamindex, x1, y1, x2, y2, smtype) {
    let eclass = "shapeseam", seamindex = shape.index + "" + sideindex + "" + index, startsideindex = shape.startsideindex,
        startseamindex = shape.startseamindex, endsideindex = shape.endsideindex, endseamindex = shape.endseamindex;
    let seamg = seamsg.select("#" + shape.mode + "seamg" + seamindex);
    if (seamg.empty()) { seamg = seamsg.append("g").attr("id", shape.mode + "seamg" + seamindex); }
    let seamline = seamg.select("#seam" + seamindex);
    let partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    // console.log(shape.index, partsrno, areaid, spindex);
    if (seamline.empty()) { seamline = seamg.append("line").attr("id", "seam" + seamindex); }
    seamline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("spsideindex", spsideindex)
        .attr("spseamindex", spseamindex).attr("startsideindex", startsideindex).attr("startseamindex", startseamindex).attr("endsideindex", endsideindex).attr("endseamindex", endseamindex)
        .attr("sindex", shape.index).attr("spindex", spindex).attr("smode", shape.mode).attr("partsrno", partsrno).attr("areaid", areaid).attr("smtype", smtype);
    if (shape.mode == 'slabpart') {
        seamline.call(seamdrag).on("mouseover", showshapesideseam).on("mouseout", hideshapesideseam).on('contextmenu', onshapesideseamcontextmenu);
        let seambandline = seamg.select("#seamband" + seamindex);
        if (seambandline.empty()) { seambandline = seamg.append("line").attr("id", "seamband" + seamindex); }
        seambandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index)
            .attr("sideindex", sideindex).attr("spsideindex", spsideindex).attr("spseamindex", spseamindex).attr("spsideindex", spsideindex)
            .attr("startsideindex", startsideindex).attr("startseamindex", startseamindex).attr("endsideindex", endsideindex).attr("endseamindex", endseamindex)
            .attr("sindex", shape.index).attr("spindex", spindex).attr("smode", shape.mode).attr("partsrno", partsrno).attr("areaid", areaid).attr("smtype", smtype)
            .on('contextmenu', onshapesideseamcontextmenu).on("mouseover", showshapesideseam).on("mouseout", hideshapesideseam).call(seamdrag);
        seambandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", "20");
    }
}
function drawseammarkerline(index, sideindex, x1, y1, x2, y2, mtx, mty, mtext) {
    let seamindex = shape.index + "" + sideindex + "" + index;
    let seammarkerg = seamsg.select("#" + shape.mode + "smarkerg" + seamindex);
    if (seammarkerg.empty()) { seammarkerg = seamsg.append("g").attr("id", shape.mode + "smarkerg" + seamindex); }
    if (!seammarkerg.empty()) {
        seammarkerg.attr("index", index).attr("sideindex", sideindex).attr("sindex", shape.index).attr("smode", shape.mode);
        //var markerline = seammarkerg.select("#msline" + seamindex);
        //if (markerline.empty()) { markerline = seammarkerg.append("line").attr("id", "msline" + seamindex); }
        //var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
        //var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
        //markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "seamarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
        let smarkertext = seammarkerg.select("#mseamtext" + seamindex);
        if (smarkertext.empty()) { smarkertext = seammarkerg.append("text").attr("id", "mseamtext" + seamindex); }
        smarkertext.attr("x", mtx).attr("y", mty).text(mtext);
        smarkertext.attr("style", "fill:red;fill-opacity:0.3;");
        let angle1 = shape.angle;
        // console.log(index, code, mtx, mty, mtext, angle, angle1);
        smarkertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
    }
}
function seamdragstarted() {
    removeshapetools();
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let spseamindex = parseInt(this.getAttribute("spseamindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let startseamindex = parseInt(this.getAttribute("startseamindex"));
    let startsideindex = parseInt(this.getAttribute("startsideindex"));
    let endseamindex = parseInt(this.getAttribute("endseamindex"));
    let endsideindex = parseInt(this.getAttribute("endsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    if (mode == 'slabpart') {
        onsetslabpartshape31(sindex, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, mode, 'seamdragstarted');
        let side = shape.sides[sideindex];
        let seam = side.seams[index];
       // console.log(JSON.stringify(side.seams));
        if (seam != undefined) {
            if (seam.type != 2) {
                dragdx = d3.event.x - seam.x; dragdy = d3.event.y - seam.y;
                bdrag = true;
            }
        }
    }   
}
function seamdragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let side = shape.sides[sideindex];
        let seam = side.seams[index];
        let cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        seam.x = cx; seam.y = cy;
        onsetsideseam32(cx, cy, index, sideindex, seam.type, 'seamdragged');
        //console.log(JSON.stringify(seam));
    }
}
function seamdragended() {
    if (bdrag) {
        resetdragvars('seamdragended');
        bdrag = false;
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let seamindex = sideindex + "" + index;
        let seammarkerg = seamsg.select("#smarkerg" + seamindex);
        if (!seammarkerg.empty()) { seammarkerg.style("opacity", "0"); }
        ActionDragSeam32(index, sideindex, 'seamdragended');
    }
}
function showshapesideseam() {
    if (!bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sindex = parseInt(this.getAttribute("sideindex"));
        var smode = this.getAttribute("smode");
        var seamindex = sindex + "" + sideindex + "" + index;
        var seammarkerg = seamsg.select("#" + smode + "smarkerg" + seamindex);
        if (!seammarkerg.empty()) { seammarkerg.style("opacity", "1"); }
        d3.select(this).attr("class", "shapesideblue");
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
    }
}
function hideshapesideseam() {
    if (!bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sindex = parseInt(this.getAttribute("sideindex"));
        var smode = this.getAttribute("smode");
        var seamindex = sindex + "" + sideindex + "" + index;
        var seammarkerg = seamsg.select("#" + smode + "smarkerg" + seamindex);
        if (!seammarkerg.empty()) { seammarkerg.style("opacity", "0"); }
        d3.select(this).attr("class", "shapeseam");
        let scolor = d3.select(this).attr('scolor');
        d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", "15");
    }
}
