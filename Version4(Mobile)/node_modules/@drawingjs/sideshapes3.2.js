function initshapesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = {};
    sideshape.index = index, sideshape.sideindex = sideindex, sideshape.sidecode = sidecode, sideshape.type = sideshapetype, sideshape.typeid = sideshapetypeid, sideshape.angle = 45;
    sideshape.w = 136, sideshape.h = 42, sideshape.r = 42, sideshape.isactive = 1, sideshape.dw = 0, sideshape.edges = [];    
    sideshape.x = side.x11, sideshape.y = side.y11;
    if (sideshapetype == 2 || sideshapetype == 5) { sideshape.w = 2 * sideshape.w; }
    else if (sideshape.typeid == 11) {//11-full arc
        if (sidecode == 0) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
        else if (sidecode == 1) { sideshape.w = applymminchfact(side.w1, 1, 0), sideshape.h = sideshape.r = applymminchfact(side.w1, 1, 0) / 4; }
        else if (sidecode == 2) { sideshape.w = applymminchfact(side.w2, 1, 0), sideshape.h = sideshape.r = applymminchfact(side.w2, 1, 0) / 4; }
        else if (sidecode == 3) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
    }
    side.sideshapes.push(sideshape);    
}
function initsideshapeedge(index, type, typeid, text, width) {
    let edge = { index: index, type: type, typeid: typeid, text: text, width: width, height: 0 };
    return edge;
}
function setsideshapeedges(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];    
    let sedgeindex = sideedgeindex1(side, sidecode);
    let edgetype = side.edges[sedgeindex].type, edgetypeid = side.edges[sedgeindex].typeid;  
    let sideshape = side.sideshapes[index];
    let sw = sideshape.dw / 4, sh = sideshape.h / 4;
    sideshape.edges = [];
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, 'W', -1, edgetype, sw));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sh));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sw));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sh));
}
function setsideshape(x, y, index, sideindex, sidecode) {   
    let side = shape.sides[sideindex];   
    if (index == -1) { index = side.sideshapes.length, initshapesideshape(index, sideindex, sidecode); }
    let sideshape = side.sideshapes[index], type = sideshape.type, typeid = sideshape.typeid;
    if (sideshape != undefined) {      
        if (sideshape.index != index) { sideshape.index = index; } //reindex 
        if (x != 0 && y != 0) { setsideshapecoords(x, y, index, sideindex, sidecode); }
    }
    //console.log(x, y, index, sideindex, sidecode, type, typeid);
    //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
    if (sideshape.dw == undefined) { setsideshapecoords(0, 0, index, sideindex, sidecode); }   
    if (typeid == 3 || typeid == 6 || typeid == 11) {setarcsideshape(index, sideindex, sidecode);
    } else if (typeid == 1 || typeid == 4) { setbumpinoutsideshape(index, sideindex, sidecode); }
    else if (typeid == 5) { setbumpoutanglesideshape(index, sideindex, sidecode); }
    else if (typeid == 2) { setbumpinanglesideshape(index, sideindex, sidecode); }
    setsideshapeedges(index, sideindex, sidecode);
    return index;
}
function setsideshapecoords(x, y, index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, x, y);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let angle1 = calclineangle2(sx1, sy1, sx11, sy11);
        if (Math.abs(angle - angle1) > 10) { sx11 = sx1, sy11 = sy1; }       
        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let angle2 = calclineangle2(sx12, sy12, sx2, sy2);
        if (Math.abs(angle - angle2) > 10){
            sx12 = sx2, sy12 = sy2;
            let npt3 = rotate_point1(sx12, sy12, -1, angle + 180, sw); //first point on side
            sx11 = npt3.dx, sy11 = npt3.dy;
        }
        dw = calchyplen(sx11, sy11, sx12, sy12);    
        sideshape.x = sx11, sideshape.y = sy11, sideshape.dw = dw;
    }
}
function setbumpinoutsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (typeid == 1) { sh = -sh; } //1- Bump in, 4- Bump Out
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side
        
        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;
        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;      
    }
}
function setbumpoutanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let opt1 = offsetline(sx11, sy11, sx12, sy12, sh);

        if (sidecode == 0) { angle1 = angle - 90 + sideangle, angle2 = angle - 90 - sideangle; }
        else if (sidecode == 1) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 270 + sideangle, angle2 = angle + 180 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;
                
        let ipt1 = calintersection1(sx11, sy11, sx21, sy21, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //hyp length       
        let ipt2 = calintersection1(sx12, sy12, sx22, sy22, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //

        sx21 = ipt1.dx, sy21 = ipt1.dy, sx22 = ipt2.dx, sy22 = ipt2.dy;
             
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;      

    }
}
function setbumpinanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; sh = -sh; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; sh = -sh; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let opt1 = offsetline(sx11, sy11, sx12, sy12, sh);

        if (sidecode == 0) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 1) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 180 + sideangle, angle2 = angle + 270 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;

        let ipt1 = calintersection1(sx11, sy11, sx21, sy21, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //hyp length       
        let ipt2 = calintersection1(sx12, sy12, sx22, sy22, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //

        sx21 = ipt1.dx, sy21 = ipt1.dy, sx22 = ipt2.dx, sy22 = ipt2.dy;

        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;       
    }
}
function setarcsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (typeid == 3) { sh = -sh; }//3- Bump in Arc, 6- Bump out Arc, 11- Full Arc
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;
        sh = 2 * sh;
        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;        
    }
}
function setsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    if (sideshape != undefined) {
        let sideshapeedge = sideshape.edges[lnindex], sw = sideshape.dw / 4, sh = sideshape.h / 4;
        sideshapeedge.type = edgetype, sideshapeedge.typeid = edgetypeid;
        if (lnindex == 0 || lnindex == 2) { sideshapeedge.width = sw; } else { sideshapeedge.width = sh; }
        let sideshapeindex = shape.index + "" + sideindex + "" + index;
        let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
        if (!sideshapeg.empty()) {
            let sslineindex = index + "" + lnindex;
            let sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
            let etypes = [];
            if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
            let eclass = sideedgeclass(edgetype);
            if (!sideshapeline.empty()) {
                sideshapeline.attr("edgetype", edgetype); sideshapeline.attr("class", eclass);
                if (etypes[1] != undefined) { sideshapeline.attr("style", "stroke:" + etypes[1]); }
            }//mouseout hideshapecorner will set class based on edgetype
        }
    }
}
function setsideshapeedges1(index, sideindex, type, typeid) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    for (let i = 1; i < sideshape.edges.length; i++) {
        setsideshapeedge1(i, index, sideindex, type, typeid);
    }
}
function onsetsideshape(x, y, index, sideindex, sidecode, source) {
   // console.log(x, y, index, sideindex, sidecode, source);
    source = source + ':onsetsideshape';
    drawlogservice.beforeupdate(shape, source, 5);
    index = setsideshape(x, y, index, sideindex, sidecode);
    drawsideshape(index, sideindex);
    drawshapeside32(sideindex, source);
    onsetsidesplash1(sideindex, sidecode, 1, source);
   //// setsideedge1(sideindex, sidecode, "U", 0, source);
   // setsideshapesedges(sideindex, sidecode, 'U', 0);    
    ActionSideShape(source);
    drawlogservice.update(shape, source, 5);
}
function onsetsideshape1(x, y, index, sideindex, sidecode, source) {
    source = source + ':onsetsideshape1';
    setsideshape(x, y, index, sideindex, sidecode);
    drawsideshape(index, sideindex);
    drawshapeside32(sideindex, source);
    onsetsidesplash1(sideindex, sidecode, 1, source);
}
function setsideshapesedges(sideindex, sidecode, type, typeid) {
    //console.log(sideindex, sidecode, type, typeid);
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].sidecode == sidecode) {
            setsideshapeedges1(i, sideindex, type, typeid);
        }
    }
}
function onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid) {
    //console.log(lnindex, index, sideindex, edgetype, edgetypeid);
    drawlogservice.beforeupdate(shape, 'onsideshapeside', 5);
    setsideshapeedges1(index, sideindex, edgetype, edgetypeid);
    ActionSideShape('onsetsideshapeedge1');
    drawlogservice.update(shape, 'onsideshapeside', 5);  
}
function onsideshapecontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode != 'print') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onsideshapecontextmenu');
        drawsideshapecontrols(index, sideindex, sidecode, m[0], m[1]);
    }
}
function onresizesideshape(obj, type, index, sideindex) {
    let source = 'onresizesideshape';
    drawlogservice.beforeupdate(shape, source, 5);
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    let sidecode = sideshape.sidecode, typeid = sideshape.typeid, sw = sideshape.w, sh = sideshape.h;
    let objVal = obj.value.split(" ");
    let swh = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    let isvalid = true;
    if (isNaN(swh) || swh < minwh) { isvalid = false; }
    let swhfact = 0;
    if (typeid == 2 || typeid == 5) {
        if (type == 0) { swhfact = roundToOne(sh / applymminchfact(swh, 1, 2)); }
        else if (type == 1) { swhfact = roundToOne(applymminchfact(swh, 1, 2) / sw); }
        if (swhfact >= 0.5) { isvalid = false; }      
    }  
    if (isvalid > 0) {
        if (type == 0) { sideshape.w = applymminchfact(swh, 1, 2); }
        else if (type == 1) { sideshape.h = applymminchfact(swh, 1, 2); }
        else if (type == 2) { sideshape.angle = swh; }
        setsideshape(0, 0, index, sideindex, sidecode);
        drawsideshape(index, sideindex);
        onsetsidesplash1(sideindex, sidecode, 1, source);
        drawshapeside32(sideindex, source);
        ActionSideShape(source);
        drawlogservice.update(shape, source, 5);
    }
}
function validatesideshapechange() {
    
}
function ondeletesideshape(index, sideindex) {
    let source = 'ondeleteshapesideshape';
    if (sideshapesg != undefined) {
        drawlogservice.beforeupdate(shape, source, 5);
        let side = shape.sides[sideindex];
        let sideshape = side.sideshapes[index];
        let sidecode = sideshape.sidecode;
        sideshape.isactive = 0;
        let sideshapeindex = shape.index + "" + sideindex + "" + index;
        $("#" + shape.mode + "sideshapeg" + sideshapeindex).remove();        
        drawshapeside32(sideindex, source);
        deletesideshapesplashs(index, sideindex, sidecode, 3)
        onsetsidesplash1(sideindex, sideshape.sidecode, 1, source);
        ActionSideShape(source);
        drawlogservice.update(shape, source, 5);       
    }
    removeshapetools();
}
function onsideshapeside() {
    let mode = this.getAttribute("smode");  
    if (mode == 'shape') {
        let lnindex = parseInt(this.getAttribute("lnindex"));
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));      
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onsideshapeside');
        if (drawmode == 4) {           
            onsetsideshapesplash(lnindex, index, sideindex, sidecode, edgetype, edgetypeid, 3);
        } else if (drawmode == 5) {
            onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid);
        }
    }
}
function resetshapesideshapes(source) {
    for (let i = 0; j < shape.sides.length; i++) {
        resetsideshapes(i, source)
    }
}
function resetsideshapes(index, source) {
    source =  source + ':resetsideshapes';
    let side = shape.sides[index];
    for (let j = 0; j < side.sideshapes.length; j++) {
        if (side.sideshapes[j].isactive == 1) {
            onsetsideshape1(0, 0, j, index, side.sideshapes[j].sidecode, source);
        }
    }
}
function setsideshapeseampos31(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw) {   
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, issplit = 0, seamline = 0, seamheight = 0, tfact = 0;  
    for (let j = 0; j < side.seams.length; j++) {
        let seam = side.seams[j];
        let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2;   
        if (sidecode == 1) {
            let angle = calclineangle2(x2, y2, x1, y1, 'setsideshapeseampos');
            let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
            let npt = rotate_point1(x1, y1, asign, angle, 20);
            let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);     
            if (isinpoly) {
                issplit = seam.split;        
                if (issplit == 1) {
                    let isinline = ispointinline(x11, y11, x12, y12, sx11, sy11);
                    let isinline1 = ispointinline(x11, y11, x12, y12, sx12, sy12);
                    seamheight = calchyplen(x1, y1, sx1, sy1);
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                    //console.log(index, side.index, shape.index, j, isinpoly, x1, y1, x2, y2, sx1, sy1, sx2, sy2, isinline, isinline1);               
                    if (isinline) {
                        tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, 'setsideshapeseampos31:1');
                        sx12 = x1; sy12 = y1;
                        sx22 = sx1; sy22 = sy1;
                        seamline = 0;
                    }
                    else if (isinline1) {
                        tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, 'setsideshapeseampos31:1');
                        sx11 = x1; sy11 = y1;
                        sx21 = sx1; sy21 = sy1;
                        seamline = 1;
                    }
                }
            }
        } else if (sidecode == 2) {
            let angle = calclineangle2(x1, y1, x2, y2, 'setsideshapeseampos');
            let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
            let npt = rotate_point1(x2, y2, asign, angle, 20);
            let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
        //    console.log(index, typeid, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw, seam.split, isinpoly);
            if (isinpoly) {
                issplit = seam.split;
                if (issplit == 1) {
                    let isinline = ispointinline(x11, y11, x12, y12, sx11, sy11);
                    let isinline1 = ispointinline(x11, y11, x12, y12, sx12, sy12);
                    seamheight = calchyplen(x1, y1, sx1, sy1);
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                    // console.log(index, side.index, shape.index, j, isinpoly, x1, y1, x2, y2, sx1, sy1, sx2, sy2, isinline, isinline1);               
                    if (isinline) {
                        tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw, 'setsideshapeseampos31:2');
                        sx12 = x2; sy12 = y2;
                        sx22 = sx2; sy22 = sy2;
                        seamline = 0;
                    }
                    else if (isinline1) {
                        tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw, 'setsideshapeseampos31:2');
                        sx11 = x2; sy11 = y2;
                        sx21 = sx2; sy21 = sy2;
                        seamline = 1;
                    }
                }
            }
        }
    }
    return {
        sx11: Math.round(sx11), sy11: Math.round(sy11), sx12: Math.round(sx12), sy12: Math.round(sy12),
        sx21: Math.round(sx21), sy21: Math.round(sy21), sx22: Math.round(sx22), sy22: Math.round(sy22), seamsplit: issplit, seamline: seamline, seamheight: seamheight, tfact: tfact
    };
}
function setsideshapeseampos32(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw) {
   // console.log(index, typeid, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, issplit = 0, seamline = 0, seamheight = 0, tfact = 0;
    for (let j = 0; j < side.seams.length; j++) {
        let seam = side.seams[j];
        let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2, smtype = seam.type;
        if (sidecode == 0) {
            let angle = calclineangle2(x2, y2, x1, y1, 'setsideshapeseampos');
            let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
            let npt = rotate_point1(x1, y1, asign, angle, 20);
            let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
            if (isinpoly) {
                issplit = seam.split;
                if (issplit == 1) {
                    if (smtype == 3) {
                        isinline = ispointinline(x11, y11, x21, y21, sx11, sy11);
                        isinline1 = ispointinline(x12, y12, x22, y22, sx12, sy12);
                    } else {
                        isinline = ispointinline(x11, y11, x12, y12, sx11, sy11);
                        isinline1 = ispointinline(x11, y11, x12, y12, sx12, sy12);
                    }
                    seamheight = calchyplen(x1, y1, sx1, sy1);
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                    // console.log(index, side.index, shape.index, j, isinpoly, x1, y1, x2, y2, sx1, sy1, sx2, sy2, isinline, isinline1);               
                    if (isinline) {
                        if (typeid == 3 || typeid == 6 || typeid == 11) { tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, 'setsideshapeseampos32:0'); }
                        sx12 = x1; sy12 = y1;
                        sx22 = sx1; sy22 = sy1;
                        seamline = 0;
                    }
                    else if (isinline1) {
                        if (typeid == 3 || typeid == 6 || typeid == 11) { tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x1, y1, angle, asign, sw, 'setsideshapeseampos32:0'); }
                        sx11 = x1; sy11 = y1;
                        sx21 = sx1; sy21 = sy1;
                        seamline = 1;
                    }
                }
            }
        } else if (sidecode == 3) {
            let angle = calclineangle2(x1, y1, x2, y2, 'setsideshapeseampos');
            let asign = -1; if (typeid == 1 || typeid == 2 || typeid == 3) { asign = 1; }
            let npt = rotate_point1(x2, y2, asign, angle, 20);
            let isinpoly = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, npt.dx, npt.dy);
            if (isinpoly) {
                issplit = seam.split;
                let isinline = false, isinline1 = false;
                if (issplit == 1) {
                    if (smtype == 3) {
                        isinline = ispointinline(x11, y11, x21, y21, sx11, sy11);
                        isinline1 = ispointinline(x12, y12, x22, y22, sx12, sy12);
                    } else {
                        isinline = ispointinline(x11, y11, x12, y12, sx11, sy11);
                        isinline1 = ispointinline(x11, y11, x12, y12, sx12, sy12);
                    }
                    seamheight = calchyplen(x1, y1, sx1, sy1);
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                  //  console.log(index, x11, y11, x12, y12, x21, y21, x22, y22, sx11, sy11, sx12, sy12, sidecode, isinline, isinline1);
                    if (isinline) {
                        if (typeid == 3 || typeid == 6 || typeid == 11) { tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw, 'setsideshapeseampos32:3'); }
                        sx12 = x2; sy12 = y2;
                        sx22 = sx2; sy22 = sy2;
                        seamline = 0;
                    }
                    else if (isinline1) {
                        if (typeid == 3 || typeid == 6 || typeid == 11) { tfact = calccurveinterecttfact32(sx11, sy11, rx, ry, sx12, sy12, x2, y2, angle, asign, sw, 'setsideshapeseampos32:3'); }
                        sx11 = x2; sy11 = y2;
                        sx21 = sx2; sy21 = sy2;
                        seamline = 1;
                    }
                }
            }
        }
    }
    return {
        sx11: Math.round(sx11), sy11: Math.round(sy11), sx12: Math.round(sx12), sy12: Math.round(sy12),
        sx21: Math.round(sx21), sy21: Math.round(sy21), sx22: Math.round(sx22), sy22: Math.round(sy22), seamsplit: issplit, seamline: seamline, seamheight: seamheight, tfact: tfact
    };
}
function drawsideshapes(index) {   
    let side = shape.sides[index];
   // console.log(shape.index, index, shape.mode, side.sideshapes.length);
    for (let j = 0; j < side.sideshapes.length; j++) {
     //   console.log(shape.index, shape.mode,side.sideshapes[j].isactive, side.sideshapes.length);
        if (side.sideshapes[j].isactive == 1) {           
            drawsideshape(j, index, side.sideshapes[j].type);
        }
    }
}
function drawsideshape(index, sideindex) {
    let source = 'drawsideshape';
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sidecode = sideshape.sidecode, sideedges = sideshape.edges, type = sideshape.type, typeid = sideshape.typeid, sw = sideshape.w, sh = sideshape.h;
    if (sideshape != undefined) {
        if (sideshape.sx1 == undefined) { setsideshape(0, 0, index, sideindex, sideshape.sidecode); }
        let sx1 = sideshape.sx1, sy1 = sideshape.sy1, sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12,
        sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22;
        //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
        let edge1type = sideedges[0].type, edge2type = sideedges[1].type, edge3type = sideedges[2].type, edge4type = sideedges[3].type;
        if (shape.mode == 'slabpart') {
            let npt = {};
            if (sidecode == 1 || sidecode == 2) { npt = setsideshapeseampos31(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
            else { npt = setsideshapeseampos32(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
            if (typeid == 3 || typeid == 6 || typeid == 11) {               
                if (npt.seamsplit == 1) {
                    if (typeid == 3) { edge3type = sideedges[0].type; }
                    if (npt.seamline == 0) {
                        let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                        //drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, npt.sx12, npt.sy12, edge1type);
                        drawsideshapearcline1(1, index, typeid, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, npt.sx12, npt.sy12, 0, npt.tfact, sw, edge2type);
                        //drawsideshapeline(2, index, sideindex, sidecode, npt.sx12, npt.sy12, npt.sx22, npt.sy22, edge3type);
                       // drawsideshapepath1(index, sideindex, sidecode, npt.sx11, npt.sy11, npt.sx12, npt.sy12, npt.sx22, npt.sy22, typeid);                       
                    } else {
                        let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                       // drawsideshapeline(0, index, sideindex, sidecode, npt.sx11, npt.sy11, sx12, sy12, edge1type);
                        drawsideshapearcline1(1, index, typeid, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, npt.sx11, npt.sy11, npt.tfact, 1, sw, edge2type);
                       // drawsideshapeline(2, index, sideindex, sidecode, npt.sx11, npt.sy11, npt.sx21, npt.sy21, edge3type);
                       // drawsideshapepath1(index, sideindex, sidecode, npt.sx11, npt.sy11, npt.sx21, npt.sy21, sx12, sy12, typeid);
                    }                   
                  
                } else {
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                  //  drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, sx12, sy12, edge1type);
                    drawsideshapearcline(1, index, typeid, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, edge2type);
                }               
            } else {                
                sx11 = npt.sx11, sy11 = npt.sy11, sx12 = npt.sx12, sy12 = npt.sy12, sx21 = npt.sx21, sy21 = npt.sy21, sx22 = npt.sx22, sy22 = npt.sy22;               
                if (npt.seamsplit == 1 && (typeid == 1 || typeid == 2)) {
                    //console.log(index, sidecode, npt.seamline);
                    if (npt.seamline == 0) {
                        edge4type = sideedges[0].type;
                        drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edge2type);
                        drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edge3type);
                        drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edge4type);
                    } else {
                        edge2type = sideedges[0].type;
                        drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edge2type);
                        drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edge3type);
                        drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edge4type);
                    }
                } else {
                    drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edge2type);
                    drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edge3type);
                    drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edge4type);
                }
                drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, typeid);   
            }
        } else {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;                
                drawsideshapearcline(1, index, typeid, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, edge2type);
                let mtext = decimaltofraction(applymminchfact(sw, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(sh, 2, 2, source));
                if (typeid == 11) { mtext = "R " + decimaltofraction(applymminchfact(sh, 2, 2, source));}
                drawsideshapemarkertext(index, sideindex, sidecode, mtext);
            } else {               
                drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edge2type);
                drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edge3type);
                drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edge4type);
                drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
                let mtext = decimaltofraction(applymminchfact(sw, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(sh, 2, 2, source));
                drawsideshapemarkertext(index, sideindex, sidecode, mtext);
            }
        }
    }
}
function drawsideshapeline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);   
    let sideshapeindex = shape.index + "" + sideindex + "" + index;    
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = index + "" + lnindex;
    let sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "sideshape" + sslineindex); }
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (etypes[1] != undefined) { sideshapeline.attr("style", "stroke:" + etypes[1]); }
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype, drawmode);
    if (shape.mode == 'shape') {
        if (lnindex == 2) {
            sideshapeline.on("click", onsideshapeside).on("mouseover", showsideshapeside).on("mouseout", hidesideshapeside);
            let sideshapebandline = sideshapeg.select("#sideshapeband" + sslineindex);
            if (sideshapebandline.empty()) { sideshapebandline = sideshapeg.append("line").attr("id", "sideshapeband" + sslineindex); }
            sideshapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
            .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
            sideshapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", "15");
            sideshapebandline.on("click", onsideshapeside).on("mouseover", showsideshapeside).on("mouseout", hidesideshapeside);
        }
    }
}
function drawsideshapearcline(lnindex, index, typeid, sideindex, sidecode, x1, y1, x2, y2, x3, y3, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sspath = quadraticcurvepath(x1, y1, x2, y2, x3, y3);
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = index + "" + lnindex;
    let sideshapepath = sideshapeg.select("#" + "sideshapepath" + sslineindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + sslineindex); }
    sideshapepath.attr("d", sspath).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
        .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    sideshapepath.on("click", onsideshapeside).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside);
    if (shape.mode == 'shape') { sideshapepath.on("contextmenu", onsideshapecontextmenu); if (typeid != 11) { sideshapepath.call(sideshapedrag); } }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (etypes[1] != undefined) { sideshapepath.style("stroke", etypes[1]); }
}
function drawsideshapearcline1(lnindex, index, typeid, sideindex, sidecode, x1, y1, x2, y2, x3, y3, lx1, ly1, t1, t2, sw, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);   
    let sideshapeindex = shape.index + "" + sideindex + "" + index;    
    let sspath = quadraticcurvesplitpath32(x1, y1, x2, y2, x3, y3, lx1, ly1, t1, t2, sw, 'drawsideshapearcline1');
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = index + "" + lnindex;
    let sideshapepath = sideshapeg.select("#" + "sideshapepath" + sslineindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + sslineindex); }
    sideshapepath.attr("d", sspath).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
        .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    sideshapepath.on("click", onsideshapeside).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside);
    if (shape.mode == 'shape') {sideshapepath.on("contextmenu", onsideshapecontextmenu); if (typeid != 11) { sideshapepath.call(sideshapedrag); } } 
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (etypes[1] != undefined) { sideshapepath.style("stroke", etypes[1]); }
}
function drawsideshapepath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, typeid) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = 'sideshape', sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sideshapepath = sideshapeg.select("#" + "sideshapepath" + index);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + index); }
    sideshapepath.attr("d", sspath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("class", eclass)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu);
        if (typeid != 11) { sideshapepath.call(sideshapedrag); }
    } 
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2").style("display", "block");
}
function drawsideshapepath1(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, typeid) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = 'sideshape', sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath +=  "l" + (x21 - x12) + "," + (y21 - y12) + "z";
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sideshapepath = sideshapeg.select("#" + "sideshapepath" + index);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + index); }
    sideshapepath.attr("d", sspath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("class", eclass)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu);
        if (typeid != 11) { sideshapepath.call(sideshapedrag); }
    }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2").style("display", "block");
}
function drawsideshapemarkertext(index, sideindex, sidecode, mtext) {
    let sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);    
    let sideshapetext = sideshapeg.select("#sideshapetext" + sideshapeindex);
    if (sideshapetext.empty()) { sideshapetext = sideshapeg.append("text").attr("id", "sideshapetext" + sideshapeindex).attr("class", "shapemarker"); }
    if (sideshapeg.node() != null) {
        let sideshapegnode = sideshapeg.node().getBBox(), w = sideshapegnode.width, h = sideshapegnode.height;
        let mtx = sideshapegnode.x + w / 2, mty = sideshapegnode.y + h / 2;
        sideshapetext.attr("x", (mtx)).attr("y", mty).text(mtext);
        let mtextlen = sideshapetext.node().getComputedTextLength();
        sideshapetext.attr("x", (mtx - (mtextlen / 2))).attr("y", mty).text(mtext);
        let angle1 = shape.angle;
        // console.log(index, code, mtx, mty, mtext, angle, angle1);
        sideshapetext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
    }

}
function drawsideshapepointcircle(lineindex, index, sideindex, sidecode, cx, cy, cr, edgetype) {
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    var eclass = sideedgeclass(edgetype);
    var spgindex = sideindex + "" + index + "" + sidecode;
    var sideshapeg = sideshapesg.select("#sideshapeg" + spgindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", "sideshapeg" + spgindex); }
    var splindex = spgindex + "" + lineindex;
    var canglecircle = sideshapeg.select("#canglecircle" + splindex);
    if (canglecircle.empty()) { canglecircle = sideshapeg.append("circle").attr("id", "canglecircle" + splindex); }
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr)
    .attr("class", 'sideshape').attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).call(sideshapedrag);
}
function sideshapedragstarted() {   
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecorner');        
        bdrag = true;
        drawlogservice.beforeupdate(shape, 'sideshapedragstarted', 5);
    }
}
function sideshapedragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));        
        let sideshape = shape.sides[sideindex].sideshapes[index];
        this.x = this.x || sideshape.x;
        this.y = this.y || sideshape.y;
        this.x += d3.event.dx;
        this.y += d3.event.dy;
        onsetsideshape1(this.x, this.y, index, sideindex, sidecode,'sideshapedragged');
    }
}
function sideshapedragended() {
    if (bdrag) {
        bdrag = false;
        ActionUpdateShape('sideshapedragended');
        drawlogservice.update(shape, 'sideshapedragended', 5);
    }
}
function showsideshapeside() {   
    if (drawmode == 4 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
    }
}
function hidesideshapeside() {
    //var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    //d3.select(this).attr("class", sideedgeclass(edgetype));
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", "15");
}
function showarcsideshapeside() {
    if (drawmode == 4 || drawmode == 5) {//splash/edge mode    
        d3.select(this).attr("class", "shapesideblue");
    }
}
function hidearcsideshapeside() {
    var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    d3.select(this).attr("class", sideedgeclass(edgetype));
}
function getshapesideshapepath32(index, sideindex) {
    let source = 'drawsideshape';
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sidecode = sideshape.sidecode, sideedges = sideshape.edges, type = sideshape.type, typeid = sideshape.typeid, sw = sideshape.w, sh = sideshape.h;
    let spath = '';
    if (sideshape != undefined) {
        if (sideshape.sx1 == undefined) { setsideshape(0, 0, index, sideindex, sideshape.sidecode); }
        let sx1 = sideshape.sx1, sy1 = sideshape.sy1, sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12,
        sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22;
        //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
        let edge1type = sideedges[0].type, edge2type = sideedges[1].type, edge3type = sideedges[2].type, edge4type = sideedges[3].type;
        if (shape.mode == 'slabpart') {
            let npt = {};
            if (sidecode == 1 || sidecode == 2) { npt = setsideshapeseampos31(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
            else { npt = setsideshapeseampos32(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                if (npt.seamsplit == 1) {
                    if (typeid == 3) { edge3type = sideedges[0].type; }
                    if (npt.seamline == 0) {
                        let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                        spath = quadraticcurvesplitpath32(sx11, sy11, rx, ry, sx12, sy12, npt.sx12, npt.sy12, 0, npt.tfact, sw, 'drawsideshapearcline1');                                            
                    } else {
                        let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                        spath = quadraticcurvesplitpath32(sx11, sy11, rx, ry, sx12, sy12, npt.sx11, npt.sy11, npt.tfact, 1, sw, 'drawsideshapearcline1');
                    }

                } else {
                    let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                    spath = quadraticcurvepath(sx11, sy11, rx, ry, sx12, sy12);                    
                }
            } else {
                sx11 = npt.sx11, sy11 = npt.sy11, sx12 = npt.sx12, sy12 = npt.sy12, sx21 = npt.sx21, sy21 = npt.sy21, sx22 = npt.sx22, sy22 = npt.sy22;
                spath = "M" + sx11 + "," + sy11;
                spath += " l" + (sx21 - sx11) + "," + (sy21 - sy11);
                spath += " l" + (sx22 - sx21) + "," + (sy22 - sy21);
                spath += " l" + (sx12 - sx22) + "," + (sy12 - sy22);
            }
        } else {
            if (typeid == 3 || typeid == 6 || typeid == 11) {
                let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
                spath = quadraticcurvepath(sx11, sy11, rx, ry, sx12, sy12);
            } else {
                spath = "M" + sx11 + "," + sy11;
                spath += " l" + (sx21 - sx11) + "," + (sy21 - sy11);
                spath += " l" + (sx22 - sx21) + "," + (sy22 - sy21);
                spath += " l" + (sx12 - sx22) + "," + (sy12 - sy22);
            }
        }
    }
    return spath;
}