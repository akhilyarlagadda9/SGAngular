function initshapesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = {};
    sideshape.index = index, sideshape.sideindex = sideindex, sideshape.sidecode = sidecode, sideshape.type = sideshapetype, sideshape.typeid = sideshapetypeid, sideshape.angle = 45;
    sideshape.w = 136, sideshape.h = 42, sideshape.r = 42, sideshape.isactive = 1, sideshape.dw = 0, sideshape.edges = []; 
    sideshape.x = side.x11, sideshape.y = side.y11;
    if (sideshapetypeid == 2 || sideshapetypeid == 5) { sideshape.w = 2 * sideshape.w; }
    else if (sideshape.typeid == 11) {//11-full arc
        if (sidecode == 0) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
        else if (sidecode == 1) { sideshape.w = applymminchfact(side.w1, 1, 0), sideshape.h = sideshape.r = applymminchfact(side.w1, 1, 0) / 4; }
        else if (sidecode == 2) { sideshape.w = applymminchfact(side.w2, 1, 0), sideshape.h = sideshape.r = applymminchfact(side.w2, 1, 0) / 4; }
        else if (sidecode == 3) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
    }
    side.sideshapes.push(sideshape);    
}
function initsideshapeedge(index, type, typeid, text, width) {
    let edge = { index: index, type: type, typeid: typeid, text: text, width: width, height: 0 };
    return edge;
}
function setsideshapeedges(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];    
    let sedgeindex = sideedgeindex1(side, sidecode);
    let edgetype = side.edges[sedgeindex].type, edgetypeid = side.edges[sedgeindex].typeid;  
    let sideshape = side.sideshapes[index];
    let sw = applymminchfact(sideshape.w, 2, 2, ''), sh = applymminchfact(sideshape.h, 2, 2, '');
    sideshape.edges = [];
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, 'W', -1, edgetype, sw));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sh));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sw));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype, sh));
}
function setsideshape(x, y, index, sideindex, sidecode) {   
    let side = shape.sides[sideindex];    
    if (index == -1) { index = side.sideshapes.length, initshapesideshape(index, sideindex, sidecode); }
    let sideshape = side.sideshapes[index], type = sideshape.type, typeid = sideshape.typeid;
    if (sideshape != undefined) {      
        if (sideshape.index != index) { sideshape.index = index; } //reindex 
        if (x != 0 && y != 0) { setsideshapecoords(x, y, index, sideindex, sidecode); }
    }
    //old- type - 1- Bump out angle, 2- Bump in Angle, 3- Full Arc, 4- Bump Out Arc, 7- Bump in Arc, 5- Bump in, 6- Bump out;
    //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
    //console.log(x, y, index, sideindex, sidecode, type, typeid);
    if (typeid > 11 || typeid==undefined) {//reset typeids;add vflag.
        if (type == 1) { typeid = 5; } else if (type == 2) { typeid = 2; } else if (type == 3) { typeid = 11; }
        else if (type == 4) { typeid = 6; } else if (type == 5) { typeid = 1; } else if (type == 6) { typeid = 4; }
        else if (type == 7) { typeid = 3; }
        if (sideshape.typeid == undefined) { sideshape.type = 0; } else { sideshape.type = sideshape.typeid;}
        sideshape.typeid = typeid, type = sideshape.type;
    }
    //console.log(x, y, index, sideindex, sidecode, type, typeid);
    if (sideshape.dw == undefined) { setsideshapecoords(0, 0, index, sideindex, sidecode); }   
    if (typeid == 3 || typeid == 6 || typeid == 11) {setarcsideshape(index, sideindex, sidecode);
    } else if (typeid == 1 || typeid == 4) { setbumpinoutsideshape(index, sideindex, sidecode); }
    else if (typeid == 5) { setbumpoutanglesideshape(index, sideindex, sidecode); }
    else if (typeid == 2) { setbumpinanglesideshape(index, sideindex, sidecode); }    
    return index;
}
function setsideshapecoords(x, y, index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, x, y);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let angle1 = calclineangle2(sx1, sy1, sx11, sy11);
        if (Math.abs(angle - angle1) > 10) { sx11 = sx1, sy11 = sy1; }       
        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let angle2 = calclineangle2(sx12, sy12, sx2, sy2);
        if (Math.abs(angle - angle2) > 10){
            sx12 = sx2, sy12 = sy2;
            let npt3 = rotate_point1(sx12, sy12, -1, angle + 180, sw); //first point on side
            sx11 = npt3.dx, sy11 = npt3.dy;
        }
        dw = calchyplen(sx11, sy11, sx12, sy12);       
        sideshape.x = sx11, sideshape.y = sy11, sideshape.dw = dw;
    }
}
function setbumpinoutsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (typeid == 1) { sh = -sh; } //1- Bump in, 4- Bump Out
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side
        
        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;
        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;      
    }
}
function setbumpoutanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let opt1 = offsetline(sx11, sy11, sx12, sy12, sh);        
        if (sidecode == 0) { angle1 = angle - sideangle, angle2 = angle - sideangle + 90; sh = -sh; }
        else if (sidecode == 1) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 270 + sideangle, angle2 = angle + 180 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }

        //console.log(index, sideindex, sidecode, angle, angle1, angle2);

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;
                
        let ipt1 = calintersection1(sx11, sy11, sx21, sy21, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //hyp length       
        let ipt2 = calintersection1(sx12, sy12, sx22, sy22, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //

        sx21 = ipt1.dx, sy21 = ipt1.dy, sx22 = ipt2.dx, sy22 = ipt2.dy;
             
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;      

    }
}
function setbumpinanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; sh = -sh; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; sh = -sh; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let opt1 = offsetline(sx11, sy11, sx12, sy12, sh);

        if (sidecode == 0) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 1) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 180 + sideangle, angle2 = angle + 270 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;

        let ipt1 = calintersection1(sx11, sy11, sx21, sy21, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //hyp length       
        let ipt2 = calintersection1(sx12, sy12, sx22, sy22, opt1.dx1, opt1.dy1, opt1.dx2, opt1.dy2); //

        sx21 = ipt1.dx, sy21 = ipt1.dy, sx22 = ipt2.dx, sy22 = ipt2.dy;

        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;       
    }
}
function setarcsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, typeid = sideshape.typeid, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (typeid == 3) { sh = -sh; }//3- Bump in Arc, 6- Bump out Arc, 11- Full Arc
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;
        sh = 2 * sh;
        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;
        sideshape.sx1 = sx1, sideshape.sy1 = sy1;
        sideshape.x11 = sx11, sideshape.y11 = sy11, sideshape.x12 = sx12, sideshape.y12 = sy12,
        sideshape.x21 = sx21, sideshape.y21 = sy21, sideshape.x22 = sx22, sideshape.y22 = sy22;        
    }
}
function setsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid, source) {    
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    if (sideshape != undefined) {
        let sideshapeedge = sideshape.edges[lnindex], sw = applymminchfact(sideshape.w, 2, 2, ''), sh = applymminchfact(sideshape.h, 2, 2, '');
        sidecode = sideshape.sidecode;
        if (edgetype != '') { sideshapeedge.type = edgetype; }
        if (edgetypeid != -1) { sideshapeedge.typeid = edgetypeid; }
        if (lnindex == 0 || lnindex == 2) { sideshapeedge.width = sw; } else { sideshapeedge.width = sh; }
        let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;
        let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);        
        //console.log('lnindex:' + lnindex, 'index:' + index, 'sideindex:' + sideindex, 'edgetype:' + edgetype, 'edgetypeid:' + edgetypeid,
        //    'sideshapeindex:' + shape.mode + "sideshapeg" + sideshapeindex, 
        //    "sw:" + sw, "sh:" + sh, "sideshapeg" + sideshapeindex, 'sideshapeg:' + sideshapeg.empty(), source);
    }
}
function setsideshapeedges1(index, sideindex, edgetype, edgetypeid, source) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    setsideshapeedge1(1, index, sideindex, edgetype, edgetypeid, source);
    setsideshapeedge1(2, index, sideindex, edgetype, edgetypeid, source);
    setsideshapeedge1(3, index, sideindex, edgetype, edgetypeid, source);
}
function onsetsideshape(x, y, index, sideindex, sidecode, source) {
   // console.log(x, y, index, sideindex, sidecode, source);
    source = source + ':onsetsideshape';    
    index = setsideshape(x, y, index, sideindex, sidecode);
    setsideshapeedges(index, sideindex, sidecode);
    drawsideshape32(index, sideindex, source);
    drawshapeside32(sideindex, source);
    onsetsidesplash1(sideindex, sidecode, 1, source);
    onsetsideseams32(sideindex, source);
    ActionSideShape(source);    
}
function onsetsideshape1(x, y, index, sideindex, sidecode, source) {
    source += ':onsetsideshape1';
    setsideshape(x, y, index, sideindex, sidecode);
    drawsideshape32(index, sideindex, source);
    onsetsidesplash1(sideindex, sidecode, 1, source);
    onsetsideseams32(sideindex, source);
    drawshapeside32(sideindex, source);
}
function setsideshapesedges(sideindex, sidecode, type, typeid, source) {
    source += ':setsideshapesedges';
    //console.log(sideindex, sidecode, type, typeid);
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].sidecode == sidecode && side.sideshapes[i].isactive==1) {
            setsideshapeedges1(i, sideindex, type, typeid, source);
            drawsideshape32(i, sideindex, source);
        }
    }
}
function onsetsideshapeedges1(index, sideindex, edgetype, edgetypeid, source) {
    source += ':onsetsideshapeedges1';
    //console.log('index:' + index, 'sideindex:' + sideindex, 'edgetype:' + edgetype, 'edgetypeid:' + edgetypeid);
    setsideshapeedges1(index, sideindex, edgetype, edgetypeid, source);
    drawsideshape32(index, sideindex, source);
    ActionSideShape(source);
}
function onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid, source) {
    source += ':onsetsideshapeedge1';
    setsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid);
    drawsideshape32(index, sideindex, source);
    ActionSideShape(source);
}
function onsideshapecontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode != 'print') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onsideshapecontextmenu');
        drawsideshapecontrols(index, sideindex, sidecode, m[0], m[1]);
    }
}
function onresizesideshape(obj, type, index, sideindex) {
    let source = 'onresizesideshape';    
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    let sidecode = sideshape.sidecode, typeid = sideshape.typeid, sw = sideshape.w, sh = sideshape.h;
    let objVal = obj.value.split(" ");
    let swh = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    let isvalid = true;
    if (isNaN(swh) || swh < minwh) { isvalid = false; }
    let swhfact = 0;
    if (typeid == 2 || typeid == 5) {
        if (type == 0) { swhfact = roundToOne(sh / applymminchfact(swh, 1, 2)); }
        else if (type == 1) { swhfact = roundToOne(applymminchfact(swh, 1, 2) / sw); }
        if (swhfact >= 0.5) { isvalid = false; }      
    }  
    if (isvalid > 0) {
        if (type == 0) { sideshape.w = applymminchfact(swh, 1, 2); }
        else if (type == 1) { sideshape.h = applymminchfact(swh, 1, 2); }
        else if (type == 2) { sideshape.angle = swh; }
        setsideshape(0, 0, index, sideindex, sidecode);
        setsideshapeedges1(index, sideindex, "", -1, source);
        drawsideshape32(index, sideindex, source);
        onsetsidesplash1(sideindex, sidecode, 1, source);
        onsetsideseams32(sideindex, source);
        drawshapeside32(sideindex, source);
        ActionSideShape(source);       
    }
}
function validatesideshapechange() {
    
}
function ondeletesideshape(index, sideindex) {
    let source = 'ondeleteshapesideshape';
    if (sideshapesg != undefined) {       
        let side = shape.sides[sideindex];
        let sideshape = side.sideshapes[index];
        let sidecode = sideshape.sidecode;
        sideshape.isactive = 0;
        let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
        let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;
        $("#" + shape.mode + "sideshapeg" + sideshapeindex).remove();
        //let splindex = sidesplashactiveindex(side, sidecode, 1);
        //let sidesplash = side.splashs[splindex];
        deletesideshapesplashs(index, sideindex, sidecode, 1)
        //onsetsidesplash34(sideindex, sidecode, sidesplash.type, sidesplash.height, sidesplash.spltype, source);
        onsetsideseams32(sideindex, source);
        drawshapeside32(sideindex, source);
        ActionSideShape(source);            
    }
    removeshapetools();
}
function onsideshapeside() {
    let source = 'onsideshapeside';
    let mode = this.getAttribute("smode");  
    if (mode == 'shape') {
        let lnindex = parseInt(this.getAttribute("lnindex"));
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));      
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onsideshapeside');
        if (drawmode == 4) {           
            onsetsideshapesplash(lnindex, index, sideindex, sidecode, edgetype, edgetypeid, 3);
        } else if (drawmode == 5) {
            onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid, source);
        }
    }
}
function onsideshape() {
    let source = 'onsideshape';
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {       
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onsideshape');
        if (drawmode == 5) {
            onsetsideshapeedges1(index, sideindex, edgetype, edgetypeid, source);
        }
    }
}
function resetshapesideshapes(source) {
    for (let i = 0; j < shape.sides.length; i++) {
        resetsideshapes(i, source)
    }
}
function resetsideshapes(index, source) {
    source =  source + ':resetsideshapes';
    let side = shape.sides[index];
    for (let j = 0; j < side.sideshapes.length; j++) {
        if (side.sideshapes[j].isactive == 1) {
            onsetsideshape1(0, 0, j, index, side.sideshapes[j].sidecode, source);
        }
    }
}
function getsideshapecoords32(sideshape, side) {
    let index = sideshape.index, sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22, typeid = sideshape.typeid,
        sidecode = sideshape.sidecode, sw = sideshape.w, spsideindex = side.spsideindex, startsideindex = shape.startsideindex, startseamindex = shape.startseamindex, endsideindex = shape.endsideindex, endseamindex = shape.endseamindex;
    if (shape.mode == 'slabpart') {
        if ((startseamindex != -1 && startsideindex == spsideindex) || (endseamindex != -1 && endsideindex == spsideindex)) {//seamsplit == true             
            if (sideshape.smx11 != 0) { sx11 = sideshape.smx11, sy11 = sideshape.smy11, sx21 = sideshape.smx21, sy21 = sideshape.smy21; }
            if (sideshape.smx12 != 0) { sx12 = sideshape.smx12, sy12 = sideshape.smy12, sx22 = sideshape.smx22, sy22 = sideshape.smy22; }            
        } 
    }
    return {
        x11: Math.round(sx11), y11: Math.round(sy11), x12: Math.round(sx12), y12: Math.round(sy12), x21: Math.round(sx21), y21: Math.round(sy21),
        x22: Math.round(sx22), y22: Math.round(sy22)
    };
}
function sortsidecodesideshapes32(sidecode, sideindex, sideshapes) {
    let sidecodesideshapes = sideshapes.filter(sideshape => sideshape.sidecode == sidecode && sideshape.isactive == 1 && sideshape.sideindex == sideindex);
    return sidecodesideshapes.sort((a, b) => (a.dw > b.dw) ? 1 : -1);
}
function getstartsideshapebyseamindex(sidecode, startseamindex, sidecodesideshapes) {   
    for (let j = 0; j < sidecodesideshapes.length; j++) {        
        if (sidecodesideshapes[j].startseamindex == startseamindex) {return j;}
    }
    return -1;
}
function getendsideshapebyseamindex(sidecode, endseamindex, sidecodesideshapes) {
    for (let j = 0; j < sidecodesideshapes.length; j++) {       
        if (sidecodesideshapes[j].endseamindex == endseamindex) {return j;}
    }
    return -1;
}
function drawsideshapes(index, source) {
    source += ':drawsideshapes';
    let side = shape.sides[index];
    //console.log(shape.index, index, shape.mode, side.sideshapes.length);
    for (let j = 0; j < side.sideshapes.length; j++) {
     //   console.log(shape.index, shape.mode,side.sideshapes[j].isactive, side.sideshapes.length);
        if (side.sideshapes[j].isactive == 1) {           
            drawsideshape32(j, index, side.sideshapes[j].type, source);
        }
    }
}
function drawsideshape32(index, sideindex, source) {
    source += ':drawsideshape32';  
    let side = shape.sides[sideindex];  
    let sideshape = side.sideshapes[index];
    if (sideshape.isactive == 0) { return; }
    //console.log(index, sideindex, sideshape.isactive, source);
    let sidecode = sideshape.sidecode, sideedges = sideshape.edges, type = sideshape.type, typeid = sideshape.typeid, sw = sideshape.w, sh = sideshape.h, seamsplit = 0,
      spsideindex = side.spsideindex, startsideindex = shape.startsideindex, startseamindex = shape.startseamindex, endsideindex = shape.endsideindex, endseamindex = shape.endseamindex;
 
    if (sideshape != undefined) {       
        if (sideshape.sx1 == undefined) { setsideshape(0, 0, index, spsideindex, sideshape.sidecode); }
        let sx1 = sideshape.sx1, sy1 = sideshape.sy1, sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12,
        sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22;
        //1- Bump in, 2- Bump in Angle, 3- Bump in Arc, 4- Bump Out,5- Bump out Angle, 6- Bump out Arc, 11- Full Arc
        let edge1type = sideshape.edges[0].type, edge2type = sideshape.edges[1].type, edge3type = sideshape.edges[2].type, edge4type = sideshape.edges[3].type;
        if (typeid == 3 || typeid == 6 || typeid == 11) {
            let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
            drawsideshapearcline(1, index, typeid, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, edge2type);          
            let mtext = decimaltofraction(applymminchfact(sw, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(sh, 2, 2, source));
            if (typeid == 11) { mtext = "R " + decimaltofraction(applymminchfact(sh, 2, 2, source)); }
            drawsideshapemarkertext(index, sideindex, sidecode, mtext);
        } else {
            drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edge2type);
            drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edge3type);
            drawsideshapeline(3, index, sideindex, sidecode, sx22, sy22, sx12, sy12, edge4type);
            drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
            let mtext = decimaltofraction(applymminchfact(sw, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(sh, 2, 2, source));
            drawsideshapemarkertext(index, sideindex, sidecode, mtext);
        }
    }
}
function drawsideshapeline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;     
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = sideshapeindex + "" + lnindex;
    let sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "sideshape" + sslineindex); }
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (etypes[1] != undefined) { sideshapeline.attr("style", "stroke:" + etypes[1]); }
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype, drawmode);
    if (shape.mode == 'shape') {
       // if (lnindex == 2) {
            sideshapeline.on("click", onsideshapeside).on("mouseover", showsideshapeside).on("mouseout", hidesideshapeside);
            let sideshapebandline = sideshapeg.select("#sideshapeband" + sslineindex);
            if (sideshapebandline.empty()) { sideshapebandline = sideshapeg.append("line").attr("id", "sideshapeband" + sslineindex); }
            sideshapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
            .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
            sideshapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", "15");
            sideshapebandline.on("click", onsideshapeside).on("mouseover", showsideshapeside).on("mouseout", hidesideshapeside);
     //   }
    }
}
function drawsideshapearcline(lnindex, index, typeid, sideindex, sidecode, x1, y1, x2, y2, x3, y3, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;    
    let sspath = quadraticcurvepath(x1, y1, x2, y2, x3, y3);
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    //console.log('lnindex:' + lnindex, 'index:' + index, 'sideindex:' + sideindex, 'edgetype:' + edgetype, 'edgetypeid:' + edgetypeid, 'sideshapeindex:' + "#" + shape.mode + "sideshapeg" + sideshapeindex, 'sideshapeg:' + sideshapeg.empty())
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = sideshapeindex + "" + lnindex;
    let sideshapepath = sideshapeg.select("#" + smode + "sideshapepath" + sslineindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", smode + "sideshapepath" + sslineindex); }
    sideshapepath.attr("d", sspath).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
        .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    sideshapepath.on("click", onsideshape).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside);
    if (shape.mode == 'shape') { sideshapepath.on("contextmenu", onsideshapecontextmenu); if (typeid != 11) { sideshapepath.call(sideshapedrag); } }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (etypes[1] != undefined) { sideshapepath.style("stroke", etypes[1]); }
}
function drawsideshapearcline1(lnindex, index, typeid, sideindex, sidecode, x1, y1, x2, y2, x3, y3, smx1, smy1, smx2, smy2, t1, t2, sw, edgetype) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index; 
    let sspath = quadraticcurvesplitpath32(x1, y1, x2, y2, x3, y3, smx1, smy1, smx2, smy2, t1, t2, sw, typeid, 'drawsideshapearcline1');
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sslineindex = sideshapeindex + "" + lnindex;
    let sideshapepath = sideshapeg.select("#" + smode + "sideshapepath" + sslineindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", smode + "sideshapepath" + sslineindex); }
    sideshapepath.attr("d", sspath).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
        .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    sideshapepath.on("click", onsideshape).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside);
    if (shape.mode == 'shape') {sideshapepath.on("contextmenu", onsideshapecontextmenu); if (typeid != 11) { sideshapepath.call(sideshapedrag); } } 
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (etypes[1] != undefined) { sideshapepath.style("stroke", etypes[1]); }
}
function drawsideshapepath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, typeid) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = 'sideshape';
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;    
    let sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sideshapepath = sideshapeg.select("#" + smode +  "sideshapepath" + sideshapeindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", smode + "sideshapepath" + sideshapeindex); }
    sideshapepath.attr("d", sspath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("class", eclass)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu).on("click", onsideshape);
        if (typeid != 11) { sideshapepath.call(sideshapedrag); }
    } 
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2").style("display", "block");
}
function drawsideshapepath1(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, typeid) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = 'sideshape';
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;
    let sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath +=  "l" + (x21 - x12) + "," + (y21 - y12) + "z";
    let sideshapeg = sideshapesg.select("#" + smode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", smode + "sideshapeg" + sideshapeindex); }
    let sideshapepath = sideshapeg.select("#" + smode +  "sideshapepath" + sideshapeindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", smode + "sideshapepath" + sideshapeindex); }
    sideshapepath.attr("d", sspath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("class", eclass)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu);
        if (typeid != 11) { sideshapepath.call(sideshapedrag); }
    }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2").style("display", "block");
}
function drawsideshapemarkertext(index, sideindex, sidecode, mtext) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index; 
    let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);    
    let sideshapetext = sideshapeg.select("#" + smode + "sideshapetext" + sideshapeindex);
    if (sideshapetext.empty()) {
        sideshapetext = sideshapeg.append("text").attr("id", smode + "sideshapetext" + sideshapeindex)
            .attr("style", "fill:black;text-anchor:middle;alignment-baseline:ideographic;font-size:10px;");
    }
    if (sideshapeg.node() != null) {
        let sideshapegnode = sideshapeg.node().getBBox(), w = sideshapegnode.width, h = sideshapegnode.height;
        let mtx = sideshapegnode.x + w / 2, mty = sideshapegnode.y + h / 2;
        sideshapetext.attr("x", (mtx)).attr("y", mty).text(mtext);
        let mtextlen = sideshapetext.node().getComputedTextLength();
        sideshapetext.attr("x", (mtx - (mtextlen / 2))).attr("y", mty).text(mtext);
        let angle1 = shape.angle;
        // console.log(index, code, mtx, mty, mtext, angle, angle1);
        sideshapetext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
    }

}
function drawsideshapepointcircle(lineindex, index, sideindex, sidecode, cx, cy, cr, edgetype) {
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    var eclass = sideedgeclass(edgetype);
    var spgindex = sideindex + "" + index + "" + sidecode;
    var sideshapeg = sideshapesg.select("#sideshapeg" + spgindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", "sideshapeg" + spgindex); }
    var splindex = spgindex + "" + lineindex;
    var canglecircle = sideshapeg.select("#canglecircle" + splindex);
    if (canglecircle.empty()) { canglecircle = sideshapeg.append("circle").attr("id", "canglecircle" + splindex); }
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr)
    .attr("class", 'sideshape').attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).call(sideshapedrag);
}
function sideshapedragstarted() {   
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecorner');        
        bdrag = true;        
    }
}
function sideshapedragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));        
        let sideshape = shape.sides[sideindex].sideshapes[index];
        //console.log(index, sideindex, sidecode);
        if (sideshape != undefined) {
            this.x = this.x || sideshape.x;
            this.y = this.y || sideshape.y;
            this.x += d3.event.dx;
            this.y += d3.event.dy;
            onsetsideshape1(this.x, this.y, index, sideindex, sidecode, 'sideshapedragged');
        }
    }
}
function sideshapedragended() {
    if (bdrag) {
        bdrag = false;
        ActionUpdateShape('sideshapedragended');       
    }
}
function showsideshapeside() {   
    if (drawmode == 4 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15").style("cursor", "crosshair");
    }
}
function hidesideshapeside() {
    //var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    //d3.select(this).attr("class", sideedgeclass(edgetype));
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", "15");
}
function showarcsideshapeside() {
    if (drawmode == 4 || drawmode == 5) {//splash/edge mode    
        d3.select(this).attr("class", "shapesideblue");
    }
}
function hidearcsideshapeside() {
    var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    d3.select(this).attr("class", sideedgeclass(edgetype));
}