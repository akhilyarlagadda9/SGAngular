function initsidesplash(index, sidesegindex, sideindex, lnindex, cornerindex, sidecode, type, height, spltype) {
    let side = shape.sides[sideindex];
    let splash = {
        index: index, sidesegindex: sidesegindex, sideindex: sideindex, lnindex: lnindex, cornerindex: cornerindex, angle: 0, sidecode: sidecode, width: 0, height: height, isactive: 1, type: type, split: 0, spltype: spltype, typeid: edgetypeid,
        x: 0, y: 0, tx: 0, ty: 0, x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, edges: [], sideshapes: [], seams: [], slabsplashs:[]
    };
    sidesplashedges(splash, sidecode, 'initsidesplash');
    side.splashs.push(splash);
}
function sidesplashindex(side, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function sideccornersplashindex(side, sidecode, lnindex, cornerindex, type) {
    let splashindex = -1;   
    for (let i = 0; i < side.splashs.length; i++) {      
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].lnindex == lnindex && side.splashs[i].cornerindex == cornerindex && side.splashs[i].type == type) {
            splashindex = i, side.splashs[i].isactive = 1; break;
        }
    }
    return splashindex;
}
function sidesegsplashindex(side, sidesegindex, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidesegindex == undefined) { side.splashs[i].sidesegindex = sidesegindex;}
        //console.log("splashindex:" + i, "sidecode:" + side.splashs[i].sidecode + "=" + sidecode, "sidesegindex:" + side.splashs[i].sidesegindex + "=" + sidesegindex, "type:" + side.splashs[i].type + "=" + type);
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].sidesegindex == sidesegindex && side.splashs[i].type == type) {
            splashindex = i, side.splashs[i].isactive = 1; break;
        }
    }
    return splashindex;
}
function sidesplashactiveindex(side, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type && side.splashs[i].isactive == 1) { splashindex = i; break; }
    }
    return splashindex;
}
function sideshapesplashindex(side, sideshapeindex, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].cornerindex == sideshapeindex && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function resetshapesplashs(source) {
    for (let j = 0; j < shape.sides.length; j++) {
        onsetsidesplashs(j, source);
    }
}
function onsetsidesplashs(sideindex, source) {
    source = source + ':onsetsidesplashs';
    if (sideindex == 0) { onsetsidesplash1(sideindex, 0, 1, source); }
    onsetsidesplash1(sideindex, 1, 1, source);
    onsetsidesplash1(sideindex, 2, 1, source);
    if (sideindex == shape.sides.length - 1) { onsetsidesplash1(sideindex, 3, 1, source); }
}
function onsetsidesplash1(sideindex, sidecode, type, source) {
    source += ':onsetsidesplash1';
    let side = shape.sides[sideindex];
    let splindex = sidesplashactiveindex(side, sidecode, 1);
    if (splindex != -1) {
        onsetsidesplash34(sideindex, sidecode, type, side.splashs[splindex].height, side.splashs[splindex].spltype, source);
    }
}
function onsetsidesplash2(sideindex, sidecode, type, source) {
    source += ':onsetsidesplash2';
    let side = shape.sides[sideindex];
    let splindex = sidesplashactiveindex(side, sidecode, 1);
    if (splindex != -1) {
        //console.log(sideindex, sidecode, type, source);
        deletesidesplashs(sideindex, sidecode, type);       
    }
}
function onsetsidesplash34(sideindex, sidecode, type, height, spltype, source) {
    source += ':onsetsidesplash34';
    deletesidesplashs(sideindex, sidecode, type);    
    setsidesplash(-1, sideindex, sidecode, height, type, spltype, source);    
}

function onsetsidesplash(sideindex, sidecode, type, height, spltype, source) {
    deletesidesplashs(sideindex, sidecode, type);
    //setsidesegs(sideindex, sidecode);
   //if (spltype == undefined) { spltype = type;}
    setsidesplash(-1, sideindex, sidecode, height, type, spltype, source);
    setsideedge1(sideindex, sidecode, edgetype, 0, source);
    setsideshapesedges(sideindex, sidecode, 'U', 0, source);
    ActionSplash(source);  
}
function onsetsideapron(sideindex, sidecode, type, edgetype, edgetypeid, height, countersidemode) {
    let source = 'onsetsideapron';  
    deletesidesplashs(sideindex, sidecode, type);
    setsidesegs(sideindex, sidecode);
    setsidesplash(-1, sideindex, sidecode, height, type, countersidemode, source);
    setsideedge1(sideindex, sidecode, edgetype, edgetypeid, source);
    setsideshapesedges(sideindex, sidecode, edgetype, edgetypeid, source);
    ActionApron(source);  
}
function onresizesidesplash(obj, type, index, sideindex, sidecode) {
    //console.log("type:" + type, "index:" + index, "sideindex:" + sideindex, "sidecode:" + sidecode);
    let source = 'onresizesidesplash';
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], spltype = splash.type, spltype1 = splash.spltype;
    var objVal = obj.value.split(" ");
    var parseVal = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));    
    if (parseVal > 0) {      
        splash.height = parseVal;
        if (spltype1 == undefined) { spltype1 = type; }
        //console.log(index, splash.lnindex, splash.cornerindex, sideindex, sidecode, type, spltype, spltype1, parseVal);
        if (spltype == 1) { setsidesplash(index, sideindex, sidecode, parseVal, spltype, spltype1, source); }
        else if (spltype == 2) { setcornersplash(index, splash.lnindex, splash.cornerindex, sideindex, sidecode, spltype, parseVal, source);}
        else if (spltype == 3) { setsideshapesplash(splash.lnindex, index, sideindex, sidecode, spltype, parseVal, source); }
        ActionSplash(source);        
    }
}
function setsidesplash(index, sideindex, sidecode, height, type, spltype, source) {   
    let side = shape.sides[sideindex];
    if (side != undefined) {
        if (side.sidesegs == undefined) { setsidesegs(sideindex, sidecode); }  
        let sidecodeseg = side.sidesegs[sidecode];        
        for (i = 0; i < sidecodeseg.segs.length; i++) {
            //console.log("index:" + index, " sideindex:" + sideindex, " sidecode:" + sidecode, " height:" + height, " type:" + type, " spltype:" + spltype, " sw:" + sidecodeseg.segs[i].sw, " sideseglen:" + sidecodeseg.segs.length, source);           
            if (sidecodeseg.segs[i].sw > 0) {               
                index = setsidesegsplash(index, i, sideindex, sidecode, height, type, spltype);
                setsidesplashseams32(index, sideindex);
                drawsidesplashseams31(index, sideindex);
                //if (shape.mode == 'shape' && drawmode != 0) { ActionAddEdge(index); }
            }
        }
    }
}
function setsidesegsplash(index, sidesegindex, sideindex, sidecode, height, type, spltype, source) {
    source += 'setsidesegsplash';
    let side = shape.sides[sideindex];
    let splindex = sidesegsplashindex(side, sidesegindex, sidecode, type);
    if (splindex == -1) { splindex = side.splashs.length; initsidesplash(splindex, sidesegindex, sideindex, 0, 0, sidecode, type, height, spltype); } 
    let splash = side.splashs[splindex];
    //console.log("splindex:" + splindex, " index:" + index, " sidesegindex:" + sidesegindex, " sideindex:" + sideindex, " sidecode:" + sidecode, " height:" + height, " type:" + type, " spltype:" + spltype, source);
    splash.isactive = 1;
    //if (splash.typeid == undefined) { splash.typeid = 0; }
    //if (spltype == undefined) { spltype = 0; splash.spltype = spltype;}
    if (height > 0) { splash.height = height; splash.typeid = edgetypeid; splash.spltype = spltype; }
    //console.log(index, index1, sidesegindex, sideindex, sidecode, height, type, spltype, splash.typeid, source)
    setsidesegsplash1(splindex, sidesegindex, sideindex, sidecode);
    setsidesplashedgeswidth(splash);
    drawsidesplash(splindex, sideindex, source);
    return splindex;
}
function setsidesegsplash1(index, sidesegindex,  sideindex, sidecode) {
    let side = shape.sides[sideindex];
    if (side.sidesegs == undefined) { setsidesegs(sideindex, sidecode); }
    let sidecodeseg = side.sidesegs[sidecode];
    let sideseg = sidecodeseg.segs[sidesegindex];
    let splash = side.splashs[index];
    let dh = 50, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2);
    let x1 = sideseg.x1, y1 = sideseg.y1, x2 = sideseg.x2, y2 = sideseg.y2;
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0, w1 = side.w1, w2 = applymminchfact(side.w2, 1, 2);

    if (sidecode == 0) { dsign = islineinpoly3(x11, y11, x12, y12, x21, y21, x22, y22, w2); }
    else if (sidecode == 1) { dsign = islineinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, side.h); }
    else  if (sidecode == 2) { dsign = islineinpoly2(x11, y11, x12, y12, x21, y21, x22, y22, side.h); }
    else if (sidecode == 3) { dsign = islineinpoly4(x11, y11, x12, y12, x21, y21, x22, y22, w2); }

    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.width = sideseg.sw;
}
function onsetcornersplash(lnindex, cornerindex, sideindex, sidecode, edgetype, edgetypeid, type) {    
    setcornersplash(-1, lnindex,  cornerindex, sideindex, sidecode, type, splheight);
    setsidecorneredge(lnindex, cornerindex, sideindex, edgetype, edgetypeid, 0, 'onsetcornersplash');   
    ActionSplash('onsetcornersplash');  
}
function setcornersplash(index, lnindex,  cornerindex, sideindex, sidecode, type, height) {    
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    index = sideccornersplashindex(side, sidecode, lnindex, cornerindex, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, -1, sideindex, lnindex, cornerindex, sidecode, type, height);}
    let splash = side.splashs[index]; if (height > 0) { splash.height = height; }   
   // console.log(index, sidecode, lnindex, cornerindex, sideindex, sidecode);
    if (corner.type == 1) {//Clip corner     
        setcornersplash1(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);        
    } else if (corner.type == 3) {//Notch corner    
        setcornersplash2(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);  
    } else if (corner.type == 4) {//Bumpout corner       
        setcornersplash2(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);
    }
    setsidesplashedgeswidth(splash);
    //ActionAddEdge(index);    
}
function setcornersplash1(index, lnindex, cornerindex, sideindex) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    let splash = side.splashs[index];
    let x1 = corner.x2, y1 = corner.y2, x2 = corner.x3, y2 = corner.y3, x3 = corner.x1, y3 = corner.y1, sidecode = corner.sidecode, cw = corner.w;
    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = applymminchfact(side.w1, 1, 2), w2 = applymminchfact(side.w2, 1, 2);

    dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x1, y1, x2, y2, cw);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;
    w = Math.round(calchyplen(x1, y1, x2, y2));
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(cw, 2, 2);
}
function setcornersplash2(index, lnindex, cornerindex, sideindex) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    let splash = side.splashs[index];
    let x1 = corner.x2, y1 = corner.y2, x2 = corner.x3, y2 = corner.y3, x3 = corner.x1, y3 = corner.y1, sidecode = corner.sidecode, cw = corner.w;
    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = applymminchfact(side.w1, 1, 2), w2 = applymminchfact(side.w2, 1, 2);
    if (lnindex == 2) { x1 = x2, y1 = y2; }     
    dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x1, y1, x3, y3, cw);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x3, y3);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x3, y3);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x3 + dx1, y12 = y3 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x3 + dx2, y22 = y3 + dy2;
    w = Math.round(calchyplen(x1, y1, x3, y3));
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(cw, 2, 2);
}
function onsetsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, edgetype, edgetypeid, type) {
    let source = 'onsetsideshapesplash';
    setsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, type, splheight, source);
    setsideshapeedge1(2, sideshapeindex, sideindex, 'U', 0);   
    ActionSplash(source);     
}
function setsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, type, height, source) {
    source += ':setsideshapesplash';
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[sideshapeindex];    
    let index = sideccornersplashindex(side, sidecode, lnindex, sideshapeindex, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, -1, sideindex, lnindex, sideshapeindex, sidecode, type, height); }
    let splash = side.splashs[index]; if (height > 0) { splash.height = height; }
    //console.log("lnindex:" + lnindex, "sideshapeindex:" + sideshapeindex, "sideindex:" + sideindex, "sidecode:" + sidecode, "type:" + type, "height:" + height, source);
    setsideshapesplash1(index, lnindex, sideshapeindex, sideindex, source);
    drawsidesplash(index, sideindex, source);
    //ActionAddEdge(index);
}
function setsideshapesplash1(index, lnindex, sideshapeindex, sideindex, source) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[sideshapeindex];
    let splash = side.splashs[index];     
    let x1 = sideshape.x21, y1 = sideshape.y21, x2 = sideshape.x22, y2 = sideshape.y22, sidecode = sideshape.sidecode;
    let x11 = sideshape.x11, y11 = sideshape.y11, x12 = sideshape.x12, y12 = sideshape.y12, x21 = sideshape.x21, y21 = sideshape.y21, x22 = sideshape.x22, y22 = sideshape.y22, sw = sideshape.w;

    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    dsign = ispointinpoly1(x21, y21, x22, y22, x11, y11, x12, y12, x1, y1, x2, y2, height);

    if (height > sideshape.h) { dsign = ispointinpoly1(side.x11, side.y11, side.x12, side.y12, side.x21, side.y21, side.x22, side.y22, x1, y1, x2, y2, height); }
    //console.log("index:" + index, "lnindex:" + lnindex, "sideshapeindex:" + sideshapeindex, "sideindex:" + sideindex, "height:" + height, "sideshapeh:" + sideshape.h, source);
   
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);

    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;
     
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(sw, 2, 2);
}
function onshapesplashside() {
    let m = d3.mouse(this);
    let mode = this.getAttribute("smode");
    let splashsidecode = parseInt(this.getAttribute("lineindex"));
    let splashindex = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesplashside');
    if (drawmode == 3) {
      //  onsetsplashsideshape(m[0], m[1], -1, splashindex, sideindex, splashsidecode);
    } else if (drawmode == 5) {
        onsetsplashsideedge(splashsidecode, splashindex, sideindex, sidecode);
    }
}
function onshapesidesplash() {
    removeshapetools();
    d3.event.stopPropagation();
    let m = d3.mouse(this);
    let mode = this.getAttribute("smode");   
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));   
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidesplash');
    
}
function onshapesplashcontextmenu() {
    d3.event.preventDefault();
    let m = d3.mouse(this);  
    let mode = this.getAttribute("smode");
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));   
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    //console.log(index, mode, sideindex, sidecode);
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesplashcontextmenu');
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], w = splash.width, h = splash.height, spltype = splash.type;
    drawshapesidesplashcontrols(index, sideindex, sidecode, w, h, m[0], m[1], spltype);
}
function ondeleteshapesidesplash(index, sideindex, sidecode) {   
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let spltype = splash.type;  
    if (spltype == 1) { deletesidesplashs(sideindex, sidecode, 1); }
    else { deletesidesplash(index, sideindex, sidecode); }    
    ActionSplash('ondeleteshapesidesplash');
    removeshapetools(); 
}
function ondeleteshapesidesplash1(index, sideindex, sidecode) {    
    let side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    deletesidesplash(index, sideindex, sidecode); 
}
function deletesidesplashs(sideindex, sidecode, type) {   
    let side = shape.sides[sideindex];
    for (i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].isactive == 1 && side.splashs[i].type == type) {
            deletesidesplash(i, sideindex, sidecode);            
        }       
    }  
}
function deletesideshapesplashs(sideshapeindex, sideindex, sidecode, type) {   
    let side = shape.sides[sideindex];    
    for (let i = 0; i < side.splashs.length; i++) {
        //console.log("sideshapeindex:" + side.splashs[i].cornerindex + "=" + sideshapeindex, "sidecode:" + side.splashs[i].sidecode + "=" + sidecode, "type:" + side.splashs[i].type + "=" + type);
        if (side.splashs[i].sideindex == sideindex && side.splashs[i].sidecode == sidecode && side.splashs[i].type == type) {
            deletesidesplash(i, sideindex, sidecode);
        }
    }
}
function deletesidesplash(index, sideindex, sidecode) {
    let areaid = shape.areaid, partsrno = shape.partsrno, smode = shape.mode;
    let side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    if (index != -1) {
        side.splashs[index].isactive = 0;
        let spgindex = areaid + "" + partsrno + "" + sideindex + "" + index;
        let splashg = splashsg.select("#" + smode + "splashg" + spgindex);       
        if (!splashg.empty()) { splashg.remove(); }
        removesidesplashseams32(index, sideindex, sidecode);
        side.splashs[index].seams = [];
        side.splashs[index].slabsplashs = [];
    }
}
function oncornerchangedrawsidesplashs(sideindex) {
    let source = 'oncornerchangedrawsidesplashs';
    drawsidesplashs(sideindex, source);
    if (sideindex > 0) { drawsidesplashs(sideindex - 1, source); }
}
function resetshapesplashs34() {
    if (shape.mode != 'slabpart') {
        for (let j = 0; j < shape.sides.length; j++) {
            let side = shape.sides[j];
            if (side.splashs == undefined) { side.splashs = []; }
            for (let i = 0; i < side.splashs.length; i++) {
                if (side.splashs[i].isactive == 1) {
                    if (side.splashs[i].spltype == undefined) { side.splashs[i].spltype = 0; }
                }
            }
        }
    }
}
function drawsidesplashs(sideindex, source) {   
    if (shape.mode != 'slabpart') {
        var side = shape.sides[sideindex];
        if (side.splashs == undefined) { side.splashs = []; }
        //console.log(sideindex, side.splashs.length, source);
        for (var i = 0; i < side.splashs.length; i++) {
            if (side.splashs[i].isactive == 1) {    
                drawsidesplash(i, sideindex, source);
                drawsidesplashseams31(i, sideindex);
            }
        }
    }
}
function drawsidesplash(index, sideindex, source) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    //console.log(JSON.stringify(splash), source);
    let sidecode = splash.sidecode, width = splash.width, height = splash.height, type = splash.type, splashtext = "";
    if (shape.mode == 'slabpart') { splashtext = 'A' + (shape.areaindex) + ':P' + (shape.partsrno) + ":S: " + width + " x " + height }
    else { splashtext = height; if (scale == 4) { splashtext += '"';} }
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    if (shape.mode != 'slabpart' && splashmode == 2) {
        let spldh = applymminchfact(splashminh, 1, 2);
        let npt = offsetline(x11, y11, x12, y12, spldh);
        x21 = npt.dx1, y21 = npt.dy1, x22 = npt.dx2, y22 = npt.dy2;
    }
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    //console.log("index:" + index, "sideindex:" + sideindex, "sidecode:" + sidecode, "type:" + type, "edge1type:" + edge1type, "edge2type:" + edge2type, "edge3type:" + edge3type, "edge4type:" + edge4type, source);
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, splashtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, height);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, height);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, height);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, height);
    //console.log(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F')
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawcornersplash(index, cornerindex, sideindex) {
    var side = shape.sides[sideindex];
    var corner = side.corners[cornerindex];
    var splash = side.splashs[index];
    let sidetext = 'A' + (shape.areaindex) + ':P' + (shape.partsrno) + ":S: ";
    let sidecode = splash.sidecode, width = splash.width, height = splash.height, type = splash.type, mtext = sidetext + +width + " x " + height;
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, height);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, height);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, height);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, height);
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype, height) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = sideedgeclass(edgetype);
    let spgindex = areaid + "" + partsrno + "" + sideindex + "" + splashindex;
    let splashg = splashsg.select("#" + smode + "splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", smode + "splashg" + spgindex); }
    let splindex = spgindex + "" + lineindex;
    let splline = splashg.select("#" + smode + "splash" + splindex);
    if (splline.empty()) { splline = splashg.append("line").attr("id", smode + "splash" +splindex); }
    splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("lineindex", lineindex).attr("index", splashindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).on("contextmenu", onshapesplashcontextmenu);
    if (shape.mode == 'shape') {
        let stwidth = 10;
        if (height < 4) { stwidth = 5; }
        let splbandline = splashg.select("#" + smode + "splashband" + splindex);
        if (splbandline.empty()) { splbandline = splashg.append("line").attr("id", smode + "splashband" + splindex); }
        splbandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("lineindex", lineindex).attr("index", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("stwidth", stwidth)
            .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
            .on("click", onshapesplashside).on("mouseover", showshapesplashside).on("mouseout", hideshapesplashside);
        splbandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth).on("contextmenu", onshapesplashcontextmenu);
    }
}
function drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let sclass = 'shapesplash';
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    //console.log(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext);
    let spgindex = areaid + "" + partsrno + "" + sideindex + "" + index;
    let splashg = splashsg.select("#" + smode + "splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", smode + "splashg" + spgindex); }    
    let splashpath = splashg.select("#" + smode + "splashpath" + spgindex);
    if (splashpath.empty()) { splashpath = splashg.append("path").attr("id", smode + "splashpath" + spgindex); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("d", spath).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') { splashpath.on("click", onshapesidesplash).on("contextmenu", onshapesplashcontextmenu); }
    let npt = calcontrolcenterpoint(splashg);
    let mtx = npt.ctx, mty = npt.cty + 4;
    let mtx1 = (x11 + x12) / 2, mty1 = (y11 + y12) / 2, mtx2 = (x21 + x22) / 2, mty2 = (y21 + y22) / 2;
    mtx = ((mtx1 + mtx2) / 2) - 4, mty = ((mty1 + mty2)) / 2 + 4;
    let splashtext = splashg.select("#" + smode +  "splashtext" + spgindex);
    if (splashtext.empty()) { splashtext = splashg.append("text").attr("id", smode + "splashtext" + spgindex); }
    splashtext.attr("x", mtx).attr("y", mty).text(mtext);
    splashpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
}
function splashdragstarted() {
    if (shape.mode != 'print') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'splashdragstarted');    
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        dragdx = d3.event.x - splash.x, dragdy = d3.event.y - splash.y;
        bdrag = true;        
    }
}
function splashdragged() {
    if (bdrag) {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));               
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        var cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        splash.x = cx, splash.y = cy;
        setsidesplash(index, sideindex, sidecode, 0, source);
    }
}
function splashdragended() {
    resetdragvars('splashdragended');    
}
function showshapesplashside() {
    if (drawmode == 3 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "10");
        //d3.select(this).attr("class", "shapesideblue");
    }
}
function hideshapesplashside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));
    // var edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
    //d3.select(this).attr("class", sideedgeclass(edgetype));
}
