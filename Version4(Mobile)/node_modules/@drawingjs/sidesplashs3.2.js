function initsidesplash(index, sidesegindex, sideindex, lnindex, cornerindex, sidecode, type, height, spltype) {
    let side = shape.sides[sideindex];
    let splash = {
        index: index, sidesegindex: sidesegindex, sideindex: sideindex, lnindex: lnindex, cornerindex: cornerindex, angle: 0, sidecode: sidecode, width: 0, height: height, isactive: 1, type: type, split: 0, spltype: spltype, typeid: edgetypeid,
        x: 0, y: 0, tx: 0, ty: 0, x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, edges: [], sideshapes: [], seams: [], slabsplashs:[]
    };
    sidesplashedges(splash, sidecode);
    side.splashs.push(splash);
}
function sidesplashindex(side, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function sideccornersplashindex(side, sidecode, lnindex, cornerindex, type) {
    let splashindex = -1;   
    for (let i = 0; i < side.splashs.length; i++) {      
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].lnindex == lnindex && side.splashs[i].cornerindex == cornerindex && side.splashs[i].type == type) {
            splashindex = i, side.splashs[i].isactive = 1; break;
        }
    }
    return splashindex;
}
function sidesegsplashindex(side, sidesegindex, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].sidesegindex == sidesegindex && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function sidesplashactiveindex(side, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type && side.splashs[i].isactive == 1) { splashindex = i; break; }
    }
    return splashindex;
}
function sideshapesplashindex(side, sideshapeindex, sidecode, type) {
    let splashindex = -1;
    for (let i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].cornerindex == sideshapeindex && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function resetshapesplashs(source) {
    for (let j = 0; j < shape.sides.length; j++) {
        onsetsidesplashs(j);
    }
}
function onsetsidesplashs(sideindex, source) {
    source = source + ':onsetsidesplashs';
    if (sideindex == 0) { onsetsidesplash1(sideindex, 0, 1, source); }
    onsetsidesplash1(sideindex, 1, 1, source);
    onsetsidesplash1(sideindex, 2, 1, source);
    if (sideindex < shape.sides.length - 1) { onsetsidesplash1(sideindex, 3, 1, source); }
}
function onsetsidesplash1(sideindex, sidecode, type, source) {
    source =  source + ':onsetsidesplash1';
    let side = shape.sides[sideindex];
    let splindex = sidesplashactiveindex(side, sidecode, 1);
    if (splindex != -1) {
        onsetsidesplash(sideindex, sidecode, type, source);
    }
}
function onsetsidesplash2(sideindex, sidecode, type, source) {
    source = source + ':onsetsidesplash2';
    let side = shape.sides[sideindex];
    let splindex = sidesplashactiveindex(side, sidecode, 1);
    if (splindex != -1) {
        console.log(sideindex, sidecode, type, source);
        deletesidesplashs(sideindex, sidecode, type);       
    }
}
function onsetsidesplash(sideindex, sidecode, type, source) {    
    drawlogservice.beforeupdate(shape, source, 6);
    deletesidesplashs(sideindex, sidecode, type);
    //setsidesegs(sideindex, sidecode);
    setsidesplash(-1, sideindex, sidecode, splheight, type, 0);
    setsideedge1(sideindex, sidecode, "U", 0, source);
    setsideshapesedges(sideindex, sidecode, 'U', 0);
    ActionSplash(source);
    drawlogservice.update(shape, source, 6);   
}
function onsetsideapron(sideindex, sidecode, type, edgetype, edgetypeid, countersidemode) {
    let source = 'onsetsideapron';
    drawlogservice.beforeupdate(shape, source, 6);
    deletesidesplashs(sideindex, sidecode, type);
    setsidesegs(sideindex, sidecode);
    setsidesplash(-1, sideindex, sidecode, splheight, type, countersidemode);
    setsideedge1(sideindex, sidecode, edgetype, edgetypeid, source);
    setsideshapesedges(sideindex, sidecode, edgetype, edgetypeid);
    ActionApron(source);
    drawlogservice.update(shape, source, 6);
}
function onresizesidesplash(obj, type, index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], spltype = splash.type, spltype1 = splash.spltype;
    var objVal = obj.value.split(" ");
    var parseVal = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));   
    if (parseVal > 0) {
        drawlogservice.beforeupdate(shape, 'onresizesidesplash', 4);
        splash.height = parseVal;
        //console.log(index, splash.lnindex, splash.cornerindex, sideindex, sidecode, spltype, parseVal);
        if (spltype == 1) { setsidesplash(index, sideindex, sidecode, parseVal, spltype); }
        else if (spltype == 2) { setcornersplash(index, splash.lnindex, splash.cornerindex, sideindex, sidecode, spltype, parseVal);}
        else if (spltype == 3) { setsideshapesplash(index, splash.lnindex, splash.cornerindex, sideindex, sidecode, spltype, parseVal);}
        ActionSplash('onresizesidesplash');
        drawlogservice.update(shape, 'onresizesidesplash', 4);       
    }
}
function setsidesplash(index, sideindex, sidecode, height, type, spltype) {    
    let side = shape.sides[sideindex];
    if (side != undefined) {     
        let sidecodeseg = side.sidesegs[sidecode];       
        for (i = 0; i < sidecodeseg.segs.length; i++) {
            if (sidecodeseg.segs[i].sw > 0) {
                index = setsidesegsplash(index, i, sideindex, sidecode, height, type, spltype);               
                drawsidesplashseams31(index, sideindex);
                //if (shape.mode == 'shape' && drawmode != 0) { ActionAddEdge(index); }
            }
        }
    }
}
function setsidesegsplash(index, sidesegindex, sideindex, sidecode, height, type, spltype) {   
    let side = shape.sides[sideindex];
    index = sidesegsplashindex(side, sidesegindex, sidecode, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, sidesegindex, sideindex, 0, 0, sidecode, type, height, spltype);}
    let splash = side.splashs[index];
    splash.isactive = 1;
   // console.log(index, sidesegindex, sideindex, sidecode, height, type);
    if (height > 0) { splash.height = height; }
    setsidesegsplash1(index, sidesegindex, sideindex, sidecode);
    setsidesplashedgeswidth(splash);
    drawsidesplash(index, sideindex);
    return index;
}
function setsidesegsplash1(index, sidesegindex,  sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sidecodeseg = side.sidesegs[sidecode];
    let sideseg = sidecodeseg.segs[sidesegindex];
    let splash = side.splashs[index];
    let dh = 50, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2);
    let x1 = sideseg.x1, y1 = sideseg.y1, x2 = sideseg.x2, y2 = sideseg.y2;
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0, w1 = side.w1, w2 = applymminchfact(side.w2, 1, 2);

    if (sidecode == 0) { dsign = islineinpoly3(x11, y11, x12, y12, x21, y21, x22, y22, w2); }
    else if (sidecode == 1) { dsign = islineinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, side.h); }
    else  if (sidecode == 2) { dsign = islineinpoly2(x11, y11, x12, y12, x21, y21, x22, y22, side.h); }
    else if (sidecode == 3) { dsign = islineinpoly4(x11, y11, x12, y12, x21, y21, x22, y22, w2); }

    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.width = sideseg.sw;
}
function onsetcornersplash(lnindex, cornerindex, sideindex, sidecode, edgetype, edgetypeid, type) {
    drawlogservice.beforeupdate(shape, 'onsetcornersplash', 6);
    setcornersplash(-1, lnindex,  cornerindex, sideindex, sidecode, type, splheight);
    setsidecorneredge(lnindex, cornerindex, sideindex, edgetype, edgetypeid, 0, 'onsetcornersplash');   
    ActionSplash('onsetcornersplash');
    drawlogservice.beforeupdate(shape, 'onsetcornersplash', 6);
}
function setcornersplash(index, lnindex,  cornerindex, sideindex, sidecode, type, height) {    
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    index = sideccornersplashindex(side, sidecode, lnindex, cornerindex, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, -1, sideindex, lnindex, cornerindex, sidecode, type, height);}
    let splash = side.splashs[index]; if (height > 0) { splash.height = height; }   
   // console.log(index, sidecode, lnindex, cornerindex, sideindex, sidecode);
    if (corner.type == 1) {//Clip corner     
        setcornersplash1(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);        
    } else if (corner.type == 3) {//Notch corner    
        setcornersplash2(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);  
    } else if (corner.type == 4) {//Bumpout corner       
        setcornersplash2(index, lnindex, cornerindex, sideindex);
        drawcornersplash(index, cornerindex, sideindex);
    }
    setsidesplashedgeswidth(splash);
    //ActionAddEdge(index);    
}
function setcornersplash1(index, lnindex, cornerindex, sideindex) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    let splash = side.splashs[index];
    let x1 = corner.x2, y1 = corner.y2, x2 = corner.x3, y2 = corner.y3, x3 = corner.x1, y3 = corner.y1, sidecode = corner.sidecode, cw = corner.w;
    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = applymminchfact(side.w1, 1, 2), w2 = applymminchfact(side.w2, 1, 2);

    dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x1, y1, x2, y2, cw);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;
    w = Math.round(calchyplen(x1, y1, x2, y2));
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(cw, 2, 2);
}
function setcornersplash2(index, lnindex, cornerindex, sideindex) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    let splash = side.splashs[index];
    let x1 = corner.x2, y1 = corner.y2, x2 = corner.x3, y2 = corner.y3, x3 = corner.x1, y3 = corner.y1, sidecode = corner.sidecode, cw = corner.w;
    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = applymminchfact(side.w1, 1, 2), w2 = applymminchfact(side.w2, 1, 2);
    if (lnindex == 2) { x1 = x2, y1 = y2; }     
    dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x1, y1, x3, y3, cw);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x3, y3);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x3, y3);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x3 + dx1, y12 = y3 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x3 + dx2, y22 = y3 + dy2;
    w = Math.round(calchyplen(x1, y1, x3, y3));
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(cw, 2, 2);
}
function onsetsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, edgetype, edgetypeid, type) {    
    drawlogservice.beforeupdate(shape, 'onsetsideshapesplash', 6);   
    setsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, type);
    setsideshapeedge1(2, sideshapeindex, sideindex, 'U', 0);   
    ActionSplash('onsetsideshapesplash')
    drawlogservice.beforeupdate(shape, 'onsetsideshapesplash', 6);    
}
function setsideshapesplash(lnindex, sideshapeindex, sideindex, sidecode, type) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[sideshapeindex];
    let index = sideccornersplashindex(side, sidecode, lnindex, sideshapeindex, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, -1, sideindex, lnindex, sideshapeindex, sidecode, type, splheight); }
    let splash = side.splashs[index]; splash.height = splheight;    
    setsideshapesplash1(index, lnindex, sideshapeindex, sideindex);
    drawsidesplash(index, sideindex);
    //ActionAddEdge(index);
}
function setsideshapesplash1(index, lnindex, sideshapeindex, sideindex) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[sideshapeindex];
    let splash = side.splashs[index];
    let x1 = sideshape.x21, y1 = sideshape.y21, x2 = sideshape.x22, y2 = sideshape.y22, sidecode = sideshape.sidecode;
    let x11 = sideshape.x11, y11 = sideshape.y11, x12 = sideshape.x12, y12 = sideshape.y12, x21 = sideshape.x21, y21 = sideshape.y21, x22 = sideshape.x22, y22 = sideshape.y22, sw = sideshape.w;

    let dh = 30, asign = side.asign, dsign = 1;
    let height = applymminchfact(splash.height, 1, 2), w = applymminchfact(splash.width, 1, 2);
    dsign = ispointinpoly1(x21, y21, x22, y22, x11, y11, x12, y12, x1, y1, x2, y2, height);
   
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);

    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;
     
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = applymminchfact(sw, 2, 2);
}
function onshapesplashside() {
    let m = d3.mouse(this);
    let mode = this.getAttribute("smode");
    let splashsidecode = parseInt(this.getAttribute("index"));
    let splashindex = parseInt(this.getAttribute("splashindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesplashside');
    if (drawmode == 3) {
      //  onsetsplashsideshape(m[0], m[1], -1, splashindex, sideindex, splashsidecode);
    } else if (drawmode == 5) {
        onsetsplashsideedge(splashsidecode, splashindex, sideindex, sidecode);
    }
}
function onshapesidesplash() {
    removeshapetools();
    d3.event.stopPropagation();
    let m = d3.mouse(this);
    let mode = this.getAttribute("smode");   
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));   
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidesplash');
    
}
function onshapesplashcontextmenu() {
    d3.event.preventDefault();
    let m = d3.mouse(this);  
    let mode = this.getAttribute("smode");
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));   
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesplashcontextmenu');
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], w = splash.width, h = splash.height;
    drawshapesidesplashcontrols(index, sideindex, sidecode, w, h, m[0], m[1]);
}
function ondeleteshapesidesplash(index, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'ondeleteshapesidesplash', 4);
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let spltype = splash.type;   
    if (spltype == 1) { deletesidesplashs(sideindex, sidecode, 1); }
    else { deletesidesplash(index, sideindex, sidecode); }  
    ActionSplash('ondeleteshapesidesplash');
    removeshapetools();
    drawlogservice.update(shape, 'ondeleteshapesidesplash', 4);    
}
function ondeleteshapesidesplash1(index, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'ondeleteshapesidesplash1', 4);
    let side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    deletesidesplash(index, sideindex, sidecode);    
    drawlogservice.update(shape, 'ondeleteshapesidesplash1', 4);   
}
function deletesidesplashs(sideindex, sidecode, type) {   
    let side = shape.sides[sideindex];
    for (i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].isactive == 1 && side.splashs[i].type == type) {
            deletesidesplash(i, sideindex, sidecode);            
        }       
    }  
}
function deletesideshapesplashs(sideshapeindex, sideindex, sidecode, type) {   
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.splashs.length; i++) {       
        if (side.splashs[i].cornerindex == sideshapeindex && side.splashs[i].sidecode == sidecode && side.splashs[i].type == type) {
            deletesidesplash(i, sideindex, sidecode);
        }
    }
}
function deletesidesplash(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    if (index != -1) {
        side.splashs[index].isactive = 0;
        let spgindex = sideindex + "" + index + "" + sidecode;
        let splashg = splashsg.select("#splashg" + spgindex);
        if (!splashg.empty()) { splashg.remove(); }
    }
}
function oncornerchangedrawsidesplashs(sideindex) {
    drawsidesplashs(sideindex);
    if (sideindex > 0) { drawsidesplashs(sideindex - 1); }
}
function drawsidesplashs(sideindex) {
    if (shape.mode != 'slabpart') {
        var side = shape.sides[sideindex];
        if (side.splashs == undefined) { side.splashs = []; }
        for (var i = 0; i < side.splashs.length; i++) {
            if (side.splashs[i].isactive == 1) {
                drawsidesplash(i, sideindex);
                drawsidesplashseams31(i, sideindex);
            }
        }
    }
}
function drawsidesplash(index, sideindex) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let sidecode = splash.sidecode, width = splash.width, height = splash.height, type = splash.type, splashtext = "";
    if (shape.mode == 'slabpart') { splashtext = 'A' + (shape.areaindex) + ':P' + (shape.partsrno) + ":S: " }    
    splashtext = splashtext + width + " x " + height;   
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    if (shape.mode != 'slabpart' && splashmode == 2) {
        let spldh = applymminchfact(splashminh, 1, 2);
        let npt = offsetline(x11, y11, x12, y12, spldh);
        x21 = npt.dx1, y21 = npt.dy1, x22 = npt.dx2, y22 = npt.dy2;
    }
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, splashtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, height);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, height);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, height);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, height);
    //console.log(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F')
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawcornersplash(index, cornerindex, sideindex) {
    var side = shape.sides[sideindex];
    var corner = side.corners[cornerindex];
    var splash = side.splashs[index];
    let sidetext = 'A' + (shape.areaindex) + ':P' + (shape.partsrno) + ":S: ";
    let sidecode = splash.sidecode, width = splash.width, height = splash.height, type = splash.type, mtext = sidetext + +width + " x " + height;
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, height);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, height);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, height);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, height);
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype, height) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = sideedgeclass(edgetype);
    let spgindex = sideindex + "" + splashindex + "" + sidecode;
    let splashg = splashsg.select("#splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", "splashg" + spgindex); }
    let splindex = sideindex + "" + splashindex + "" + sidecode + "" + lineindex;
    let splline = splashg.select("#splash" + splindex);
    if (splline.empty()) { splline = splashg.append("line").attr("id", "splash" + splindex); }
    splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (shape.mode == 'shape') {
        let stwidth = 10;
        if (height < 4) { stwidth = 5; }
        let splbandline = splashg.select("#splashband" + splindex);
        if (splbandline.empty()) { splbandline = splashg.append("line").attr("id", "splashband" + splindex); }
        splbandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", lineindex).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("stwidth", stwidth)
            .attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
            .on("click", onshapesplashside).on("mouseover", showshapesplashside).on("mouseout", hideshapesplashside);
        splbandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
    }
}
function drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let sclass = 'shapesplash';
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";

    let spgindex = sideindex + "" + index + "" + sidecode;
    let splashg = splashsg.select("#splashg" + spgindex);
   
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", "splashg" + spgindex); }
    let splindex = sideindex + "" + index + "" + sidecode + "" + type;
    let splashpath = splashg.select("#splashpath" + splindex);
    if (splashpath.empty()) { splashpath = splashg.append("path").attr("id", "splashpath" + splindex); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("d", spath)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
        .on("click", onshapesidesplash).on("contextmenu", onshapesplashcontextmenu);
    let npt = calcontrolcenterpoint(splashg);
    let mtx = npt.ctx, mty = npt.cty + 3;
    let splashtext = splashg.select("#splashtext" + splindex);
    if (splashtext.empty()) { splashtext = splashg.append("text").attr("id", "splashtext" + splindex); }
    splashtext.attr("x", mtx).attr("y", mty).text(mtext);
    splashpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
}
function splashdragstarted() {
    if (shape.mode != 'print') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'splashdragstarted');    
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        dragdx = d3.event.x - splash.x, dragdy = d3.event.y - splash.y;
        bdrag = true;
        drawlogservice.beforeupdate(shape, 'splashdragstarted', 4);
    }
}
function splashdragged() {
    if (bdrag) {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));               
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        var cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        splash.x = cx, splash.y = cy;
        setsidesplash(index, sideindex, sidecode, 0);
    }
}
function splashdragended() {
    resetdragvars('splashdragended');
    drawlogservice.update(shape, 'splashdragended', 4);
}
function showshapesplashside() {
    if (drawmode == 3 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "10");
        //d3.select(this).attr("class", "shapesideblue");
    }
}
function hideshapesplashside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));
    // var edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
    //d3.select(this).attr("class", sideedgeclass(edgetype));
}
