function initdglayout32(index) {
    initdgmatareas32(index);
}
function initdgmatslabgroups(index) {
    let versionid = getversionid();
    mdgsvg = d3.select("#mdgsvg" + versionid);
    if (mdgsvg.empty()) { mdgsvg = d3.select('.mdgsvg').append("svg").attr("id", "mdgsvg" + versionid); }
    mdgsvg.attr("width", dglwidth).attr("height", dglheight).attr("style", "border:1px solid lightblue");
}
function initdgmatareas32(matindex) {    
    let areas = getversionareas();   
    for (let index = 0; index < areas.length; index++) {
        let area = areas[index]; 
        let matpartlist = getpartlist(index); //filter area partlist by material
        if (matpartlist.length > 0) {
            mdgsvg = d3.select("#mdgsvg" + index + area.VersionID + area.ExNo);
            if (mdgsvg.empty()) { mdgsvg = d3.select('.mdgsvg').append("svg").attr("id", "mdgsvg" + index + area.VersionID + area.ExNo); }
            mdgsvg.attr("width", dglwidth).attr("height", dglheight).attr("style","border:1px solid lightblue");
            mdgslabpartsg = mdgsvg.select("#mdgslabpartsg" + index); if (mdgslabpartsg.empty()) { mdgslabpartsg = mdgsvg.append("g").attr("id", "mdgslabpartsg" + index); }            
            drawdgslabpartshapes32(matpartlist, 'shapedg', 'initdglayout');
            setmdgsvgbounds();            
        }
    }   
}
function getslabpartdgshapesidepath32(sideindex, source) {
    let sidepoints = getshapesidepoints(sideindex);
    let spath = shapesidepath32(sidepoints);
    return spath;
}
function onsetslabpartclipimage32() {
    let source = 'onsetslabpartclipimage32';
    let slabindex = shape.slabindex, slabid = shape.slabid, partsrno = shape.partsrno, spindex = shape.spindex, areaid = shape.areaid, matid = shape.materialid
    let matindex = msvg.attr("index");
    drawdgshapeslabparts32(partsrno, spindex, areaid, slabindex, slabid, matindex, source);

}
function drawdgslabpartshapes32(matpartlist, mode, source) {
    if (matpartlist != null && matpartlist.length > 0) {
        for (let i = 0; i < matpartlist.length; i++) {
            if (matpartlist[i].IsActive == 1 && matpartlist[i].Shape != null && matpartlist[i].Shape != 'null') {    
                drawdgshape32(matpartlist[i].SrNo, matpartlist[i].AreaID, source);               
            }
        }
    }
}
function drawdgshape32(partsrno, areaid, source) {
    let smode = 'shapedg';
    shape = getpartshapebyareapartsrno(partsrno, areaid);
    if (shape != undefined) {
        let index = partsrno - 1, areashapeindex = areaid + "" + index, spindex = shape.spindex;
        let partshapeouterg = mdgslabpartsg.select("#" + smode + "outer" + areashapeindex);
        if (partshapeouterg.empty()) { partshapeouterg = mdgslabpartsg.append("g").attr("id", smode + "outer" + areashapeindex); }
        partshapeouterg.attr("id", smode + "outer" + areashapeindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        let ztx = shape.tx, zty = shape.ty;           
        let npt = [ztx, zty];
        partshapeouterg.attr('transform', 'translate(' + npt + ')');
        let partshapeg = partshapeouterg.select("#" + smode + areashapeindex);
        if (partshapeg.empty()) { partshapeg = partshapeouterg.append("g").attr("id", smode + areashapeindex); }       
        let partshapepathg = partshapeouterg.select("#" + smode + "path" + areashapeindex);
        if (partshapepathg.empty()) { partshapepathg = partshapeouterg.append("g").attr("id", smode + "path" + areashapeindex); } else { partshapepathg.selectAll('*').remove();}
        for (let j = 0; j < shape.sides.length; j++) {
            let spath = getslabpartdgshapesidepath32(j, source);
            partshapepathg.append("path").attr("d", spath).attr("class", "shapeside");
        }
        drawslabpartshapesidesclippath32(areashapeindex, partshapepathg, source);
        drawslabpartshapecornersclippath32(areashapeindex, partshapepathg, source);
    }
}
function drawdgshapeslabparts32(partsrno, spindex, areaid, slabindex, slabid, matindex, source) {
   // console.log(partsrno, spindex, areaid, slabindex, slabid, matindex, source);
    let dgpartshape = getpartshapebyareapartsrno(partsrno, areaid);   
    let smode = 'shapedg', index = dgpartshape.index;
    if (dgpartshape != undefined) {
        let ztx = dgpartshape.tx, zty = dgpartshape.ty;
        let x11 = dgpartshape.sides[0].x11, y11 = dgpartshape.sides[0].y11;
        let dgsx1 = x11 + ztx, dgsy1 = y11 + zty;     
        drawdgshapeslabpart32(spindex, partsrno, areaid, slabindex, slabid, matindex, dgsx1, dgsy1, source);
    }
}
function drawdgshapeslabpart32(spindex, partsrno, areaid, slabindex, slabid, matindex, dgsx1, dgsy1, source) {
    let smode = 'shapedg';
    //console.log(spindex, partsrno, areaid, slabindex, matindex, dgsx1, dgsy1, source);
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let partshapeg = d3.select("#" + smode + areashapeindex);
    let slabpartdgouterg = partshapeg.select("#slabpartdgouter" + areashapeslabpartindex);
    if (slabpartdgouterg.empty()) { slabpartdgouterg = partshapeg.append("g").attr("id", "slabpartdgouter" + areashapeslabpartindex); }
    else { slabpartdgouterg.selectAll('*').remove(); }
    drawslabpartshapeimage32(slabindex, matindex, spindex, partsrno, areaid);
    drawslabpartshapeclippath32(spindex, partsrno, areaid, slabid); 
}
function drawslabpartshapeimage32(slabindex, matindex, spindex, partsrno, areaid) {
   // console.log(slabindex, matindex, spindex, partsrno, areaid);
    let mslablist = getmatslablistbyindex(matindex);
    let mslab = mslablist[slabindex];  
    let mslabid = mslab.ID, areashapeindex = 0, areashapeslabpartindex = 0, sindex = 0;
    let mdgslabx = 0, mdgslaby = 0, mslabw = applymminchfact(mslab.Width, 1, 0), mslabh = applymminchfact(mslab.Length, 1, 0), mslabimgpath = mslab.Path;
    //console.log(slabindex, matindex, spindex, partsrno, areaid, mslabid);
    if (mslabimgpath == null) { return;}
    if (mslabimgpath.indexOf('.jpg') == -1) { mslabimgpath = contentPath + "Inventory/" + mslab.Path + '.jpg'; }   
    areashapeindex = areaid + "" + (partsrno - 1);
    areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;  
    let slabptrnimg = d3.select("#" + "slabptrnimg" + mslabid);
    mdgslabx = slabptrnimg.attr("x"), mdgslaby = slabptrnimg.attr("y");
  //  console.log(slabindex, matindex, spindex, partsrno, areaid, mslabx, mslaby);
    //1.draw slabpart slab image
    mdgslabx -= shape.tx, mdgslaby -= shape.ty;
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    if (slabpartdgouterg.empty()) { slabpartdgouterg = partshapeg.append("g").attr("id", "slabpartdgouter" + areashapeslabpartindex); }

    let slabptrndgimg = slabpartdgouterg.select("#slabptrndgimg" + areashapeslabpartindex);
    if (slabptrndgimg.empty()) { slabptrndgimg = slabpartdgouterg.append("image").attr("id", "slabptrndgimg" + areashapeslabpartindex); }

    slabptrndgimg.attr("slabindex", slabindex).attr("x", mdgslabx).attr("y", mdgslaby).attr("width", mslabw)
        .attr("height", mslabh).attr("preserveAspectRatio", "xMidYMid").attr("href", mslabimgpath);
    //2. apply clip path to slabimage using slabpart measurements.
    slabptrndgimg.attr("clip-path", "url(#slabpartdgclippath" + areashapeslabpartindex + ")");
}
function drawslabpartshapeclippath32(spindex, partsrno, areaid) {
    let source = 'drawslabpartshapeclippath32';
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;   
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);   
    let slabpartdgclippath = slabpartdgouterg.select("#slabpartdgclippath" + areashapeslabpartindex);
    if (slabpartdgclippath.empty()) { slabpartdgclippath = slabpartdgouterg.append("clipPath").attr("id", "slabpartdgclippath" + areashapeslabpartindex).attr("clipPathUnits", "userSpaceOnUse"); }
    for (let i = 0; i < shape.sides.length; i++) {
        let spsideclippathindex = areashapeslabpartindex + "" + i;
        let spath = getslabpartdgshapesidepath32(i, source);
        let spsideclippath = slabpartdgclippath.select("#spsideclippath" + spsideclippathindex);
        if (spsideclippath.empty()) { spsideclippath = slabpartdgclippath.append("path").attr("id", "spsideclippath" + spsideclippathindex); }
       // console.log(i, spath);
        spsideclippath.attr("d", spath);
    }
    drawslabpartshapesidesclippath32(areashapeslabpartindex, slabpartdgclippath, source);
    drawslabpartshapecornersclippath32(areashapeslabpartindex, slabpartdgclippath, source);
    rotateslabpartshape(spindex, partsrno, areaid, shape.angle);
}
function drawslabpartshapesidesclippath32(areashapeslabpartindex, slabpartdgclippath, source) {
    for (let i = 0; i < shape.sides.length; i++) {
        let side = shape.sides[i];
        for (let j = 0; j < side.sideshapes.length; j++) {
            if (side.sideshapes[j].isactive == 1) {
                let spsideshapeclippathindex = areashapeslabpartindex + "" + i + "" + j;
                let spath = getshapesideshapepath32(j, i);
                let spsideshapeclippath = slabpartdgclippath.select("#spsideshapeclippath" + spsideshapeclippathindex);
                if (spsideshapeclippath.empty()) { spsideshapeclippath = slabpartdgclippath.append("path").attr("id", "spsideshapeclippath" + spsideshapeclippathindex); }
                // console.log(i, spath);
                spsideshapeclippath.attr("d", spath).attr("class", "shapeside");
            }
        }
    }
}
function drawslabpartshapecornersclippath32(areashapeslabpartindex, slabpartdgclippath, source) {
    for (let i = 0; i < shape.sides.length; i++) {
        let side = shape.sides[i];
        for (let j = 0; j < side.corners.length; j++) {
            if (side.corners[j].type != 0) {
                let spsidecornerclippathindex = areashapeslabpartindex + "" + i + "" + j;
                let spath = getshapesidecornerpath32(j, i);
                let spsidecornerclippath = slabpartdgclippath.select("#spsidecornerclippath" + spsidecornerclippathindex);
                if (spsidecornerclippath.empty()) { spsidecornerclippath = slabpartdgclippath.append("path").attr("id", "spsidecornerclippath" + spsidecornerclippathindex); }
                console.log(i, spath);
                spsidecornerclippath.attr("d", spath).attr("class", "shapeside");
            }
        }
    }
}
function rotateslabpartshape(spindex, partsrno, areaid, spangle) {
    //1.rotate slabpartclippath
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    let slabpartdgclippath = slabpartdgouterg.select("#slabpartdgclippath" + areashapeslabpartindex);
    let spclipnode = slabpartdgclippath.node();
    let sx2 = spclipnode.getBBox().x + spclipnode.getBBox().width / 2; sy2 = spclipnode.getBBox().y + spclipnode.getBBox().height / 2;
    let npt2 = [sx2.toFixed(), sy2.toFixed()];
    slabpartdgclippath.attr("transform", "rotate(" + spangle + "," + npt2 + ")");
    //2.rotate slabpartdgimage
    let slabptrndgimg = slabpartdgouterg.select("#slabptrndgimg" + areashapeslabpartindex);   
    slabptrndgimg.attr("transform", "rotate(" + -spangle + "," + npt2 + ")");
}
function removedgshapeslabparts32(partsrno, spindex, areaid, source) {
    let smode = 'shapedg';
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let partshapeg = d3.select("#" + smode + areashapeindex);
    let slabpartdgouterg = partshapeg.select("#slabpartdgouter" + areashapeslabpartindex);
    if (slabpartdgouterg.empty()) { slabpartdgouterg = partshapeg.append("g").attr("id", "slabpartdgouter" + areashapeslabpartindex); }
    else { slabpartdgouterg.selectAll('*').remove(); }
}

function setmdgsvgbounds() {
    let sgscale = 0;
    let mdgslabpartsgnode = mdgslabpartsg.node().getBBox(), mdgsgw = Math.round(mdgslabpartsgnode.width), mdgsgh = Math.round(mdgslabpartsgnode.height) + 30;
    mdgsleft = Math.round(mdgslabpartsgnode.left), mdgstop = Math.round(mdgslabpartsgnode.top);
    let ztx = 0, zty = 0;
    if (mdgsgw != 0 && mdgsgh != 0) {
        mdgsvg.attr("height", mdgsgh);
        let mdgsvgnode = mdgsvg.node(), mdgsvgclientw = Math.round(mdgsvgnode.clientWidth), mdgsvgclienth = Math.round(mdgsvgnode.clientHeight);
        mdgsvgclientleft = Math.round(mdgsvgnode.clientLeft), mdgsvgclientop = Math.round(mdgsvgnode.clientTop);        
        sgscale = roundToPlaces(Math.min(mdgsvgclientw / mdgsgw, mdgsvgclienth / mdgsgh), 2);
        ztx = Math.round(mdgsvgclientop - mdgslabpartsgnode.x + 30); zty = Math.round(mdgsvgclientleft - mdgslabpartsgnode.y + 30);
        console.log(mdgslabpartsgnode.x, mdgslabpartsgnode.y, mdgsvgclientop, mdgsvgclientleft, sgscale);
    }   
    if (sgscale > dglzscale) { sgscale = dglzscale; }
    let npt = [Math.round(ztx * sgscale), Math.round(zty * sgscale)];
    mdgslabpartsg.attr("transform", "translate(" + npt + ")scale(" + sgscale + ")");
    return sgscale;
}

