function initmaterial31(index) {   
    let source = 'initmaterial31';
    mslaby = 0;   
    initmatslabgroups(index);
    initdglayout32(index);
    togglelayoutmode();
    drawslabshapes(index, source);   
    setmatslabparts31(index);    
    if (mslaby > lheight) { lheight = mslaby + spdy; msvg.style("height", lheight); }
    resetmsvgbounds();
    zoomslabshapes(index); 
    zoommatslabparts(index); 
}
function initmatslabgroups(index) {
    lwidth = window.innerWidth - 120;//window width
    let versionid = getversionid();
    msvg = d3.select("#msvg" + versionid); if (msvg.empty()) { msvg = d3.select('.msvg' + versionid).append("svg").attr("id", "msvg" + versionid).on("mousedown", msvgclick) }
    msvg.attr("index", index).attr("width", lwidth).attr("height", lheight).style("display", "block").on("contextmenu", svgcontextmenu);
    mslabsg = msvg.select("#mslabsg"); if (mslabsg.empty()) { mslabsg = msvg.append("g").attr("id", "mslabsg"); } else { mslabsg.selectAll('*').remove(); }
    mslabpartsg = msvg.select("#mslabpartsg"); if (mslabpartsg.empty()) { mslabpartsg = msvg.append("g").attr("id", "mslabpartsg"); } else { mslabpartsg.selectAll('*').remove(); }
    let slabpartsrect = mslabpartsg.select("#slabpartsrect"); if (slabpartsrect.empty()) { slabpartsrect = mslabpartsg.append("rect").attr("id", "slabpartsrect"); }
    slabpartsrect.attr("x", lzscalex).attr("y", lzscaley).attr("width", lwidth).attr("height", lheight).style("fill", "lightblue").style("fill-opacity", "0.1");    
    slabpartcontrolsg = mslabpartsg.select("#slabpartcontrolsg"); if (slabpartcontrolsg.empty()) { slabpartcontrolsg = mslabpartsg.append("g").attr("id", "slabpartcontrolsg"); }    
    //maskdefs = apdefssvg.select("#maskdefs"); if (maskdefs.empty()) { maskdefs = apdefssvg.append("defs").attr("id", "maskdefs"); }
}

function setmatslabparts31(index) {   
    //1. get material parts
    //2. loop throup all part shapes  and add to slabaprts.
    let matpartlist = getpartlistbymatindex(index);   
    slabparty = 0;    
    setmatpartshapes32(matpartlist);
}
function setmatpartshapes32(matpartlist) {
    if (matpartlist != null && matpartlist != '') {
        for (let i = 0; i < matpartlist.length; i++) {
            if (matpartlist[i].Shape.layout == undefined) { matpartlist[i].Shape.layout = 1; }            
            if (matpartlist[i].IsActive == 1) { setpartshapeslabpartslayout(matpartlist[i].Shape); }           
        }
    }
}
function setpartshapeslabpartslayout(partshape) {   
    if (partshape.layout == 1) {
        setpartshapeslabparts31(partshape, 'slabpart', 'setmatslabparts31');
        setpartshapeslabsplashs31(partshape);
       // if (layoutmode == 2) { drawslabpartshapeclippath(); }
    } else {
        deleteslabpartshapes1(partshape);//show/hide part shapes in layout
    }
}

function onsetlayoutmode(mode) {
    let source = 'onsetlayoutmode';
    layoutmode = mode;
    togglelayoutmode();
    setslabshapepathimages(source);
}
function togglelayoutmode() {
    let layoutclass = layoutmode == 2 ? "fa fa-toggle-on active1" : "fa fa-toggle-on fa-rotate-180 inactive1";
    $('#layoutmode').attr('class', layoutclass);
}
function setslabshapepathimages(source) {
    source += ":" + layoutmode;
    // let index = getmaterialindex();
    let index = msvg.attr("index");    
    if (layoutmode == 1) {
        //1.remove slab images to slabs; 
        //getmaterial index      
        drawslabshapes(index, source);
       // removedgslabshapes(index);
        //2.remove shape images and set opacity
       // removeshapesclipimages();
        //3.set shapes opacity
       // setshapesopacity(0.2);
        //4.set slabpart shapes opacity
       // setslabpartsopacity(0.2);
    } else if (layoutmode == 2) {
        ////1.set slab images
        drawslabshapes(index, source);
        //clipcanvasimage();
        //drawdgslabshapes(index);
        ////2.set slabpart clip images to shapes
        // onsetslabpartclipimage32();
    }
}
function msvgclick() {    
    if (d3.event.srcElement.tagName == 'svg') { removeshapetools(); }
}
function mlzoomclick(ztype) {
    lzscale = roundToOne(lzscale);
    let scaleto = ztype == 0 ? roundToOne(lzscale - 0.1) : roundToOne(lzscale + 0.1);
   // console.log(lzscale, scaleto);
    if (scaleto <= 0.1) { scaleto = 0.1; }
    lzscale = roundToOne(scaleto);
    let matindex = msvg.attr("index");    
    zoomslabshapes(matindex); //get material index
    zoommatslabparts(matindex);
    removeshapetools();
    $('#txtmlzoom').html((Math.round(roundToOne(lzscale) * 100)) + "%");
}
function zoommatslabparts(index) {
    let matpartlist = getpartlistbymatindex(index);
    for (let i = 0; i < matpartlist.length; i++) {
        let partshape = parsepartshape(matpartlist[i].Shape);
        zoompartshapeslabparts31(partshape, 'slabpart', 'zoommatslabparts');
        zoompartshapeslabsplashs31(partshape, 'zoommatslabparts');
    }
}
function zoompartshapeslabparts31(partshape, mode, source) {
    if (partshape.slabparts != null) {
        for (let i = 0; i < partshape.slabparts.length; i++) {
            transformslabpartshape(i, partshape, mode);
        }
    }
}
function zoompartshapeslabsplashs31(partshape, source) {
    if (partshape.sides != null) {
        for (let i = 0; i < partshape.sides.length; i++) {
            if (partshape.sides[i].splashs != null) {
                for (let j = 0; j < partshape.sides[i].splashs.length; j++) {
                    for (let k = 0; k < partshape.sides[i].splashs[j].slabsplashs.length; k++) {
                        transformpartslabsplash(k, j, i, partshape, 'slabsplash');
                    }
                }
            }
        }
    }
}
function transformslabpartshape(spindex, partshape, mode) {
    let areashapeindex = partshape.areaid + "" + partshape.partsrno + "" + spindex;
    let partshapeouterg = mslabpartsg.select("#" + mode + "outer" + areashapeindex);
    let ztx = partshape.slabparts[spindex].tx, zty = partshape.slabparts[spindex].ty;
   // console.log(areashapeindex, ztx, zty, lzscale, partshapeouterg.empty());    
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    partshapeouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function transformpartslabsplash(splindex, spsplashindex, spsideindex, partshape, mode) {
    let partshapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs[splindex];
    let shapeslabsplashindex = partshapeslabsplash.partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let partslabsplashouterg = mslabpartsg.select("#slabsplashouterg" + shapeslabsplashindex);
    let ztx = partshapeslabsplash.tx, zty = partshapeslabsplash.ty;
   // console.log(splindex, spsplashindex, spsideindex, shapeslabsplashindex);
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    partslabsplashouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function getslabpartshapesgscale() {
    let sgscale = 0;
    let mslabpartsgnode = mslabpartsg.node().getBBox(), msgw = Math.round(mslabpartsgnode.width), msgh = Math.round(mslabpartsgnode.height);
    if (msgw != 0 && msgh != 0) {
        let msvgnode = msvg.node(), msvgclientw = Math.round(msvgnode.clientWidth), msvgclienth = Math.round(msvgnode.clientHeight);
        sgscale = roundToPlaces(Math.min(msvgclientw / msgw, msvgclienth / msgh) * lzscale, 2);
    }
    return sgscale;
}
function isslabpartinbounds(sgscale) {
    let isinbox = true;
    let nsgscale = getslabpartshapesgscale();
    nsgscale += (lzscale - sgscale);
    if (nsgscale < lzscale) { isinbox = false; }
    //console.log(nsgscale, sgscale, zscale);
    return isinbox;
}
function resetmsvgbounds() {
    let sgscale = getslabpartshapesgscale();
    if (sgscale < lzscale) { lzscale = sgscale; }
    $('#txtmlzoom').html((Math.round(roundToOne(lzscale) * 100)) + "%");
}
function checkimage(url) {
    var img = new Image();
    img.src = url;
    if (img.height > 0) {
        return true;
    } else {
        return false;
    }
}
function initslabdefs() {
    //<defs><pattern id="img1" patternUnits="userSpaceOnUse" width="100" height="100"><image xlink:href="wall.jpg" x="0" y="0" width="100" height="100" /></pattern></defs>
    slabdefs = defssvg.select("#slabdefs");
    if (slabdefs.empty()) { slabdefs = defssvg.append("defs").attr("id", "slabdefs"); }
    var slabdef = slabdefs.select("#slabptrn" + slab.index);
    if (slabdef.empty()) {
        slabdef = slabdefs.append("pattern").attr("id", "slabptrn" + slab.index).attr("patternContentUnits", "objectBoundingBox")
            .attr("width", "100%").attr("height", "100%").attr("viewBox", "0 0 1 1").attr("preserveAspectRatio", "xMidYMid slice");
    }
    var slabptrnimmage = slabdef.select("#slabptrnimg" + slab.index);
    if (slabptrnimmage.empty()) {
        slabptrnimmage = slabdef.append("image").attr("id", "slabptrnimg" + slab.index).attr("width", "1").attr("height", "1").attr("preserveAspectRatio", "xMidYMid slice")
            .attr("xlink:href", slab.path);
    }
}
function convertbase64image(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function () {
        var reader = new FileReader();
        reader.onloadend = function () { callback(reader.result); }
        reader.readAsDataURL(xhr.response);
    };
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.send();
}
function setslabpartsplashslabinfo32(materialid, slabpartsidepathEle, mslablist, mode) {
    let onslabmode = 0;
    for (let i = 0; i < mslablist.length; i++) {
        onslabmode = 0;
        let mslabgEle = document.querySelector("#" + "mslabpathg" + mslablist[i].ID);
        if (isshapeinbox(mslabgEle, slabpartsidepathEle)) { onslabmode = 3; }
        if (isshapesideintersect(mslabgEle, slabpartsidepathEle, 'setslabpartsplashslabinfo32')) {
            if (mode == 'slabpart') { shape.slabid = mslablist[i].ID, shape.slabindex = i; }
            else if (mode == 'slabsplash') { shapeslabsplash.slabid = mslablist[i].ID, shapeslabsplash.slabindex = i; }
        }
        if (onslabmode != 0) { break; }
    }
    let iscollision = detectslabpartcollision(materialid);
    if (iscollision && onslabmode == 0) { onslabmode = 1; } else if (iscollision && onslabmode == 3) { onslabmode = 2; }
    if (mode == 'slabpart') { shape.color = slabpartsplashfillcolor(onslabmode); } else if (mode == 'slabsplash') { shapeslabsplash.color = slabpartsplashfillcolor(onslabmode); }    
    return onslabmode;
}
function detectslabpartcollision(materialid) {
    //1. get material parts
    //2. loop throup all part shapes  and add to slabaprts. 
    let areashapeindex = shape.areaid + "" + shape.index;
    for (let i = 0; i < shape.sides.length; i++) {
        let sidepathindex = areashapeindex + "" + i;
        let slabpartsidepathgEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);
        if (detectslabpartcollision1(materialid, areashapeindex, slabpartsidepathgEle)) { return true; }
    }
    return false;
}
function detectslabpartcollision1(materialid, areashapeindex, slabpartsidepathgEle) {
    let matpartlist = getpartlistbymaterialId31(materialid);
    for (let i = 0; i < matpartlist.length; i++) {
        let tmppartshape = parsepartshape(matpartlist[i].Shape);
        for (let j = 0; j < tmppartshape.slabparts.length; j++) {
            let tmpareashapeindex = tmppartshape.areaid + "" + tmppartshape.partsrno + "" + j;
            if (areashapeindex != tmpareashapeindex) {
                if (detectslabpartcollision2(tmpareashapeindex, tmppartshape, slabpartsidepathgEle)) { return true; }
            }
            if (detectslabpartsplashscollision2(tmppartshape, slabpartsidepathgEle)) { return true; }
        }
    }
    return false;
}
function detectslabpartcollision2(tmpareashapeindex, tmppartshape, slabpartsidepathgEle) {
    for (let k = 0; k < tmppartshape.sides.length; k++) {
        let sidepathindex = tmpareashapeindex + "" + k;
        let tmpslabpartsidepathgEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);
        if (tmpslabpartsidepathgEle != null) {
            if (isshapesideintersect(slabpartsidepathgEle, tmpslabpartsidepathgEle, 'detectslabpartcollision2')) {
                return true;
            }
        }
    }
    return false;
}
function detectslabpartsplashscollision2(tmppartshape, slabpartsidepathgEle) {
    for (let i = 0; i < tmppartshape.sides.length; i++) {
        for (let j = 0; j < tmppartshape.sides[i].splashs.length; j++) {
            for (let k = 0; k < tmppartshape.sides[i].splashs[j].slabsplashs.length; k++) {
                let slabsplashindex = tmppartshape.areaid + "" + tmppartshape.partsrno + "" + i + "" + j + "" + k;
                let tmpslabsplashsidepathgEle = document.querySelector("#" + "slabsplashpath" + slabsplashindex);
                if (tmpslabsplashsidepathgEle != null) {
                    if (isshapesideintersect(slabpartsidepathgEle, tmpslabsplashsidepathgEle, 'detectslabpartsplashscollision2')) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function isshapeinbox(el1, el2) {
    let elb1 = el1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    let elb2 = el2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT
    //console.log(Math.round(elb1.left), Math.round(elb1.right), Math.round(elb1.top), Math.round(elb1.bottom), Math.round(elb2.left), Math.round(elb2.right), Math.round(elb2.top), Math.round(elb2.bottom)
    //    , elb2.left < elb1.left, elb2.top > elb1.top, elb2.right < elb1.right, elb2.bottom < elb1.bottom);
    //CHECK IF THE TWO BOUNDING BOXES OVERLAP

    return ((elb1.left < elb2.left) && (elb1.top < elb2.top) && (elb1.right > elb2.right) && (elb1.bottom > elb2.bottom));
}
function isshapesideintersect(el1, el2, source) {
    let elb1 = el1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    let elb2 = el2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT
    //console.log(Math.round(elb1.left), Math.round(elb1.right), Math.round(elb1.top), Math.round(elb1.bottom), Math.round(elb2.left), Math.round(elb2.right), Math.round(elb2.top), Math.round(elb2.bottom)
    //    , elb2.left > elb1.right, elb2.right < elb1.left, elb2.top > elb1.bottom, elb2.bottom < elb1.top, source);
    //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(elb2.left > elb1.right || elb2.right < elb1.left || elb2.top > elb1.bottom || elb2.bottom < elb1.top);
}
function slabpartsplashfillcolor(mode) {   
    let scolor = shape.color;
    if (mode == 0) {
        scolor = "orange"; //orange - off the slab &  not colliding with other shape  
    } else if (mode == 1) {
        scolor = "red";  //Red - off the slab & colliding with other shape
    } else if (mode == 2) {
        scolor = "yellow"; // Yellow - On the slab but colliding with other shape
    } else if (mode == 3) {
        scolor = "green"; // Green - on the slab       
    }
    return scolor;
}
