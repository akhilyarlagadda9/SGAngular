function initslabsplash31(index, spseamindex, spsplashindex, spsideindex, partsrno, areaid) {
    let slabsplash = { index: index, x: 0, y: 0, tx: 0, ty: 0, angle: 0, splindex: index, spseamindex: spseamindex, spsplashindex: spsplashindex, spsideindex: spsideindex, partsrno: partsrno, areaid: areaid };
    shapeslabsplash.slabsplashs.push(slabsplash);
}
function setslabsplashgroups31(index, source) {   
    let splindex = shapeslabsplash.splindex, spseamindex = shapeslabsplash.spseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
    slabsplashouterg = mslabpartsg.select("#slabsplashouterg" + index);
    if (slabsplashouterg.empty()) { slabsplashouterg = mslabpartsg.append("g").attr("id", "slabsplashouterg" + index).attr("index", index); }
    slabsplashouterg.attr("splindex", splindex).attr("spseamindex", spseamindex).attr("spsplashindex", spsplashindex).attr("spsideindex", spsideindex).attr("partsrno", partsrno).attr("areaid", areaid);
    slabsplashg = slabsplashouterg.select("#slabsplashg" + index);
    if (slabsplashg.empty()) { slabsplashg = slabsplashouterg.append("g").attr("id", "slabsplashg" + index); }
    slabsplashouterg.call(slabsplashdrag);
}
function slabsplashindex(spsplashindex, spsideindex, spseamindex, slabsplashs) {   
    let index = -1;
    for (let i = 0; i < slabsplashs.length; i++) {
        if (slabsplashs[i].spseamindex == spseamindex && slabsplashs[i].spsplashindex == spsplashindex && slabsplashs[i].spsideindex == spsideindex) { index = i; break; }
    }
    return index;
}
function setslabsplashangle() {   
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;    
    let angle = calclineangle2(x11, y11, x12, y12, 'slabsplashangle');
    shapeslabsplash.angle = angle;
}
function setslabsplash30(index, spseamindex, spsplashindex, spsideindex, partsrno, areaid, partshape) {
    //console.log(index, spseamindex, spsplashindex, spsideindex, partsrno, areaid);
    shapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex];
    if (index == -1) { index = shapeslabsplash.slabsplashs.length; initslabsplash31(index, spseamindex, spsplashindex, spsideindex, partsrno, areaid); }
    shapeslabsplash.seams[spseamindex].split = 1;
    let slabsplash = shapeslabsplash.slabsplashs[index];
    slabsplash.tx = shapeslabsplash.tx + 10;
    slabsplash.ty = shapeslabsplash.ty + 10;
    slabsplash.spseamindex = spseamindex;
    slabsplash.spsplashindex = spsplashindex;
    slabsplash.spsideindex = spsideindex;   
    slabsplash.partsrno = partsrno;
    slabsplash.areaid = areaid;
}
function setslabsplash32(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, source) {
  //  console.log(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, source);
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    shapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex];
    setslabsplashinfo31(splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, partshape.areaindex, partshape.materialid);
}
function setslabsplashinfo31(splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, materialid) {
    let slabsplash = shapeslabsplash.slabsplashs[splindex];
    //console.log(shapeslabsplash.index, splindex, slabsplash.tx, slabsplash.ty, shapeslabsplash.y21);
    if ((shapeslabsplash.x21 + slabsplash.tx) < 0) { slabsplash.tx = (-shapeslabsplash.x21) + 30;}
    if ((shapeslabsplash.y21 + slabsplash.ty) < 0) { slabsplash.ty = (-shapeslabsplash.y21) + 30; }
    shapeslabsplash.tx = slabsplash.tx;
    shapeslabsplash.ty = slabsplash.ty;    
    shapeslabsplash.angle = slabsplash.angle;
    shapeslabsplash.spseamindex = spseamindex;
    shapeslabsplash.spsplashindex = spsplashindex;
    shapeslabsplash.spsideindex = spsideindex;
    shapeslabsplash.splindex = splindex;
    shapeslabsplash.partsrno = partsrno;
    shapeslabsplash.areaid = areaid;
    shapeslabsplash.areaindex = areaindex;
    shapeslabsplash.index = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    shapeslabsplash.materialid = materialid;
    shapeslabsplash.color = slabsplash.color;
    setslabsplashangle();   
}
function setshapesplashslabsplashs31(spseamindex, spsplashindex, spsideindex, partshape, source) {
    //console.log(spseamindex, spsplashindex, spsideindex, source, partshape.sides[spsideindex].splashs[spsplashindex].length);
    let partsrno = partshape.partsrno, areaid = partshape.areaid, areaindex = partshape.areaindex;
    shapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex];
    if (shapeslabsplash.slabsplashs == undefined || shapeslabsplash.slabsplashs == null) { shapeslabsplash.slabsplashs = []; }
    let splindex = 0, startspseamindex = -1;
    if (shapeslabsplash.slabsplashs.length == 0) { splindex = shapeslabsplash.slabsplashs.length, initslabsplash31(splindex, spsplashindex, spsideindex, spseamindex, partsrno, areaid); }
    if (shapeslabsplash.slabsplashs.length == 1) { // not seamed
        setslabsplashinfo31(splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape.materialid);
        drawslabsplash31(shapeslabsplash.index, 'setshapeslabsplashs31');
        drawslabsplashseams31(splindex, spsplashindex, source);
    } else {
        let tmpshapeslabsplash = JSON.parse(JSON.stringify(partshape.sides[spsideindex].splashs[spsplashindex]));
        for (let i = 0; i < tmpshapeslabsplash.seams.length; i++) {
           // console.log("splindex:" + splindex, "spseamindex:" + spseamindex, "startspseamindex:" + startspseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "issplit:" + tmpshapeslabsplash.seams[i].split, tmpshapeslabsplash.seams.length);
            if (tmpshapeslabsplash.seams[i].split == 1) {
                shapeslabsplash = JSON.parse(JSON.stringify(partshape.sides[spsideindex].splashs[spsplashindex]));
                setslabsplashinfo31(splindex, i, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape.materialid);
                setseamedslabsplash31(splindex, startspseamindex, i);               
                drawslabsplash31(shapeslabsplash.index, 'setshapeslabsplashs31');
                startspseamindex = i;
                splindex++;
            }            
            //seamed slab splashes
        }       
        shapeslabsplash = JSON.parse(JSON.stringify(partshape.sides[spsideindex].splashs[spsplashindex]));
        setslabsplashinfo31(splindex, startspseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape.materialid);
        setseamedslabsplash31(splindex, startspseamindex, -1);
       // console.log("splindex:" + splindex, "spseamindex:" + spseamindex, "startspseamindex:" + startspseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "spsplashseamcount" + shapeslabsplash.seams.length, source);
        drawslabsplash31(shapeslabsplash.index, 'setshapeslabsplashs31');
    }   
}
function setpartshapeslabsplashs31(partshape) {
    //1.sceanrios 1. no slabaprt. 2. non seamed slabaprt 3. seamed slabpart 
    partshape = parsepartshape(partshape);
    if (partshape.sides != null && partshape.sides != undefined) {
        for (let i = 0; i < partshape.sides.length; i++) {
            for (let j = 0; j < partshape.sides[i].splashs.length; j++) {
                if (partshape.sides[i].splashs[j].isactive == 1) { setshapesplashslabsplashs31(-1, j, i, partshape, 'setpartshapeslabsplashs31'); }                
            }
        }
    }
}
function setseamedslabsplash31(splindex, startseamindex, endseamindex) {
   // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex);   
    if (startseamindex != -1) { setseamedsplashstartpos31(startseamindex); }
    if (endseamindex != -1) { setseamedsplashendpos31(endseamindex); }
    setseamedsplashseams();
}
function setseamedsplashstartpos31(seamindex) {
    let  seam = shapeslabsplash.seams[seamindex];
    let sx11 = seam.x1, sy11 = seam.y1, sx21 = seam.x2, sy21 = seam.y2, sx1 = (sx11 + sx21) / 2, sy1 = (sy11 + sy21) / 2;
    shapeslabsplash.x11 = sx11, shapeslabsplash.y11 = sy11, shapeslabsplash.x21 = sx21, shapeslabsplash.y21 = sy21;   
}
function setseamedsplashendpos31(seamindex) {
    let seam = shapeslabsplash.seams[seamindex];    
    let sx12 = seam.x1, sy12 = seam.y1, sx22 = seam.x2, sy22 = seam.y2, sx2 = (sx12 + sx22) / 2, sy2 = (sy12 + sy22) / 2;
    shapeslabsplash.x12 = sx12, shapeslabsplash.y12 = sy12, shapeslabsplash.x22 = sx22, shapeslabsplash.y22 = sy22;
}
function setseamedsplashseams() {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let nseams = [];
    for (let j = 0; j < shapeslabsplash.seams.length; j++) {
        let seam = JSON.parse(JSON.stringify(shapeslabsplash.seams[j]));    
        if (seam.split == 0) {
            let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2;
            let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
           // console.log(j, x11, y11, x12, y12, sx1, sy1, isinline);
            if (isinline) { nseams.push(seam); }
        }
    }
    shapeslabsplash.seams = nseams;
}
function onsetslabsplash31(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, source) {    
    setslabsplash32(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, source);
    setslabsplashgroups31(index, source);
}
function onslabsplash() {
    if (drawmode == 7) {
        d3.event.stopPropagation();
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let splindex = parseInt(this.getAttribute("splindex"));
        let spseamindex = parseInt(this.getAttribute("spseamindex"));
        let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
        let spsideindex = parseInt(this.getAttribute("spsideindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        onsetslabsplash31(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, 'onslabsplash');
        let m = d3.mouse(this);   
        onsetslabsplashseam31(m[0], m[1], -1, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid);
        setdrawmode(0);
    }
}
function onslabsplashcontextmenu() {
    removeshapecontrols();
    d3.event.preventDefault();
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let splindex = parseInt(this.getAttribute("splindex"));
    let spseamindex = parseInt(this.getAttribute("spseamindex"));
    let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    onsetslabsplash31(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, 'onslabsplashcontextmenu');
    let m = d3.mouse(this);
    drawslabsplashcontrols(index, m[0], m[1]);
}
function onrotateslabsplash(type, index, angle) {
    let npt = [];
    slabsplashg = mslabpartsg.select("#slabsplashg" + index);
    //drawslabsplashcontrols(index, m[0], m[1]);
    if (!slabsplashg.empty()) {       
        if (type == 0) { shapeslabsplash.angle = angle; }
        else if (type == 1) { shapeslabsplash.angle += angle; }
        else if (type == -1) { shapeslabsplash.angle -= angle; }        
        rotateslabsplashtext();
        rotateslabsplash();
        $('#slabsplashctlinputangle' + index).val(shapeslabsplash.angle);
        if (type != 0) { ActionSlabSplash31('onrotateslabsplash'); }
    }
}
function rotateslabsplash() {
    let gnode = slabsplashg.node();
    let sx = gnode.getBBox().x + gnode.getBBox().width / 2; sy = gnode.getBBox().y + gnode.getBBox().height / 2;
    let npt = [sx.toFixed(), sy.toFixed()];
    slabsplashg.attr("transform", "rotate(" + shapeslabsplash.angle + "," + npt + ")");   
}
function rotateslabsplashtext() {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let angle = calclineangle2(x11, y11, x12, y12);
    if (angle != 0) { angle += 180; }
    let splashtextg = slabsplashg.select("#slabsplashtext" + shapeslabsplash.index);
    let gnode = splashtextg.node();
    let sx = gnode.getBBox().x; sy = gnode.getBBox().y;
    let npt = [sx.toFixed(), sy.toFixed()];
    //console.log(shapeslabsplash.index, sx, sy, angle);
    splashtextg.attr("transform", "rotate(" + angle + "," + npt + ")");
}
function onseamslabsplash31(spseamindex, spsplashindex) {
    //console.log(spseamindex, spsplashindex);
    removeshapecontrols();
    let splindex = shapeslabsplash.splindex,  spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
   // console.log(seamindex, splashindex, seamindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid);
    //1.get part and set partshape
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    //2.set new slabsplash
    setslabsplash30(-1, spseamindex,  spsplashindex, spsideindex, partsrno, areaid, partshape);
    //4. set part slabparts  
    setshapesplashslabsplashs31(spseamindex, spsplashindex, spsideindex, partshape, 'onseamslabsplash31');
    //5.update part shape in scope
    ActionSeamSlabSplash31(spseamindex, spsideindex, 'onseamslabpart31');
}
function ondeleteslabsplash(index) {
    removeshapecontrols();
    //1.remove slabsplash shapes
    deleteslabsplashshapes();
    //2.get part and set partshape
    let partshape = getpartshapecopybyareaidpartsrno(shape.partsrno, shape.areaid);
    shapeslabsplash.seams[spseamindex].split = 1;
    //3.set seam 
    //4. set part slabparts  
    setpartshapeslabparts31(partshape);
}
function deleteslabsplashshapes() {
    for (let i = 0; i < shapeslabsplash.slabsplashs.length; i++) {
        let shapeslabsplashindex = shapeslabsplash.partsrno + "" + shapeslabsplash.spsideindex + "" + shapeslabsplash.spsplashindex + "" + shapeslabsplash.splindex;       
        $("#slabsplashouterg" + shapeslabsplashindex).remove();
    }
}
function drawslabsplash31(index) {    
    setslabsplashgroups31(index, 'drawslabsplash31');
    let sideindex = shapeslabsplash.shapesideindex, sidecode = shapeslabsplash.sidecode, width = shapeslabsplash.width, height = shapeslabsplash.height, type = shapeslabsplash.type;
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let x21 = shapeslabsplash.x21, y21 = shapeslabsplash.y21, x22 = shapeslabsplash.x22, y22 = shapeslabsplash.y22;
    let splindex = shapeslabsplash.splindex;
    let edge1type = shapeslabsplash.edges[0].type, edge2type = shapeslabsplash.edges[1].type, edge3type = shapeslabsplash.edges[2].type, edge4type = shapeslabsplash.edges[3].type;
    slabsplashg.selectAll('*').remove();
    drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, width, height);
    drawslabsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type);
    drawslabsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type);
    drawslabsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type);
    drawslabsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type);
    transformslabsplash();
    rotateslabsplashtext();
    rotateslabsplash();    
    drawslabsplashseams31(splindex, index, 'drawslabsplash31');
    //if (layoutmode == 2) { onsetslabsplashclipimage(index); }
}
function drawslabsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    let eclass = sideedgeclass(edgetype);
    let spgindex = splashindex;
    let splindex = splashindex + "" + lineindex;
    let splline = slabsplashg.select("#slabsplash" + splindex);
    if (splline.empty()) { splline = slabsplashg.append("line").attr("id", "slabsplash" + splindex); }
    splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("edgetype", edgetype);
}
function drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, w, h) {
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sclass = 'shapesplash', smode = 'slabsplash';
    let splindex = shapeslabsplash.splindex, spseamindex = shapeslabsplash.spseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex,
        partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid, areaindex = shapeslabsplash.areaindex, splcolor = shapeslabsplash.color;
    let splashpath = slabsplashg.select("#slabsplashpath" + index);
    if (splashpath.empty()) { splashpath = slabsplashg.append("path").attr("id", "slabsplashpath" + index); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("splindex", splindex).attr("spseamindex", spseamindex).attr("spsplashindex", spsplashindex)
        .attr("spsideindex", spsideindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("d", spath);
    splashpath.attr("style", "fill:" + splcolor).style("fill-opacity", "0.2");
    splashpath.on("click", onslabsplash).on("contextmenu", onslabsplashcontextmenu);
    let npt = calcenterpoint(x11, y11, x12, y12, x21, y21, x22, y22, w, w);
    let sptx = npt.dx, spty = npt.dy + 4;
    let spltext = 'A' + (areaindex) + ':P' + (partsrno) + ':S' + (parseInt(splindex) + 1) + ':' + w  + ' x ' + h;
    let splashtextg = slabsplashg.select("#slabsplashtext" + index);
    if (splashtextg.empty()) { splashtextg = slabsplashg.append("text").attr("id", "slabsplashtext" + index); }
    splashtextg.attr("x", sptx).attr("y", spty).text(spltext);
}
function transformslabsplash() {
    let ztx = Math.round(shapeslabsplash.tx), zty = Math.round(shapeslabsplash.ty);
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    slabsplashouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function slabsplashdragstarted() {
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        let index = parseInt(this.getAttribute("index"));        
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let splindex = parseInt(this.getAttribute("splindex"));
        let spseamindex = parseInt(this.getAttribute("spseamindex"));
        let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
        let spsideindex = parseInt(this.getAttribute("spsideindex"));      
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));        
        onsetslabsplash31(index, splindex, spseamindex, spsplashindex, spsideindex, partsrno, areaid, 'slabsplashdragstarted');
        bdrag = true;
    }
    removeshapecontrols();
}
function slabsplashdragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));        
        let ndx = this.x || shapeslabsplash.tx;
        let ndy = this.y || shapeslabsplash.ty;
        ndx += d3.event.dx;
        ndy += d3.event.dy;
        let stx = shapeslabsplash.tx, sty = shapeslabsplash.ty;
        let sgscale = getslabpartshapesgscale();
        shapeslabsplash.tx = Math.round(ndx), shapeslabsplash.ty = Math.round(ndy);
        transformslabsplash();        
        if (!isslabpartinbounds(sgscale)) {
            shapeslabsplash.tx = Math.round(stx), shapeslabsplash.ty = Math.round(sty);
            transformslabsplash();
        }
    }
}
function slabsplashdragended() {
    if (bdrag) {
        bdrag = false;
        ondragslabsplash32();
        ActionSlabSplash31('slabsplashdragended');
    }
}
function ondragslabsplash32() {
    //1. slabpart slab - check boundaries
    setslabsplashslabinfo32('slabsplash');
    //2. dig slabpart layout    
    if (layoutmode == 2) { drawdgshapeslabparts(); }
}
function setslabsplashslabinfo32(mode) {
    let matindex = msvg.attr("index"); 
    let mslablist = getmatslablistbyindex(matindex);    
    let slabsplashsidepathEle = document.querySelector("#" + "slabsplashpath" + shapeslabsplash.index);    
    let onslabmode = setslabpartsplashslabinfo32(matindex, slabsplashsidepathEle, mslablist, mode);
   // console.log(shapeslabsplash.index, onslabmode, shapeslabsplash.color);
    let slabpartsidepath = d3.select("#" + "slabsplashpath" + shapeslabsplash.index);
    slabpartsidepath.attr("style", "fill:" + shapeslabsplash.color).style("fill-opacity", "0.2");
}