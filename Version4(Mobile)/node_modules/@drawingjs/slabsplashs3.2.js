function initshapeslabsplash31(splindex, spsplashindex, spsideindex, partsrno, areaid) {
    let pshapeslabsplash = { index: splindex, x: 0, y: 0, tx: 0, ty: 0, angle: 0, startseamindex: -1, endseamindex: -1, spsplashindex: spsplashindex, spsideindex: spsideindex, partsrno: partsrno, areaid: areaid };
    return pshapeslabsplash;
}
function getslabsplashindex32(splindex, source) {
    let index = -1;
    for (let i = 0; i < pshapeslabsplashs.length; i++) { if (pshapeslabsplashs[i].splindex == splindex) { index = i; break; } }
    return index;
}
function getslabsplashindex33(splindex, startseamindex, pslabsplashs, source) {
    let index = -1;
    for (let i = 0; i < pslabsplashs.length; i++) { if (pslabsplashs[i].startseamindex == startseamindex) { index = i; break; } }
    return index;
}
function getslabsplashindex34(splindex, endseamindex, pslabsplashs, source) {
    let index = -1;
    for (let i = 0; i < pslabsplashs.length; i++) { if (pslabsplashs[i].endseamindex == endseamindex) { index = i; break; } }
    return index;
}
function setslabsplashgroups31(index, smode, source) {
    let splindex = shapeslabsplash.splindex, startseamindex = shapeslabsplash.startseamindex, endseamindex = shapeslabsplash.endseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
    if (smode == undefined) { smode = 'slabsplash'; }
    if (smode == 'shapedg') {
        slabsplashouterg = mdgslabpartsg.select("#slabsplashdgouterg" + index);
        if (slabsplashouterg.empty()) { slabsplashouterg = mdgslabpartsg.append("g").attr("id", "slabsplashdgouterg" + index); }
    } else {
        slabsplashouterg = mslabpartsg.select("#slabsplashouterg" + index);
        if (slabsplashouterg.empty()) { slabsplashouterg = mslabpartsg.append("g").attr("id", "slabsplashouterg" + index); }
    }
    slabsplashouterg.attr("index", index).attr("smode", smode).attr("splindex", splindex).attr("startseamindex", startseamindex).attr("endseamindex", endseamindex).attr("spsplashindex", spsplashindex).attr("spsideindex", spsideindex).attr("partsrno", partsrno).attr("areaid", areaid);
    slabsplashg = slabsplashouterg.select("#slabsplashg" + index);
    if (slabsplashg.empty()) { slabsplashg = slabsplashouterg.append("g").attr("id", "slabsplashg" + index); }
    slabsplashouterg.call(slabsplashdrag);
}
function setpartshapeslabsplashs31(partshape) {
    //1.sceanrios 1. no slabaprt. 2. non seamed slabaprt 3. seamed slabpart 
    partshape = parsepartshape(partshape);
    if (partshape.sides != null && partshape.sides != undefined) {
        for (let i = 0; i < partshape.sides.length; i++) {
            for (let j = 0; j < partshape.sides[i].splashs.length; j++) {
                if (partshape.sides[i].splashs[j].isactive == 1) { setshapesplashslabsplashs31(j, i, partshape, 'setpartshapeslabsplashs31'); }
            }
        }
    }
}
function setslabsplashtransformcoords32(pshapeslabsplash, source) {
    if (pshapeslabsplash.tx == undefined) { pshapeslabsplash.tx = 0; } if (pshapeslabsplash.ty == undefined) { pshapeslabsplash.ty = 0; }
    let ztx = pshapeslabsplash.tx, zty = pshapeslabsplash.ty, stscale = pshapeslabsplash.tscale;
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12,
        x21 = shapeslabsplash.x21, y21 = shapeslabsplash.y21, x22 = shapeslabsplash.x22, y22 = shapeslabsplash.y22;
    let spdxy = 10, minstx1 = Math.min(x11, x12, x21, x22), minsty1 = Math.min(y11, y12, y21, y22), maxstw1 = shapeslabsplash.width;
    if ((ztx + minstx1) < 0) { ztx = -minstx1; }
    else if ((ztx + minstx1 + maxstw1) > lwidth) {
        ztx -= (ztx + minstx1 + maxstw1 - lwidth);
    } else {
        ztx = slabpartx, zty = slabparty;
        slabpartx += spdxy, slabparty += spdxy;
        // console.log("sindex:" + shape.index, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "minstx1:" + minstx1, "minsty1:" + minsty1, "maxstw1:" + maxstw1);
    }
    if ((zty + minsty1) < 0) { zty = -minsty1; }
    pshapeslabsplash.tx = ztx, pshapeslabsplash.ty = zty;
}
function setslabsplashangle() {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let angle = calclineangle2(x11, y11, x12, y12, 'slabsplashangle');
    shapeslabsplash.angle = angle;
}
function setshapeslabsplash31(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, tmppshapeslabsplashs, source) {
    let index1 = getslabsplashindex33(splindex, startseamindex, tmppshapeslabsplashs, source);
    let pshapeslabsplash = {};
    if (index1 == -1) {
        pshapeslabsplash = initshapeslabsplash31(pshapeslabsplashs.length, spsplashindex, spsideindex, partsrno, areaid); pshapeslabsplash.color = shape.color;
    } else { pshapeslabsplash = tmppshapeslabsplashs[index1]; }
    if (index1 == -1) {
        if (splindex == 0) {
            setslabsplashtransformcoords32(pshapeslabsplash, source);
        }
        if (splindex > 0) {
            let index2 = getslabsplashindex34(splindex, startseamindex, tmppshapeslabsplashs, source); //prev slabpart endseamindex and endsideindex = curr startendindex and startseamindex
            let index3 = getslabsplashindex32(splindex - 1, source);     //to be safe side not to error out      
            //console.log("index1:" + index1, "index2:" + index2, "index3:" + index3, "startseamindex:" + startseamindex, JSON.stringify(tmppshapeslabsplashs), source)
            if (index2 == -1) { index2 = index3; }//to be safe side not to error out
            if (tmppshapeslabsplashs[index2] != undefined) {
                pshapeslabsplash.tx = tmppshapeslabsplashs[index2].tx;
                pshapeslabsplash.ty = tmppshapeslabsplashs[index2].ty;
                pshapeslabsplash.angle = tmppshapeslabsplashs[index2].angle;
                pshapeslabsplash.slabindex = tmppshapeslabsplashs[index2].slabindex;
                pshapeslabsplash.slabid = tmppshapeslabsplashs[index2].slabid;
                pshapeslabsplash.slabx = tmppshapeslabsplashs[index2].slabx;
                pshapeslabsplash.slaby = tmppshapeslabsplashs[index2].slaby;
                pshapeslabsplash.clipx = tmppshapeslabsplashs[index2].clipx;
                pshapeslabsplash.clipy = tmppshapeslabsplashs[index2].clipy;
                pshapeslabsplash.rtx = tmppshapeslabsplashs[index2].rtx;
                pshapeslabsplash.rty = tmppshapeslabsplashs[index2].rty;
            }
        }
    }
    pshapeslabsplash.startseamindex = startseamindex;
    pshapeslabsplash.endseamindex = endseamindex;
    pshapeslabsplash.spsplashindex = spsplashindex;
    pshapeslabsplash.spsideindex = spsideindex;
    pshapeslabsplash.splindex = splindex;
    pshapeslabsplash.partsrno = partsrno;
    pshapeslabsplash.areaid = areaid;
    pshapeslabsplash.areaindex = areaindex;
    pshapeslabsplash.index = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    //pshapeslabsplash.materialid = materialid;
    //  console.log("index1:" + index1, "splindex:" + splindex, "startseamindex:" + startseamindex, JSON.stringify(pshapeslabsplash), "source:" + source);
    pshapeslabsplashs.push(pshapeslabsplash);
    return pshapeslabsplash;
}
function setslabsplash32(splindex, source) {
    source += ":" + "setslabsplash32";
    let index1 = getslabsplashindex32(splindex, source);
    let pshapeslabsplash = pshapeslabsplashs[index1];
    if (pshapeslabsplash != undefined) {
        pshapeslabsplash.tx = shapeslabsplash.tx;
        pshapeslabsplash.ty = shapeslabsplash.ty;
        pshapeslabsplash.angle = shapeslabsplash.angle;
        pshapeslabsplash.slabindex = shapeslabsplash.slabindex;
        pshapeslabsplash.slabid = shapeslabsplash.slabid;
        pshapeslabsplash.slabx = shapeslabsplash.slabx;
        pshapeslabsplash.slaby = shapeslabsplash.slaby;
        pshapeslabsplash.clipx = shapeslabsplash.clipx;
        pshapeslabsplash.clipy = shapeslabsplash.clipy;
        pshapeslabsplash.color = shapeslabsplash.color;
        pshapeslabsplash.rtx = shapeslabsplash.rtx;
        pshapeslabsplash.rty = shapeslabsplash.rty;
    }
    let npshapeslabsplashs = JSON.parse(JSON.stringify(pshapeslabsplashs));
    ActionUpdateSlabSplash32(npshapeslabsplashs, source);
    //console.log("index1:" + index1, "spindex:" + spindex, "pslabpart:" + JSON.stringify(pslabpart));
    //console.log("index1:" + index1, "spindex:" + spindex, "startseamindex:" + startseamindex, "startsideindex:" + startsideindex, "slabparttx:" + pslabpart.tx, "slabpartty:" + pslabpart.ty, "source:" + source);
    return pshapeslabsplash;
}
function setslabsplashinfo31(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source) {
    // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "source:" + source);
    shapeslabsplash = JSON.parse(JSON.stringify(partshape.sides[spsideindex].splashs[spsplashindex]));
    shapeslabsplash.startseamindex = startseamindex;
    shapeslabsplash.endseamindex = endseamindex;
    shapeslabsplash.spsplashindex = spsplashindex;
    shapeslabsplash.spsideindex = spsideindex;
    shapeslabsplash.splindex = splindex;
    shapeslabsplash.partsrno = partsrno;
    shapeslabsplash.areaid = areaid;
    shapeslabsplash.areaindex = areaindex;
    shapeslabsplash.index = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let tmppshapeslabsplashs = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs;
    let pshapeslabsplash = setshapeslabsplash31(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, tmppshapeslabsplashs, source);
    if (pshapeslabsplash != undefined) {
        shapeslabsplash.tx = pshapeslabsplash.tx;
        shapeslabsplash.ty = pshapeslabsplash.ty;
        shapeslabsplash.angle = pshapeslabsplash.angle;
        shapeslabsplash.slabx = pshapeslabsplash.slabx;
        shapeslabsplash.slaby = pshapeslabsplash.slaby;
        shapeslabsplash.clipx = pshapeslabsplash.clipx;
        shapeslabsplash.clipy = pshapeslabsplash.clipy;
        shapeslabsplash.slabid = pshapeslabsplash.slabid;
        shapeslabsplash.slabindex = pshapeslabsplash.slabindex;
        shapeslabsplash.color = pshapeslabsplash.color;
        shapeslabsplash.rtx = pshapeslabsplash.rtx;
        shapeslabsplash.rty = pshapeslabsplash.rty;
    }
    //console.log(JSON.stringify(shapeslabsplash));
}
function setslabsplashinfo32(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source) {
    // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "source:" + source);
    shapeslabsplash = JSON.parse(JSON.stringify(partshape.sides[spsideindex].splashs[spsplashindex]));
    shapeslabsplash.startseamindex = startseamindex;
    shapeslabsplash.endseamindex = endseamindex;
    shapeslabsplash.spsplashindex = spsplashindex;
    shapeslabsplash.spsideindex = spsideindex;
    shapeslabsplash.splindex = splindex;
    shapeslabsplash.partsrno = partsrno;
    shapeslabsplash.areaid = areaid;
    shapeslabsplash.areaindex = areaindex;
    shapeslabsplash.materialid = partshape.materialid;
    shapeslabsplash.index = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let index1 = getslabsplashindex32(splindex, source);
    let index2 = getslabsplashindex33(splindex, startseamindex, pshapeslabsplashs, source);
    let pshapeslabsplash = pshapeslabsplashs[index1];
    if (pshapeslabsplash != undefined) {
        pshapeslabsplash.startseamindex = startseamindex;
        pshapeslabsplash.endseamindex = endseamindex;
        pshapeslabsplash.spsplashindex = spsplashindex;
        pshapeslabsplash.spsideindex = spsideindex;
        pshapeslabsplash.splindex = splindex;
        pshapeslabsplash.partsrno = partsrno;
        pshapeslabsplash.areaid = areaid;
        pshapeslabsplash.areaindex = areaindex;

        shapeslabsplash.tx = pshapeslabsplash.tx;
        shapeslabsplash.ty = pshapeslabsplash.ty;
        shapeslabsplash.angle = pshapeslabsplash.angle;
        shapeslabsplash.slabx = pshapeslabsplash.slabx;
        shapeslabsplash.slaby = pshapeslabsplash.slaby;
        shapeslabsplash.clipx = pshapeslabsplash.clipx;
        shapeslabsplash.clipy = pshapeslabsplash.clipy;
        shapeslabsplash.slabid = pshapeslabsplash.slabid;
        shapeslabsplash.slabindex = pshapeslabsplash.slabindex;
        shapeslabsplash.color = pshapeslabsplash.color;
        shapeslabsplash.rtx = pshapeslabsplash.rtx;
        shapeslabsplash.rty = pshapeslabsplash.rty;
    }
    // console.log("index1:" + index1, "index2:" + index2, "splindex:" + splindex, "startseamindex:" + startseamindex, JSON.stringify(pshapeslabsplash), "source:" + source);
}
function setshapesplashslabsplashs31(spsplashindex, spsideindex, partshape, source) {
    source += ':setshapeslabsplashs31';
    let partsrno = partshape.partsrno, areaid = partshape.areaid, areaindex = partshape.areaindex, splindex = 0, startseamindex = -1, endseamindex = -1;
    if (partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == undefined || partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == null) {
        partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs = [];
    }
    // pshapeslabsplashs = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs;
    pshapeslabsplashs = [];
    // console.log(spsplashindex, spsideindex, JSON.stringify(pshapeslabsplashs));
    // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "pshapeslabsplashs" + pshapeslabsplashs.seams.length, "spsplashseamcount" + shapeslabsplash.seams.length, source);
    for (let i = 0; i < partshape.sides[spsideindex].splashs[spsplashindex].seams.length; i++) {
        // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "issplit:" + tmpshapeslabsplash.seams[i].split, tmpshapeslabsplash.seams.length);
        if (partshape.sides[spsideindex].splashs[spsplashindex].isactive == 1 && partshape.sides[spsideindex].splashs[spsplashindex].seams[i].split == 1) {
            endseamindex = i;
            setslabsplashinfo31(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source);
            setseamedslabsplash31(splindex, startseamindex, endseamindex);
            drawslabsplash31(shapeslabsplash.index, source);
            startseamindex = i;
            splindex++;
        }
        //seamed slab splashes
    }
    endseamindex = -1;
    setslabsplashinfo31(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source);
    setseamedslabsplash31(splindex, startseamindex, endseamindex);
    pshapeslabsplashs = pshapeslabsplashs.sort((a, b) => (a.index > b.index) ? 1 : -1);
    //console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "spsplashseamcount" + shapeslabsplash.seams.length, source);
    drawslabsplash31(shapeslabsplash.index, source);
    let npshapeslabsplashs = JSON.parse(JSON.stringify(pshapeslabsplashs));
    updatepartshapeslabsplashs32(partsrno, areaid, npshapeslabsplashs, source);
    //console.log(JSON.stringify(npshapeslabsplashs));
}
function setshapesplashslabsplashs32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, source) {
    source += ':setshapesplashslabsplashs32';
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    pshapeslabsplashs = [];
    if (partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == undefined || partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == null) {
        return;
    }
    let areaindex = partshape.areaindex;
    pshapeslabsplashs = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs;
    pshapeslabsplashs = pshapeslabsplashs.sort((a, b) => (a.index > b.index) ? 1 : -1);
    // console.log(spsplashindex, spsideindex, JSON.stringify(pshapeslabsplashs));
    //let partshapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex];
    //for (let i = 0; i < partshapeslabsplash.seams.length; i++) {
    //    if (i != startseamindex) {
    //        // console.log("splindex:" + splindex, "startseamindex:" + startseamindex,  "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "issplit:" + tmpshapeslabsplash.seams[i].split, tmpshapeslabsplash.seams.length);
    //        if (partshapeslabsplash.seams[i].isactive == 1 && partshapeslabsplash.seams[i].split == 1) {
    //            endseamindex = i;
    //            break;
    //        }
    //    }
    //}
    //console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "spsplashseamcount" + shapeslabsplash.seams.length, source);
    setslabsplashinfo32(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source);
    setseamedslabsplash31(splindex, startseamindex, endseamindex);
}
function setshapesplashslabsplashs33(spsplashindex, spsideindex, partshape, source) {
    source += ':setshapesplashslabsplashs33';
    let partsrno = partshape.partsrno, areaid = partshape.areaid, areaindex = partshape.areaindex, splindex = 0, startseamindex = -1, endseamindex = -1;
    if (partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == undefined || partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs == null) {
        partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs = [];
    }
    pshapeslabsplashs = [];
    pshapeslabsplashs = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs;
    for (let i = 0; i < partshape.sides[spsideindex].splashs[spsplashindex].seams.length; i++) {
        // console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "issplit:" + tmpshapeslabsplash.seams[i].split, tmpshapeslabsplash.seams.length);
        if (partshape.sides[spsideindex].splashs[spsplashindex].isactive == 1 && partshape.sides[spsideindex].splashs[spsplashindex].seams[i].split == 1) {
            endseamindex = i;
            setslabsplashinfo32(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source);
            setseamedslabsplash31(splindex, startseamindex, endseamindex);
            drawslabsplash31(shapeslabsplash.index, source);
            startseamindex = i;
            splindex++;
        }
        //seamed slab splashes
    }
    endseamindex = -1;
    setslabsplashinfo32(splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, areaindex, partshape, source);
    setseamedslabsplash31(splindex, startseamindex, endseamindex);
    pshapeslabsplashs = pshapeslabsplashs.sort((a, b) => (a.index > b.index) ? 1 : -1);
    //console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex, "spsplashindex:" + spsplashindex, "spsideindex:" + spsideindex, "spsplashseamcount" + shapeslabsplash.seams.length, source);
    drawslabsplash31(shapeslabsplash.index, source);
}
function setseamedslabsplash31(splindex, startseamindex, endseamindex) {
    //console.log("splindex:" + splindex, "startseamindex:" + startseamindex, "endseamindex:" + endseamindex);   
    if (startseamindex != -1) { setseamedsplashstartpos31(startseamindex); }
    if (endseamindex != -1) { setseamedsplashendpos31(endseamindex); }
    setseamedsplashseams();
}
function setseamedsplashstartpos31(seamindex) {
    //console.log(seamindex, shapeslabsplash.seams.length);
    let seam = shapeslabsplash.seams[seamindex];
    let sx11 = seam.x1, sy11 = seam.y1, sx21 = seam.x2, sy21 = seam.y2, sx1 = (sx11 + sx21) / 2, sy1 = (sy11 + sy21) / 2;
    shapeslabsplash.x11 = sx11, shapeslabsplash.y11 = sy11, shapeslabsplash.x21 = sx21, shapeslabsplash.y21 = sy21;
}
function setseamedsplashendpos31(seamindex) {
    let seam = shapeslabsplash.seams[seamindex];
    let sx12 = seam.x1, sy12 = seam.y1, sx22 = seam.x2, sy22 = seam.y2, sx2 = (sx12 + sx22) / 2, sy2 = (sy12 + sy22) / 2;
    shapeslabsplash.x12 = sx12, shapeslabsplash.y12 = sy12, shapeslabsplash.x22 = sx22, shapeslabsplash.y22 = sy22;
}
function setseamedsplashseams() {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let nseams = [];
    for (let j = 0; j < shapeslabsplash.seams.length; j++) {
        let seam = JSON.parse(JSON.stringify(shapeslabsplash.seams[j]));
        if (seam.split == 0) {
            let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2;
            let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
            // console.log(j, x11, y11, x12, y12, sx1, sy1, isinline);
            if (isinline) { nseams.push(seam); }
        }
    }
    shapeslabsplash.seams = nseams;
}
function onsetslabsplash32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, smode, source) {
    //console.log(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, shapeslabsplash.seams.length, source);
    setshapesplashslabsplashs32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
    setslabsplashgroups31(index, smode, source);
}
function onaddslabsplashseam32(index, sideindex, source) {
    source += ":" + "onaddslabsplashseam32";
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex,
       splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    setshapesplashslabsplashs33(spsplashindex, spsideindex, partshape, source);
}
function ondragslabsplashseam32(index, splashindex, source) {
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    setshapesplashslabsplashs31(spsplashindex, spsideindex, partshape, 'ondragslabsplashseam32');
}
function onseamslabsplash32(index, spseamindex, splashindex, source) {
    removeshapecontrols();
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    // console.log(index, splashindex, spsideindex, spsplashindex, partshape.sides[spsideindex].splashs[spsplashindex].seams.length, source);
    partshape.sides[spsideindex].splashs[spsplashindex].seams[spseamindex].split = 1;
    setshapesplashslabsplashs31(spsplashindex, spsideindex, partshape, 'onseamslabsplash32');
}
function ondeleteslabsplashseam32(index, splashindex) {
    removeshapecontrols();
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    setshapesplashslabsplashs31(spsplashindex, spsideindex, partshape, 'ondeleteslabsplashseam32');
}
function ondeleteslabsplash32(index) {
    let source = 'ondeleteslabsplash';
    removeshapecontrols();
    //$("#slabpartouter" + shape.index).remove();
    removeslabsplashshapes32();
    //removedgsslabsplashs32(shape.partsrno, shape.spindex, shape.areaid, source);
    //1.get part and set partshape
    let spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    //4. set part slabparts  
    setshapesplashslabsplashs31(spsplashindex, spsideindex, partshape, source);
}
function removeslabsplashshapes32() {
    for (let i = 0; i < shapeslabsplash.slabsplashs.length; i++) {
        let splindex = shapeslabsplash.splindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
        let shapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + i;
        //console.log(i, shapeslabsplash.slabsplashs.length, i, shapeslabsplashindex)
        $("#slabsplashouterg" + shapeslabsplashindex).remove();
    }
}
function onslabsplash() {
    if (drawmode == 7) {
        d3.event.stopPropagation();
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let splindex = parseInt(this.getAttribute("splindex"));
        let startseamindex = parseInt(this.getAttribute("startseamindex"));
        let endseamindex = parseInt(this.getAttribute("endseamindex"));
        let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
        let spsideindex = parseInt(this.getAttribute("spsideindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        onsetslabsplash32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, 'slabsplash', 'onslabsplash');
        let m = d3.mouse(this);
        onsetslabsplashseam31(m[0], m[1], -1, splindex, startseamindex, spsplashindex, spsideindex, partsrno, areaid);
        setdrawmode(0);
    }
}
function onslabsplashcontextmenu() {
    removeshapecontrols();
    d3.event.preventDefault();
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let splindex = parseInt(this.getAttribute("splindex"));
    let startseamindex = parseInt(this.getAttribute("startseamindex"));
    let endseamindex = parseInt(this.getAttribute("endseamindex"));
    let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    onsetslabsplash32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, 'slabsplash', 'onslabsplashcontextmenu');
    let m = d3.mouse(this);
    drawslabsplashcontrols(index, m[0], m[1]);
}
function onrotateslabsplash(type, index, angle) {
    let npt = [], source = 'onrotateslabsplash';
    slabsplashg = mslabpartsg.select("#slabsplashg" + index);
    //drawslabsplashcontrols(index, m[0], m[1]);
    if (!slabsplashg.empty()) {
        if (type == 0) { shapeslabsplash.angle = angle; }
        else if (type == 1) { shapeslabsplash.angle += angle; }
        else if (type == -1) { shapeslabsplash.angle -= angle; }
        //setslabsplashcentercords32(source);
        rotateslabsplash33(index, source);
        if (layoutmode == 2) { onsetslabsplashclipimage32(); }
        setslabsplash32(shapeslabsplash.splindex, source);
    }
}
function ondragendslabsplash32(source) {
    //1. slabpart slab - check boundaries
    oncheckslabsplashslabbounds34(source);
    //2. dig slabpart layout    
    if (layoutmode == 2) { onsetslabsplashclipimage32(); }    
    setslabsplash32(shapeslabsplash.splindex, source);
}
function setslabsplashcentercords32(source) {
    let gnode = slabsplashg.node();
    let sx = gnode.getBBox().x + gnode.getBBox().width / 2; sy = gnode.getBBox().y + gnode.getBBox().height / 2;
    let npt = [sx.toFixed(), sy.toFixed()];
    shapeslabsplash.rtx = sx.toFixed(), shapeslabsplash.rty = sy.toFixed();
    //console.log(shapeslabsplash.rtx, shapeslabsplash.rty)
}
function rotateslabsplash33(index, source) {
    if (shapeslabsplash.angle == undefined) { return; }
    let npt = {};
    if (!slabsplashg.empty()) {
        setslabsplashcentercords32(source);
        // if (shapeslabsplash.rtx == undefined) { setslabsplashcentercords32(source); }
        let npt = [shapeslabsplash.rtx, shapeslabsplash.rty];
        slabsplashg.attr("transform", "rotate(" + shapeslabsplash.angle + "," + npt + ")");
        $('#slabsplashctlinputangle' + index).val(shapeslabsplash.angle);
    }
}
function rotateslabsplashtext() {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let angle = calclineangle2(x11, y11, x12, y12);
    if (angle != 0) { angle += 180; }
    let splashtextg = slabsplashg.select("#slabsplashtext" + shapeslabsplash.index);
    let gnode = splashtextg.node();
    let sx = gnode.getBBox().x; sy = gnode.getBBox().y;
    let npt = [sx.toFixed(), sy.toFixed()];
    //console.log(shapeslabsplash.index, sx, sy, angle);
    splashtextg.attr("transform", "rotate(" + angle + "," + npt + ")");
}
function deleteslabsplashshapes32() {
    let tmppshapeslabsplashs = [];
    for (let i = 0; i < pshapeslabsplashs.length; i++) {
        let splindex = shapeslabsplash.splindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex, partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid;
        let shapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
        if (pshapeslabsplashs[i].splindex != splindex) {
            tmppshapeslabsplashs.push(pshapeslabsplashs[i]);
        }
        $("#slabsplashouterg" + shapeslabsplashindex).remove();
    }
    // console.log(pshapeslabsplashs.length, tmppshapeslabsplashs.length);
    pshapeslabsplashs = tmppshapeslabsplashs;
}
function deleteslabpartshapessplash1(partshape) {
    if (partshape.sides != null && partshape.sides != undefined) {
        for (let i = 0; i < partshape.sides.length; i++) {
            for (let j = 0; j < partshape.sides[i].splashs.length; j++) {
                let splash = partshape.sides[i].splashs[j];
                if (splash.isactive == 1) {
                    let splindex = splash.splindex, spsplashindex = splash.spsplashindex, spsideindex = splash.spsideindex, partsrno = partshape.partsrno, areaid = partshape.areaid;
                    let shapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
                    $("#slabsplashouterg" + shapeslabsplashindex).remove();
                }
            }
        }
    }
}
function drawslabsplash31(index, source) {
    source += ':drawslabsplash31';
    setslabsplashgroups31(index, 'slabsplash', source);
    let sideindex = shapeslabsplash.shapesideindex, sidecode = shapeslabsplash.sidecode, width = shapeslabsplash.width, height = shapeslabsplash.height, type = shapeslabsplash.type;
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let x21 = shapeslabsplash.x21, y21 = shapeslabsplash.y21, x22 = shapeslabsplash.x22, y22 = shapeslabsplash.y22;
    let splindex = shapeslabsplash.splindex;
    let edge1type = shapeslabsplash.edges[0].type, edge2type = shapeslabsplash.edges[1].type, edge3type = shapeslabsplash.edges[2].type, edge4type = shapeslabsplash.edges[3].type;
    //console.log(index, edge1type, edge2type, edge3type, edge4type);
    slabsplashg.selectAll('*').remove();
    drawslabsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type);
    drawslabsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type);
    drawslabsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type);
    drawslabsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type);
    drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, width, height);
    transformslabsplash(source);
    //rotateslabsplashtext();
    rotateslabsplash33();
    drawslabsplashseams31(splindex, index, source);
}
function drawslabsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    let eclass = sideedgeclass(edgetype);
    let spgindex = splashindex, splindex = shapeslabsplash.splindex, areaid = shapeslabsplash.areaid,  partsrno = shapeslabsplash.partsrno, areaindex = shapeslabsplash.areaindex;
    let spllineindex = areaid + "" + partsrno + "" + splashindex + "" + lineindex;
    let splline = slabsplashg.select("#slabsplash" + spllineindex);
    if (splline.empty()) { splline = slabsplashg.append("path").attr("id", "slabsplash" + spllineindex); }
    let spath = "M" + x1 + "," + y1 + "l" + (x2 - x1) + "," + (y2 - y1);
    splline.attr("d", spath).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("edgetype", edgetype);
    //splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("edgetype", edgetype);
    if (lineindex == 1) {
        let slabsplashtext = slabsplashg.select("#slabsplashtext" + spllineindex);
        let spltext = 'A' + (areaindex) + ':S' + (partsrno) + "." + (splindex + 1);
        if (slabsplashtext.empty()) {
            slabsplashtext = slabsplashg.append("text").append("textPath").attr("id", "slabsplashtext" + spllineindex)
            .attr("xlink:href", "#slabsplash" + spllineindex).attr("startOffset", 5).attr("style", "fill:grey;font-size:10px;").text(spltext);
        }
    }
}
function drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, w, h) {
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sclass = 'shapesplash', smode = 'slabsplash';
    let splindex = shapeslabsplash.splindex, startseamindex = shapeslabsplash.startseamindex, endseamindex = shapeslabsplash.endseamindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex,
        partsrno = shapeslabsplash.partsrno, areaid = shapeslabsplash.areaid, areaindex = shapeslabsplash.areaindex, splcolor = shapeslabsplash.color;
    let slabsplashindex = areaid + "" + partsrno + "" + index;
    let splashpath = slabsplashg.select("#slabsplashpath" + slabsplashindex);
    if (splashpath.empty()) { splashpath = slabsplashg.append("path").attr("id", "slabsplashpath" + slabsplashindex); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("splindex", splindex).attr("startseamindex", startseamindex).attr("endseamindex", endseamindex)
    .attr("spsplashindex", spsplashindex).attr("spsideindex", spsideindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("d", spath);
    splashpath.attr("style", "fill:" + splcolor).style("fill-opacity", "0.2");
    splashpath.on("click", onslabsplash).on("contextmenu", onslabsplashcontextmenu).on("mouseover", showdgslabsplashshape34).on("mouseout", hidedgslabsplashshape34);
}
function transformslabsplash(source) {
    let ztx = Math.round(shapeslabsplash.tx), zty = Math.round(shapeslabsplash.ty);
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    slabsplashouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function slabsplashdragstarted() {
    if (drawmode == 7) { return; }
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let splindex = parseInt(this.getAttribute("splindex"));
        let startseamindex = parseInt(this.getAttribute("startseamindex"));
        let endseamindex = parseInt(this.getAttribute("endseamindex"));
        let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
        let spsideindex = parseInt(this.getAttribute("spsideindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        onsetslabsplash32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, 'slabsplash', 'slabsplashdragstarted');
        bdrag = true;
    }
    removeshapecontrols();
}
function slabsplashdragged() {
    let source = 'slabsplashdragged';
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let ndx = this.x || shapeslabsplash.tx;
        let ndy = this.y || shapeslabsplash.ty;
        ndx += d3.event.dx;
        ndy += d3.event.dy;
        let stx = shapeslabsplash.tx, sty = shapeslabsplash.ty;
        let sgscale = getslabpartshapesgscale();
        shapeslabsplash.tx = Math.round(ndx), shapeslabsplash.ty = Math.round(ndy);
        transformslabsplash(source);
        if (!isslabpartinbounds(sgscale)) {
            shapeslabsplash.tx = Math.round(stx), shapeslabsplash.ty = Math.round(sty);
            transformslabsplash(source);
        }
    }
}
function slabsplashdragended() {
    let source = 'slabsplashdragended';
    if (bdrag) {
        bdrag = false;
        // console.log(shapeslabsplash.tx, shapeslabsplash.ty);
        ondragendslabsplash32(source);
    }
}

function onsetslabsplashslabinfo32(source) {
    let matindex = msvg.attr("index");
    let mslablist = getmatslablistbyindex(matindex);
    let slabsplashsidepathEle = document.querySelector("#" + "slabsplashpath" + shapeslabsplash.index);
    let onslabmode = setslabsplashslabinfo32(matindex, slabsplashsidepathEle, mslablist, source);
    //console.log(shapeslabsplash.index, onslabmode, shapeslabsplash.color);
    let slabpartsidepath = d3.select("#" + "slabsplashpath" + shapeslabsplash.index);
    slabpartsidepath.attr("style", "fill:" + shapeslabsplash.color).style("fill-opacity", "0.2");
}