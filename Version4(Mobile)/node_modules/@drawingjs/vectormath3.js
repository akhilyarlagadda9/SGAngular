function lndirection(x1, y1, x2, y2) {
    var lndir = '';
    x1 = Math.round(x1); y1 = Math.round(y1); x2 = Math.round(x2); y2 = Math.round(y2);
    if ((x1 == x2) && (y1 > y2)) {
        lndir = 'sn';//S-N direction 90 degrees  
    } else if ((x1 == x2) && (y1 < y2)) {
        lndir = 'ns'; // N-S direction 270 degrees      
    } else if ((y1 == y2) && (x1 > x2)) {
        lndir = 'ew'; //E-W direction  0 degrees  
    } else if ((y1 == y2) && (x1 < x2)) {
        lndir = 'we';//W-E direction   180 degrees 
    } else if ((x1 < x2) && (y1 > y2)) {
        lndir = 'ne';// N-E direction 0-90 degrees
    } else if ((x1 > x2) && (y1 > y2)) {
        lndir = 'nw';// N-W direction 90-180 degrees
    } else if ((x1 < x2) && (y1 < y2)) {
        lndir = 'se';// S-E direction 270-360 degrees
    } else if ((x1 > x2) && (y1 < y2)) {
        lndir = 'sw'; // S-W direction 180-270 degrees
    }
    return lndir;
}
function lndirsign(x1, y1, x2, y2) {
    var dsign = 1;
    x1 = Math.round(x1); y1 = Math.round(y1); x2 = Math.round(x2); y2 = Math.round(y2);
    if ((x1 == x2) && (y1 > y2)) {
        dsign = -1;//S-N direction 90 degrees  
    } else if ((x1 == x2) && (y1 < y2)) {
        dsign = -1; // N-S direction 270 degrees      
    } else if ((y1 == y2) && (x1 > x2)) {
        dsign = -1; //E-W direction  0 degrees
    } else if ((y1 == y2) && (x1 < x2)) {
        dsign = 1;//W-E direction   180 degrees 
    } else if ((x1 < x2) && (y1 > y2)) {
        dsign = -1;// N-E direction 0-90 degrees
    } else if ((x1 > x2) && (y1 > y2)) {
        dsign = 1;// N-W direction 90-180 degrees
    } else if ((x1 < x2) && (y1 < y2)) {
        dsign = 1;// S-E direction 270-360 degrees
    } else if ((x1 > x2) && (y1 < y2)) {
        dsign = -1;// S-W direction 180-270 degrees
    }
    return dsign;
}
function lndirsign1(x1, y1, x2, y2, x3, y3) {
    var dsign = 1;
    var d = (x3 - x1) * (y2 - y1) - (y3 - y1) * (x2 - x1);
    if (d < 0) { dsign = -1; }
    return dsign;
}
function lndirsign2(p1, p2, p3) {
    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}
function lnasign1(x1, y1, x2, y2) {
    var angrad = Math.atan2(y2 - y1, x2 - x1);
    var asign = angrad > 0 ? 1 : -1;
    return asign;
}
function lnasign(x1, y1, x2, y2) {
    var asign = 1, dsign = 1;
    x1 = Math.round(x1); y1 = Math.round(y1); x2 = Math.round(x2); y2 = Math.round(y2);
    if ((x1 == x2) && (y1 > y2)) {
        asign = 1, dsign = -1;//S-N direction 90 degrees
    } else if ((x1 == x2) && (y1 < y2)) {
        asign = -1, dsign = -1; // N-S direction 270 degrees
    } else if ((y1 == y2) && (x1 > x2)) {
        asign = -1, dsign = -1; //E-W direction  0 degrees
    } else if ((y1 == y2) && (x1 < x2)) {
        asign = -1, dsign = 1;//W-E direction   180 degrees
    } else if ((x1 < x2) && (y1 > y2)) {
        asign = 1, dsign = -1;// N-E direction 0-90 degrees
    } else if ((x1 > x2) && (y1 > y2)) {
        asign = 1, dsign = 1;// N-W direction 90-180 degrees
    } else if ((x1 < x2) && (y1 < y2)) {
        asign = 1, dsign = 1;// S-E direction 270-360 degrees
    } else if ((x1 > x2) && (y1 < y2)) {
        asign = 1, dsign = -1; // S-W direction 180-270 degrees
    }
    return asign;
}
function lnadsign1(lndir, lndir1) {
    let asign = 1, dsign = 1;
    if (lndir == 'sn') {
        asign = 1, dsign = -1;
        if (lndir1 == 'we') { asign = 1, dsign = -1; }
        else if (lndir1 == 'ew') { asign = 1, dsign = 1; }
        else if (lndir1 == 'ne') { asign = 1, dsign = -1; }
        else if (lndir1 == 'nw') { asign = 1, dsign = 1; }
    } else if (lndir == 'ns') {
        asign = 1, dsign = 1;
        if (lndir1 == 'we') { asign = -1, dsign = -1; }
        else if (lndir1 == 'ew') { asign = -1, dsign = 1; }
        else if (lndir1 == 'sw') { asign = -1, dsign = 1; }
    } else if (lndir == 'ew') {
        asign = -1, dsign = -1;
        if (lndir1 == 'sn') { asign = -1, dsign = -1; }
        else if (lndir1 == 'ns') { asign = 1, dsign = -1; }
        else if (lndir1 == 'sw') { asign = 1, dsign = -1; }
    } else if (lndir == 'we') {
        asign = -1, dsign = 1;
        if (lndir1 == 'sn') { asign = -1, dsign = 1; }
        else if (lndir1 == 'ns') { asign = -1, dsign = -1; }
        else if (lndir1 == 'se') { asign = -1, dsign = -1; }
    } else if (lndir == 'ne') {
        asign = 1, dsign = -1;
        if (lndir1 == 'we') { asign = 1, dsign = -1; }
        else if (lndir1 == 'ne') { asign = 1, dsign = -1; }
        else if (lndir1 == 'sn') { asign = -1, dsign = 1; }
    } else if (lndir == 'nw') {
        asign = 1, dsign = 1;
        if (lndir1 == 'ew') { asign = 1, dsign = 1; }
        if (lndir1 == 'sn') { asign = 1, dsign = 1; }
    } else if (lndir == 'se') {
        asign = -1, dsign = -1;
        if (lndir1 == 'we') { asign = -1, dsign = -1; }
    } else if (lndir == 'sw') {
        asign = -1, dsign = 1;
        if (lndir1 == 'ew') { asign = -1, dsign = 1; }
    } else if (lndir == 'se') {
        asign = -1, dsign = -1;
        if (lndir1 == 'ns') { asign = -1, dsign = -1; }
    }
    //   console.log(lndir,lndir1,asign,dsign);
    return { asign: asign, dsign: dsign }
}
function calchyppoint3(d, angle, asign) {
    let dx = 0, dy = 0;
    // let d = Math.sqrt((a * a) / 2);
    dx = d * Math.cos(toRadians(angle));
    dy = asign * d * Math.sin(toRadians(angle));
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calchyppoint5(d, angle, asign, dsign) {
    let dx = 0, dy = 0;
    dx = dsign * d * Math.cos(toRadians(angle));
    dy = asign * d * Math.sin(toRadians(angle));
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calcsidelen(a) {
    return Math.sqrt((a * a) / 2);
}
function calchyplen(x1, y1, x2, y2) {
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    return d;
}
function calclinepoint(x1, y1, x2, y2, dt) {
    let dx = 0, dy = 0;
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    if (d != 0) {
        let t = dt / d;
        dx = Math.round(((1 - t) * x1) + (t * x2));
        dy = Math.round(((1 - t) * y1) + (t * y2));
    }
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calclinepoint1(x1, y1, x2, y2, dt) {
    let dx = 0, dy = 0;
    let d = calchyplen(x1, y1, x2, y2);
    if (d != 0) {
        dx = x1 - (dt * (x1 - x2) / d);
        dy = y1 - (dt * (y1 - y2) / d);
    }
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calcanglepoint1(x1, y1, x2, y2, ax, ay, angle) {
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    let dx = 0, dy = 0;
    dx = x2 - d * Math.cos(toRadians(angle));
    if (ay > y2) { dy = y2 + d * Math.sin(toRadians(angle)); } else { dy = y2 - d * Math.sin(toRadians(angle)); }
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calcanglepoint2(x1, y1, x2, y2, ax, ay, angle) {
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    let dx = 0, dy = 0;
    dx = x1 + d * Math.cos(toRadians(angle));
    if (ay > y1) { dy = y1 + d * Math.sin(toRadians(angle)); } else { dy = y1 - d * Math.sin(toRadians(angle)); }
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calcanglepoint3(x1, y1, x2, y2, angle, asign) {
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    let dx = 0, dy = 0;
    dx = d * Math.cos(toRadians(angle));
    dy = asign * d * Math.sin(toRadians(angle));
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calcanglepoint4(x1, y1, x2, y2, angle, asign) {
    let d = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    let dx = 0, dy = 0;
    dx = d * Math.cos(toRadians(angle));
    dy = asign * d * Math.sin(toRadians(angle));
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function calchyppoint4(x1, y1, dist, angle, asign) {
    let dx = 0, dy = 0;
    dx = x1 + d * Math.cos(toRadians(angle));
    dy = y1 + asign * d * Math.sin(toRadians(angle));
    return { dx: Math.round(dx), dy: Math.round(dy) };
}
function rotate_point(cx, cy, asign, angle, px, py) {
    let s = Math.sin(toRadians(angle));
    let c = Math.cos(toRadians(angle));
    // translate point back to origin:
    px -= cx; py -= cy;
    // rotate point
    let xnew;
    let ynew;

    if (asign > 0) {//clockwise rotation 
        xnew = px * c - py * s;
        ynew = px * s + py * c;
    }
    else {//counter clockwise roatation
        xnew = px * c + py * s;
        ynew = -px * s + py * c;
    }
    // translate point back:
    px = xnew + cx;
    py = ynew + cy;
    return {
        dx: Math.round(px),
        dy: Math.round(py)
    };
}
function rotate_point1(cx, cy, asign, angle, dist) {
    let angsin = Math.sin(toRadians(angle));
    let angcos = Math.cos(toRadians(angle));
    let px = (dist * angcos) + cx;
    let py = (asign * dist * angsin) + cy;
    return {
        dx: Math.round(px),
        dy: Math.round(py)
    };
}
function calclineangle(x1, y1, x2, y2, source) {

    var angrad = Math.atan2(y2 - y1, x2 - x1);
    var asign = angrad > 0 ? 1 : -1;
    var angle = Math.abs(((360 * angrad) / (Math.PI * 2)));
    if (asign == 1) { angle += 180; }
    if (angle == 360) { angle = 180; }
    // console.log(asign, angle);
    return roundToOne(angle);
}
function calclineangle1(x1, y1, x2, y2, source) {
    var angrad = Math.atan2(y2 - y1, x2 - x1);
    var asign = angrad > 0 ? 1 : -1;
    var angle = Math.abs(((360 * angrad) / (Math.PI * 2)));
    if (asign == 1) { angle += 180; }
    // if (angle == 360) { angle = 180;}
    // console.log(asign, angle);
    return roundToOne(angle);
}
function calclineangle2(x1, y1, x2, y2, source) {
    let angrad = Math.atan2(y2 - y1, x2 - x1);
    var asign = angrad > 0 ? 1 : -1;
    let angle = Math.abs(toAngle(angrad));
    var angledec = angle - Math.floor(angle);
    if (angledec > 0 && angledec <= 0.7) { angledec = 0.5 } else if (angledec > 0.7) { angledec = 1 } else { angledec = 0; }
    angle = Math.floor(angle) + angledec;
    if (asign == 1) { angle = 360 - angle; }
    return roundToOne(angle);
}
function calc2lineangle(x1, y1, x2, y2, x3, y3) {
    var a2 = Math.atan2(y3 - y1, x3 - x1);
    var a1 = Math.atan2(y2 - y1, x2 - x1);
    var sign = a1 > a2 ? 1 : -1;
    var angle = a1 - a2;
    var K = -sign * Math.PI * 2;
    var angle = (Math.abs(K + angle) < Math.abs(angle)) ? K + angle : angle;
    var atext = Math.abs(Math.round(360 * angle / (Math.PI * 2)));
    return atext;
}
function calc2vectorangle(x1, y1, x2, y2, x3, y3, x4, y4) {
    let a1 = Math.atan2(y2 - y1, x1 - x2); //atan2(vector.y, vector.x) = the angle between the vector and the X axis.
    let a2 = Math.atan2(y4 - y3, x3 - x4);
    let angrad = (a1 - a2);
    let vangle = Math.abs(toAngle(angrad));
    var vangledec = vangle - Math.floor(vangle);
    if (vangledec > 0 && vangledec < 0.7) { vangledec = 0.5 } else if (vangledec > 0.7) { vangledec = 1 } else { vangledec = 0; }
    vangle = Math.floor(vangle) + vangledec;
    return vangle;
}
function calc2vectorangle1(a1, a2) {
    var calangle = Math.abs(a1 - a2);
    if (calangle < 0) calangle += 90;
    var calangdec = calangle - Math.floor(calangle);
    if (calangdec > 0 && calangdec < 0.7) { calangdec = 0.5 } else if (calangdec > 0.7) { calangdec = 1 } else { calangdec = 0; }
    calangle = Math.floor(calangle) + calangdec;
    return calangle;
}
function calintersection1(x1, y1, x2, y2, x3, y3, x4, y4) {
    var A1 = y2 - y1;
    var B1 = x1 - x2;
    var C1 = (A1 * x1) + (B1 * y1);
    var A2 = y4 - y3;
    var B2 = x3 - x4;
    var C2 = (A2 * x3) + (B2 * y3);
    var det = (A1 * B2) - (A2 * B1);
    var dx = 0, dy = 0;
    if (det != 0) {
        dx = Math.round(((B2 * C1) - (B1 * C2)) / det);
        dy = Math.round(((A1 * C2) - (A2 * C1)) / det);
    }
    return {
        dx: dx,
        dy: dy
    };
}
function calcTranslationExact1(targetDistance, x1, y1, x2, y2) {
    let x1_x0 = x2 - x1, y1_y0 = y2 - y1, x2_x0, y2_y0;
    if (y1_y0 === 0) {
        x2_x0 = 0;
        y2_y0 = targetDistance;
    } else {
        let angle = Math.atan((x1_x0) / (y1_y0));
        x2_x0 = -targetDistance * Math.cos(angle);
        y2_y0 = targetDistance * Math.sin(angle);
    }
    return {
        dx: Math.round(x2_x0),
        dy: Math.round(y2_y0)
    };
}
function offsetline(x1, y1, x2, y2, dh) {
    let hyp = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    // This is the second line
    let x1p = x1 + dh * (y2 - y1) / hyp;
    let x2p = x2 + dh * (y2 - y1) / hyp;
    let y1p = y1 + dh * (x1 - x2) / hyp;
    let y2p = y2 + dh * (x1 - x2) / hyp;
    return {
        dx1: Math.round(x1p),
        dy1: Math.round(y1p),
        dx2: Math.round(x2p),
        dy2: Math.round(y2p)
    };
}
function calintersection(x1, y1, angle) {
    var tangle = Math.tan(angle);
    var x = (y1 * tangle) + x1;
    var y = ((1 / tangle) * x) + y1 + ((1 / tangle) * x1);
    //console.log(x, y);
}
function calcverticalvectorpoint(x1, y1, x2, y2, x3, y3) {
    let m1 = 0, m2 = 0, b1 = 0, b2 = 0, x4 = 0, y4 = 0;
    if (x1 == x2) {
        x4 = x2, y4 = y3;
    } else if (y1 == y2) {
        x4 = x3, y4 = y2;
    } else {
        m1 = (y1 - y2) / (x1 - x2); // slope of the line 
        m2 = -1 / m1; // slope of the perpendicular line
        b1 = y1 - m1 * x1; //y=mx+b => find y-intersect of original line
        b2 = y3 - m2 * x3; //y=mx+b => find y-intersect of vertical line
        x4 = (b2 - b1) / (m1 - m2); // find x coordinate of vertcal line touching original line
        y4 = m2 * x4 + b2; // find y coordinate of vertcal line touching original line
    }
    return { dx: Math.round(x4), dy: Math.round(y4) };
}
function roundToTwo(num) {
    return +(Math.round(num + "e+2") + "e-2");
}
function roundToOne(num) {
    return +(Math.round(num + "e+1") + "e-1");
}
function toRadians(angle) {
    return angle * (Math.PI / 180);
}
function toAngle(rad) {
    return rad * (180 / Math.PI)
}
function sidecenterpoint(lndir, x11, y11, x12, y12, x21, y21, x22, y22) {
    let mtx = 0, mty = 0, mtx1 = 0, mty1 = 0, mtx2 = 0, mty2 = 0;
    mtx1 = (x11 + x12) / 2; mty1 = (y11 + y12) / 2; mtx2 = (x21 + x22) / 2; mty2 = (y21 + y22) / 2;
    var lndir1 = lndirection(mtx1, mty1, mtx2, mty2);
    if (lndir == 'sn') {
        mtx = mtx1, mty = mty1 - (mty1 - mty2) / 2;
    } else if (lndir == 'ns') {
        mtx = mtx1, mty = mty1 - (mty1 - mty2) / 2;
    } else if (lndir == 'we') {
        mty = mty1, mtx = mtx1 + Math.abs((mtx2 - mtx1) / 2);
    } else if (lndir == 'ew') {
        mty = mty1, mtx = mtx1 + Math.abs((mtx2 - mtx1) / 2);
    } else {
        mtx = mtx1 + (mtx2 - mtx1) / 2; mty = mty1 - (mty1 - mty2) / 2;
    }
    return [mtx, mty];
}
function bboxcoords(obj) {
    var gnode = obj.node();
    var x = gnode.getBBox().x, y = gnode.getBBox().y, w = gnode.getBBox().width, h = gnode.getBBox().height;
    return { x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h) };
}
function calcontrolcenterpoint(obj) {
    let gnode = obj.node(), ctx = 0, cty = 0;
    if (gnode != null) {
        ctx = gnode.getBBox().x + gnode.getBBox().width / 2,
        cty = gnode.getBBox().y + gnode.getBBox().height / 2;
    }
    return { ctx: Math.round(ctx), cty: Math.round(cty) };
}
function calcontrolcenterpoint1(obj) {
    var gnode = obj.node();
    var ctx = gnode.getBBox().x + gnode.getBBox().width / 2; cty = gnode.getBBox().y + gnode.getBBox().height / 2;
    return [ctx, cty];
}
function ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x31, y31, x32, y32, cw) {
    var vs = [[x11, y11], [x12, y12], [x22, y22], [x21, y21]];
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    var dsign = -1;
    var minX = vs[0][0], maxX = vs[0][0];
    var minY = vs[0][1], maxY = vs[0][1];
    for (var n = 1; n < vs.length; n++) {
        var q = vs[n];
        minX = Math.min(q[0], minX);
        maxX = Math.max(q[0], maxX);
        minY = Math.min(q[1], minY);
        maxY = Math.max(q[1], maxY);
    }
    if (x < minX || x > maxX || y < minY || y > maxY) {
        dsign = 1;
    }
    //for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
    //    var xi = vs[i][0], yi = vs[i][1];
    //    var xj = vs[j][0], yj = vs[j][1];       
    //    var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    //    ////console.log("xi:" + xi, "yi:" + yi, "xj:" + xj, "yj:" + yj, "x:" + x, "y:" + y, intersect, dsign, yi > y, yj > y, (xj - xi) * (y - yi) / (yj - yi) + xi,
    //    //    (yi > y) != (yj > y), x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    //    if (intersect) { dsign = -1; break;}
    //}
    //drawpointcircle(lineindex, splashindex, sideindex, sidecode, x, y, 10, 'A');
    // console.log(x, y, minX, minY, maxX, maxY, dsign);
    //console.log(dsign, x, y, x11, y11, x12, y12, x21, y21, x22, y22, x31, y31, x32, y32);
    return dsign;
};
function ispointinpoly2(x11, y11, x12, y12, x21, y21, x22, y22, x31, y31, x32, y32, cw, lineindex, splashindex, sideindex, sidecode) {
    var dsign = 1;
    var r = { A: { x: x12, y: y12 }, B: { x: x12, y: y12 }, C: { x: x21, y: y21 }, D: { x: x22, y: y22 } };
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    let mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
    var m = { x: mx, y: my };
    var AB = vector2d(r.A, r.B);
    var AM = vector2d(r.A, m);
    var BC = vector2d(r.B, r.C);
    var BM = vector2d(r.B, m);
    var dotABAM = dot(AB, AM);
    var dotABAB = dot(AB, AB);
    var dotBCBM = dot(BC, BM);
    var dotBCBC = dot(BC, BC);
    if (0 <= dotABAM && dotABAM <= dotABAB && 0 <= dotBCBM && dotBCBM <= dotBCBC) { dsign = -1; }
    drawpointcircle(lineindex, splashindex, sideindex, sidecode, mx, my, 10, 'A');
    //console.log(x11, y11, x12, y12, x21, y21, x22, y22, mx, my);
    //console.log(dotABAM, dotABAB, dotBCBM, dotBCBC, dsign, 0 <= dotABAM, dotABAM <= dotABAB, 0 <= dotBCBM, dotBCBM <= dotBCBC, 0 <= dotABAM && dotABAM <= dotABAB && 0 <= dotBCBM && dotBCBM <= dotBCBC);
    return dsign;
}
function islineinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, h) {
    let dsign = 1;
    let npt1 = calcTranslationExact1(h / 3, x11, y11, x12, y12);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    let x1 = x11 + dx1, y1 = y11 + dy1, x2 = x12 + dx1, y2 = y12 + dy1;
    // drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    let npt2 = calcverticalvectorpoint(x21, y21, x22, y22, x, y);
    let x3 = npt2.dx, y3 = npt2.dy, x4 = x, y4 = y;
    let d = calchyplen(x3, y3, x4, y4);
    if (d < h) { dsign = -1; }
    // console.log(d, h, dsign, x11, y11, x12, y12, x21, y21, x22, y22, h);
    return dsign;
}
function islineinpoly2(x11, y11, x12, y12, x21, y21, x22, y22, h) {
    let dsign = 1;
    let npt1 = calcTranslationExact1(h / 3, x21, y21, x22, y22);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    let x1 = x21 + dx1, y1 = y21 + dy1, x2 = x22 + dx1, y2 = y22 + dy1;
    // drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    let npt2 = calcverticalvectorpoint(x11, y11, x12, y12, x, y);
    let x3 = npt2.dx, y3 = npt2.dy, x4 = x, y4 = y;
    let d = calchyplen(x3, y3, x4, y4);
    // drawsplashline(6, 1, 1, 1, x3, y3, x4, y4, 'A');  
    //console.log(d, h, dsign, x11, y11, x12, y12, x21, y21, x22, y22, h);
    if (d < h) { dsign = -1; }
    return dsign;
}
function islineinpoly3(x11, y11, x12, y12, x21, y21, x22, y22, h) {
    let dsign = 1;
    let npt1 = calcTranslationExact1(h / 3, x11, y11, x21, y21);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    let x1 = x11 + dx1, y1 = y11 + dy1, x2 = x21 + dx1, y2 = y21 + dy1;
    // drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;

    let npt2 = calcverticalvectorpoint(x11, y11, x12, y12, x22, y22);
    let x3 = npt2.dx, y3 = npt2.dy, x4 = x22, y4 = y22;
    // drawsplashline(6, 1, 1, 1, x3, y3, x4, y4, 'A');

    let npt3 = calcverticalvectorpoint(x3, y3, x4, y4, x, y);
    let x5 = npt3.dx, y5 = npt3.dy, x6 = x, y6 = y;
    // drawsplashline(7, 1, 1, 1, x5, y5, x6, y6, 'A');

    let d = calchyplen(x5, y5, x6, y6);
    if (d < h) { dsign = -1; }
    // console.log(d, h, dsign);
    return dsign;
}
function islineinpoly4(x11, y11, x12, y12, x21, y21, x22, y22, h) {
    let dsign = 1;
    let npt1 = calcTranslationExact1(h / 3, x12, y12, x22, y22);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    let x1 = x12 + dx1, y1 = y12 + dy1, x2 = x22 + dx1, y2 = y22 + dy1;
    // drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;

    let npt2 = calcverticalvectorpoint(x11, y11, x12, y12, x21, y21);
    let x3 = npt2.dx, y3 = npt2.dy, x4 = x21, y4 = y21;
    // drawsplashline(6, 1, 1, 1, x3, y3, x4, y4, 'A');

    let npt3 = calcverticalvectorpoint(x3, y3, x4, y4, x, y);
    let x5 = npt3.dx, y5 = npt3.dy, x6 = x, y6 = y;
    // drawsplashline(7, 1, 1, 1, x5, y5, x6, y6, 'A');

    let d = calchyplen(x5, y5, x6, y6);
    if (d < h) { dsign = -1; }
    // console.log(d, h, dsign);
    return dsign;
}
function islineinpoly5(x31, y31, x32, y32, x11, y11, x12, y12, cw, w1) {
    let dsign = 1, d = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = x12, y3 = y12;
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    if (Math.abs(x11 - x12) > Math.abs(y11 - y12)) { y3 = y; } else { x3 = x; }
    d = calchyplen(x3, y3, x, y);
    drawsplashline(6, 1, 1, 1, x3, y3, x, y, 'A');
    if (d < w1) { dsign = -1; }
    console.log(d, w1, dsign, x11, y11, x12, y12, x, y);
    return dsign;
}
function islineinpoly6(x31, y31, x32, y32, x11, y11, x12, y12, cw, w2) {
    let dsign = 1, d = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = x12, y3 = y12;
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    // drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    if (Math.abs(x11 - x12) > Math.abs(y11 - y12)) { y3 = y; } else { x3 = x; }
    d = calchyplen(x3, y3, x, y);
    drawsplashline(6, 1, 1, 1, x3, y3, x, y, 'A');
    if (d > w2) { dsign = -1; }
    console.log(d, w2, dsign, x11, y11, x12, y12, x, y);
    return dsign;
}
function islineinpoly7(x31, y31, x32, y32, x21, y21, x22, y22, cw, w1) {
    let dsign = 1, d = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = x22, y3 = y22;
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    if (Math.abs(x21 - x22) > Math.abs(y21 - y22)) { y3 = y; } else { x3 = x; }
    d = calchyplen(x3, y3, x, y);
    drawsplashline(6, 1, 1, 1, x3, y3, x, y, 'A');
    if (d < w1) { dsign = -1; }
    console.log(d, w1, dsign, x21, y21, x22, y22, x, y);
    return dsign;
}
function islineinpoly8(x31, y31, x32, y32, x21, y21, x22, y22, cw, w2) {
    let dsign = 1, d = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = x22, y3 = y22;
    let npt1 = calcTranslationExact1(cw, x31, y31, x32, y32);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x1 = x31 + dx1, y1 = y31 + dy1, x2 = x32 + dx1, y2 = y32 + dy1;
    drawsplashline(5, 1, 1, 1, x1, y1, x2, y2, 'A');
    let x = (x1 + x2) / 2, y = (y1 + y2) / 2;
    if (Math.abs(x21 - x22) > Math.abs(y21 - y22)) { y3 = y; } else { x3 = x; }
    d = calchyplen(x3, y3, x, y);
    drawsplashline(6, 1, 1, 1, x3, y3, x, y, 'A');
    if (d > w2) { dsign = -1; }
    console.log(d, w2, dsign, x21, y21, x22, y22, x, y);
    return dsign;
}
function ispointinline(x1, y1, x2, y2, x3, y3) {
    var distXZ = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3),
        distXY = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2),
        distYZ = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);

    // if triangle is right or acute, or obtuse with hypotenuse XY, returns true
    return (distXZ + distXY >= distYZ) && (distYZ + distXY >= distXZ);
}
function insidePoly(x11, y11, x12, y12, x21, y21, x22, y22, pointx, pointy) {
    var i, j;
    var inside = false;
    var poly = [{ x: x11, y: y11 }, { x: x12, y: y12 }, { x: x22, y: y22 }, { x: x21, y: y21 }];
    for (i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        if (((poly[i].y > pointy) != (poly[j].y > pointy)) && (pointx < (poly[j].x - poly[i].x) * (pointy - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)) inside = !inside;
    }
    return inside;
}
function pointIsInPoly(x11, y11, x12, y12, x21, y21, x22, y22, pointx, pointy) {
    var isInside = false;
    var polygon = [{ x: x11, y: y11 }, { x: x12, y: y12 }, { x: x22, y: y22 }, { x: x21, y: y21 }];
    var p = { x: pointx, y: pointy };
    var minX = polygon[0].x, maxX = polygon[0].x;
    var minY = polygon[0].y, maxY = polygon[0].y;
    for (var n = 1; n < polygon.length; n++) {
        var q = polygon[n];
        minX = Math.min(q.x, minX);
        maxX = Math.max(q.x, maxX);
        minY = Math.min(q.y, minY);
        maxY = Math.max(q.y, maxY);
    }

    if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) {
        return false;
    }

    var i = 0, j = polygon.length - 1;
    for (i, j; i < polygon.length; j = i++) {
        if ((polygon[i].y > p.y) != (polygon[j].y > p.y) &&
                p.x < (polygon[j].x - polygon[i].x) * (p.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x) {
            isInside = !isInside;
        }
    }

    return isInside;
}
function inLine(A, B, C) {
    // if AC is vertical
    if (A.x == C.x) return B.x == C.x;
    // if AC is horizontal
    if (A.y == C.y) return B.y == C.y;
    // match the gradients
    return (A.x - C.x) * (A.y - C.y) == (C.x - B.x) * (C.y - B.y);
}
function ispointintriangle(pt, v1, v2, v3) {
    var b1, b2, b3;
    b1 = sign(pt, v1, v2) < 0
    b2 = sign(pt, v2, v3) < 0
    b3 = sign(pt, v3, v1) < 0
    return ((b1 == b2) && (b2 == b3));
}
function vector2d(p1, p2) {
    return { x: (p2.x - p1.x), y: (p2.y - p1.y) };
}
function vect2d(p1, p2) {
    var temp = { x: 0, y: 0 };
    temp.x = (p2.x - p1.x);
    temp.y = -1 * (p2.y - p1.y);
    return temp;
}
function dot(u, v) {
    return u.x * v.x + u.y * v.y;
}
function cross(u, v) {
    return u.x * v.y - u.y * v.x;
}
function fractionToDecimal(f) {
    return f != undefined ? f.split('/').reduce((n, d, i) => n / (i ? d : 1)) : 0;
}
function rounddecimal(decival) {
    return Math.round(decival * 10000) / 10000;
}
function decimaltofraction(decival) {
    let decinchfact = 0.015625;  // 1/64 inch = 0.015625;
    let feet = Math.floor(decival);
    let frdecval = decival - feet;
    let retVal = feet + " " + simplifyfactor(Math.round(frdecval / decinchfact), 64);
    return retVal.toString().trim();
}
function simplifyfactor(numerator, denominator) {
    var gcd = function gcd(a, b) {
        return b ? gcd(b, a % b) : a;
    };
    gcd = gcd(numerator, denominator);
    return numerator == 0 ? "" : (numerator / gcd) + "/" + (denominator / gcd);
}
function float2rat(x) {
    var tolerance = 1.0E-6;
    var h1 = 1; var h2 = 0;
    var k1 = 0; var k2 = 1;
    var b = x;
    do {
        var a = Math.floor(b);
        var aux = h1; h1 = a * h1 + h2; h2 = aux;
        aux = k1; k1 = a * k1 + k2; k2 = aux;
        b = 1 / (b - a);
    } while (Math.abs(x - h1 / k1) > x * tolerance);

    return h1 + "/" + k1;
}
function calcCirclePath(a, b, c) {
    var A = dist(b, c);
    var B = dist(c, a);
    var C = dist(a, b);
    var angle = Math.acos((A * A + B * B - C * C) / (2 * A * B));
    //calc radius of circle
    var K = .5 * A * B * Math.sin(angle);
    var r = A * B * C / 4 / K;
    r = Math.round(r * 1000) / 1000;
    //large arc flag
    var laf = +(Math.PI / 2 > angle);
    //sweep flag
    var saf = +((b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) < 0);
    var path = ['M', a, 'A', r, r, 0, laf, saf, b].join(' ');
    return path;
}
function dist(a, b) {
    return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2))
}
function rounded_rect(x, y, w, h, r, tl, tr, bl, br) {
    var retval;
    retval = "M" + (x + r) + "," + y;
    retval += "h" + (w - 2 * r);
    if (tr) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + r; }
    else { retval += "h" + r; retval += "v" + r; }
    retval += "v" + (h - 2 * r);
    if (br) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + r; }
    else { retval += "v" + r; retval += "h" + -r; }
    retval += "h" + (2 * r - w);
    if (bl) { retval += "a" + r + "," + r + " 0 0 1 " + -r + "," + -r; }
    else { retval += "h" + -r; retval += "v" + -r; }
    retval += "v" + (2 * r - h);
    if (tl) { retval += "a" + r + "," + r + " 0 0 1 " + r + "," + -r; }
    else { retval += "v" + -r; retval += "h" + r; }
    retval += "z";
    return retval;
}
function quadraticcurvepath(x1, y1, x2, y2, x3, y3) {
    var path = "M " + x1 + " " + y1 + " Q " + x2 + " " + y2 + " " + x3 + " " + y3;
    return path;
}
function quadraticcurvepath1(x1, y1, x2, y2, r, xrflag, laflag, swflag) {
    var path = "M" + x1 + " " + y1 + " A" + r + " " + r + "," + xrflag + "," + laflag + "," + swflag + ", " + x2 + " " + y2;
    // console.log(path);
    return path;
    //A rx ry x-axis-rotation large-arc-flag sweep-flag x y
    //a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy
    //M80 80 A 45 45, 0, 0, 0, 125 125
}
function d3arcpath(startang, endang) {
    console.log(startang, endang, Math.PI / 2);
    let darc = d3.arc()
    .innerRadius(20)
    .outerRadius(50)
    .startAngle(3 * Math.PI / 2) //converting from degs to radians
    .endAngle(Math.PI / 2) //just radians
    return darc;
}
function getRandomColor2() {
    var color = 'rgb(' +
    (Math.floor(Math.random() * 56) + 200) + ', ' +
    (Math.floor(Math.random() * 56) + 200) + ', ' +
    (Math.floor(Math.random() * 56) + 200) +
    ')';
    console.log(color)
}
function getRandomColor1() {
    color = "hsl(" + Math.random() * 360 + ", 100%, 75%)";
    return color;
}
function getRandomColor() {
    var letters = 'BCDEF'.split('');
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * letters.length)];
    }
    return color;
}
function getRandomColor3() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '#';
    for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
function getcolorcode(index) {
    var colorCodes = [
      "SkyBlue", "yellowgreen", "sandybrown", "coral", "burlywood", "#E1BEE7", "#FCE4EC", "#CCCC99", "#E0F2F1",
      "#FFFDE7", "#FFF3E0", "#EFEBE9", "#FFCDD2", "#CCCC00", "#D1C4E9", "#BBDEFB", "#99FFFF", "#B2DFDB", "#F0F4C3",
      "#FFE0B2", "#FFCCBC", "#CFD8DC", "#EF9A9A", "#F48FB1", "#CE93D8", "#9FA8DA", "#90CAF9", "#80CBC4", "#E6EE9C",
      "#FFCC80", "#FFAB91", "#F9EBEA", "#99FF99", "#D7BDE2", "#EAF2F8", "#A3E4D7", "#FADBD8", "#A5D6A7", "#FFF59D",
      "#76D7C4", "#FDEDEC", "#F6DDCC", "#F0B27A", "#85C1E9", "#F4D03F", "#F5B041", "#EB984E", "#F2D7D5", "#FFE082",
      "#D5DBDB", "#80DEEA", "#AED581", "#FF8A65", "#FFB74D", "#FFF176", "#D5F5E3", "#F39C12", "#8BC34A", "#FAD7A0",
      "#E6B0AA", "#E67E22", "#EC7063", "#CDDC39", "#FBEEE6", "#E8F8F5", "#FEF9E7", "#E8DAEF", "#FFCCFF", "#D7CCC8",
      "#F5EEF8", "#82E0AA", "#E3F2FD", "#00FFFF", "#F8BBD0", "#CC9999", "#66CC66", "#CC9900", "#B2EBF2", "#66FF99",
      "#D6EAF8", "#F8C471", "#EAFAF1", "#73C6B6", "#EBDEF0", "#DCE775", "#7FB3D5", "#D4EFDF", "#99CCCC", "#BDBDBD",
      "#875faf", "#87875f", "#878787", "#8787af", "#8787d7", "#8787ff", "#87af00", "#87af5f", "#87af87", "#875fd7",
      "#87afd7", "#87afff", "#87d700", "#87d75f", "#87d787", "#87d7af", "#87d7d7", "#87d7ff", "#87ff00", "#87ff5f",
      "#87ff87", "#87ffaf", "#87ffd7", "#87ffff", "#af0000", "#af005f", "#af0087", "#af00af", "#af00d7", "#af00ff",
      "#af5f00", "#af5f5f", "#af5f87", "#af5faf", "#af5fd7", "#af5fff", "#af8700", "#af875f", "#af8787", "#af87af",
      "#af87d7", "#af87ff", "#afaf00", "#afaf5f", "#afaf87", "#afafaf", "#afafd7", "#afafff", "#afd700", "#afd75f",
      "#afd787", "#afd7af", "#afd7d7", "#afd7ff", "#afff00", "#afff5f", "#afff87", "#afffaf", "#afffd7", "#afffff",
      "#d70000", "#d7005f", "#d70087", "#d700af", "#d700d7", "#d700ff", "#d75f00", "#d75f5f", "#d75f87", "#d75faf",
      "#d75fd7", "#d75fff", "#d78700", "#d7875f", "#d78787", "#d787af", "#d787d7", "#d787ff", "#dfaf00", "#dfaf5f",
      "#dfaf87", "#dfafaf", "#dfafdf", "#dfafff", "#dfdf00", "#dfdf5f", "#dfdf87", "#dfdfaf", "#dfdfdf", "#dfdfff",
      "#dfff00", "#dfff5f", "#dfff87", "#dfffaf", "#dfffdf", "#dfffff", "#ff0000", "#ff005f", "#ff0087", "#ff00af",
      "#ff00df", "#ff00ff", "#ff5f00", "#ff5f5f", "#ff5f87", "#ff5faf", "#ff5fdf", "#ff5fff", "#ff8700", "#ff875f",
      "#ff8787", "#ff87af", "#ff87df", "#ff87ff", "#ffaf00", "#ffaf5f", "#ffaf87", "#ffafaf", "#ffafdf", "#ffafff",
      "#ffdf00", "#ffdf5f", "#ffdf87", "#ffdfaf", "#ffdfdf", "#ffdfff", "#ffff00", "#ffff5f", "#ffff87", "#ffffaf",
      "#ffffdf", "#ffffff", "#080808", "#121212", "#1c1c1c", "#262626", "#303030", "#3a3a3a", "#444444", "#4e4e4e",
      "#585858", "#626262", "#6c6c6c", "#767676", "#808080", "#8a8a8a", "#949494", "#9e9e9e", "#a8a8a8", "#b2b2b2",
      "#bcbcbc", "#c6c6c6", "#d0d0d0", "#dadada", "#e4e4e4", "#eeeeee", "#00005f", "#000087", "#0000af", "#0000d7",
      "#0000ff", "#005f00", "#0000ff", "#ffffff", "#000000",
    ]
    return colorCodes[index];
}
function calcenterpoint(x11, y11, x12, y12, x21, y21, x22, y22, w1, w2) {
    let cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, cx3 = 0, cy3 = 0, npt = {};
    if (w1 >= w2) {
        cx1 = x21, cy1 = y21, cx2 = (x21 + x22) / 2; cy2 = (y21 + y22) / 2;
        npt = calcverticalvectorpoint(x11, y11, x12, y12, cx2, cy2);
        cx3 = (cx2 + npt.dx) / 2, cy3 = (cy2 + npt.dy) / 2;
    } else {
        cx1 = x11, cy1 = y11, cx2 = (x11 + x12) / 2; cy2 = (y11 + y12) / 2;
        npt = calcverticalvectorpoint(x21, y21, x22, y22, cx2, cy2);
        cx3 = (cx2 + npt.dx) / 2, cy3 = (cy2 + npt.dy) / 2;
    }
    return { dx: Math.round(cx3), dy: Math.round(cy3) };
}
