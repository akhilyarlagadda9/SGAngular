function initshape(index, x, y) {    
    let color = getRandomColor();   
    shape = {
        index: index, id: index, areaindex: 0, areaid: 0, partsrno: 0, partid: 0, partname: '', materialid: 0, isactive: 1,
        spactive: 0, mode: 'shape', spindex: -1, slabid: 0, slabindex: 0, unitcount: 1, dupcount: 0, tscale: zscale, layout: 1,
        x: x, y: y, tx: 0, ty: 0, h: sdh, angle: 0, color: color, opoints: [], sides: [], seams: [], slabparts: [], slabsplashs: [], labels: []
    };
    shape.opoints.push([x, y]);
}
function initpartshape31(mx, my) {
    let areaindex = getareaindex();
    let area = getareabyindex(areaindex);
    let partsrno = getlastactivepartsrno() + 1;
    let index = area.PartList.length;
    initshape(index, mx, my);    
    shape.areaid = area.ID;
    shape.areaindex = areaindex + 1;
    shape.unitcount = area.NoOfUnits;
    shape.partsrno = partsrno;    
    setshapegroups31(index, 'shape', 'initpartshape31');
}
function setdrawshape31(index, partsrno, areaid, smode, source) {  
    if (bdraw) { onendshapedraw(); }
    if (shape.index != index) { removeshapecorners(0, 'setdrawmode'); }
    //console.log(index, partsrno, areaid, smode, source);
    shape = getpartshapebyareapartsrno(partsrno, areaid);
    shape.index = index;
    shape.partsrno = partsrno;
   // shape = getshapebypartindex(index);
    ActionSelectPart(partsrno);
    setshapegroups31(index, smode, source);
}
function setduplicateshape31(dupcount) {
    let areaindex = getareaindex();
    let partlen = getpartlength(areaindex);
    for (let i = 0; i < dupcount; i++) {
        duplicateshape31(partlen + i);
        ActionDuplicateShape('setduplicateshape31');
    }   
}
function duplicateshape31(index) {
    shape = JSON.parse(JSON.stringify(shape));
    shape.index = index;    
    shape.color = getRandomColor();
    shape.materialid = getpartmaterialidbyareapartid(shape.partid, shape.partsrno, shape.areaid);
    shape.partsrno = (index + 1);
    shape.partid = 0;
    shape.tx += 10, shape.ty += 10;
    for (let j = 0; j < shape.sides.length; j++) {resetduplicateshapesideitems(shape.sides[j], shape.index);}
    drawshape32(index, 'shape', 'duplicateshape31');
    drawlogservice.add(shape, 'duplicateshape', 1);
}
function drawshape31(index, partsrno, areaid, mode, source) {    
    setdrawshape31(index, partsrno, areaid, mode, source);  
    if (shape != undefined) {
        shapesides(source + ':drawshape31');
        transformshape();
        if (shape.angle != 0) { rotateshape(0, index, shape.angle); }
    }
}
function drawshape32(index, smode, source) {
    setshapegroups31(index, smode, source);
    shapesides(source + ':drawshape32');
    transformshape();
    if (shape.angle != 0) { rotateshape(0, index, shape.angle); }
}
function setshapegroups31(index, smode, source) {    
    if (shape != undefined) {
        shape.mode = smode;
        let partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
        let areashapeindex = areaid + "" + index;
        if (smode == 'print') {
            shapeouterg = prshapesg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = prshapesg.append("g").attr("id", smode + "outer" + areashapeindex); }
            //if (layoutmode == 2) {
                let shapeslabimgsg = shapeouterg.select("#" + "shapeslabimgsg" + areashapeindex);
                if (shapeslabimgsg.empty()) { shapeslabimgsg = shapeouterg.append("g").attr("id", "shapeslabimgsg" + areashapeindex); }
            //}
        } else if (smode == 'shape') {
            shapeouterg = shapesg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = shapesg.append("g").attr("id", smode + "outer" + areashapeindex); }
            shapeouterg.call(shapedrag);
        } else if (smode == 'slabpart') {
            shapeouterg = mslabpartsg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = mslabpartsg.append("g").attr("id", smode + "outer" + areashapeindex); }
            shapeouterg.call(shapedrag);
        }
        else if (smode == 'slabpartdg') {           
            shapeouterg = mdgslabpartsg.select("#" + smode + "outer" + areashapeindex);
            if (shapeouterg.empty()) { shapeouterg = mdgslabpartsg.append("g").attr("id", smode + "outer" + areashapeindex); }
            //let slabpartslabimgsg = shapeouterg.select("#" + "slabpartslabimgsg" + areashapeindex);
            //if (slabpartslabimgsg.empty()) { slabpartslabimgsg = shapeouterg.append("g").attr("id", "slabpartslabimgsg" + areashapeindex); }
        }
        shapeouterg.attr("id", smode + "outer" + areashapeindex).attr("index", index).attr("sindex", index).attr("spindex", spindex).attr("partsrno", partsrno)
        .attr("areaid", areaid).attr("smode", smode).attr("sideslength", shape.sides.length);
        setshapeinnergroups31(index, smode, source);
    }
}
function setshapeinnergroups31(index, smode, source) {
    shapeg = shapeouterg.select("#" + smode + index);
    if (shapeg.empty()) { shapeg = shapeouterg.append("g").attr("id", smode + index); }
    shapepathg = shapeg.select("#" + smode + "pathg" + index); if (shapepathg.empty()) { shapepathg = shapeg.append("g").attr("id", smode + "pathg" + index); }
    sidesg = shapeg.select("#" + smode + "sidesg" + index); if (sidesg.empty()) { sidesg = shapeg.append("g").attr("id", smode + "sidesg" + index); }
    cornersg = shapeg.select("#" + smode + "cornersg" + index); if (cornersg.empty()) { cornersg = shapeg.append("g").attr("id", smode + "cornersg" + index); }
    sideshapesg = shapeg.select("#" + smode + "sideshapesg" + index); if (sideshapesg.empty()) { sideshapesg = shapeg.append("g").attr("id", smode + "sideshapesg" + index); }
    splashsg = shapeg.select("#" + smode + "splashsg" + index); if (splashsg.empty()) { splashsg = shapeg.append("g").attr("id", smode + "splashsg" + index); }
    cutoutsg = shapeg.select("#" + smode + "cutoutsg" + index); if (cutoutsg.empty()) { cutoutsg = shapeg.append("g").attr("id", smode + "cutoutsg" + index); }
    seamsg = shapeg.select("#" + smode + "seamsg" + index); if (seamsg.empty()) { seamsg = shapeg.append("g").attr("id", smode + "seamsg" + index); }
    anglehandlesg = shapeg.select("#" + smode + "anglehandlesg" + index); if (anglehandlesg.empty()) { anglehandlesg = shapeg.append("g").attr("id", smode + "anglehandlesg" + index); }    
}
function setdrawmode(dmode) {   
    if (bdraw) { onendshapedraw('setdrawmode'); }
    drawmode = dmode; 
    if (drawmode != 2) { removeshapecorners(0, 'setdrawmode'); }
}
function drawcountershape(type) {
    shapetype = type;
    setdrawmode(1);
}
function setcornertype(type, itemid) {
    cornertype = parseInt(type);
    cornertypeid = parseInt(itemid);
    setdrawmode(2);
    if (shape.mode == 'shape') {
        onsetcornertype(shape.index);
    }
}
function setsideshapetype(typeid, itemid) {
    sideshapetype = parseInt(itemid);
    sideshapetypeid = parseInt(typeid);
    setdrawmode(3);
}
function splashapronheightclick(dh) {
    splheight = parseFloat($('#txtsplashapronheight').val());    
    splheight += dh;   
    if (splheight <= splashminh) { splheight = splashminh; }
    $('#txtsplashapronheight').val(splheight);
    setsplashtype(0, splheight);
}
function setsplashtype(typeid, height) {
    edgetype = "U"; edgetypeid = typeid; splheight = height == 0 ? splashminh : height;
    setdrawmode(4);
}
function setedgetype(type, typeid, unittypeid) {    
    edgetype = type;
    edgetypeid = parseInt(typeid);    
    setdrawmode(5);
}
function setcutouttype(type, itemid) {
    cutouttype = type;
    cutoutinfo = getpricebookcutoutbyid(itemid);
    setdrawmode(6);
}
function setsinkcutouttype(type, itemid) {
    let sink = getpricebooksinkcutoutbyid(itemid);
    if (sink != '' && sink.CutoutInfo != '') {
        cutoutinfo = sink.CutoutInfo; cutoutinfo.SinkID = sink.ID; cutoutinfo.NoOfBowls = sink.NoOfBowls;
        cutouttype = cutoutinfo.Type;
        if (sink.BasinModeType != null && cutouttype != 'co' && cutouttype != 'cor') { cutouttype = sink.BasinModeType; }
        setdrawmode(6);
    }
}
function setseamtype(type) {
    seamtype = type;
    removeanglehandles();
    setdrawmode(7);
}
function setaprontype(dh, typeid, sidemode) {
    splheight = dh == 0 ? splashminh : dh;
    edgetype = "U"; edgetypeid = parseInt(typeid); countersidemode = sidemode;
    setdrawmode(8);
}
function setshapetext() {
    setdrawmode(9);
}
function setlayoutmode() {    
    let mode = layoutmode == 1 ? 2 : 1;
    onsetlayoutmode(mode);
}
function ondrawshape(mx, my) {
    let stx = mx * (1 - zscale), sty = my * (1 - zscale);
    initpartshape31(mx, my);
    shape.tx = stx / zscale, shape.ty = sty / zscale;
    transformshape();
    if (shapetype == 0) {       
        drawshapedrawhandle(mx, my);
    } else {        
        drawpredefinedshapes(mx, my);
    }    
    shapetype = 0;
}
function drawpredefinedshapes(mx, my) {    
    if (shapetype == 1) { drawrectshape(mx, my); }
    else if (shapetype == 2) { drawrlshape(mx, my); }
    else if (shapetype == 3) { drawllshape(mx, my); }
    else if (shapetype == 4) { drawushape(mx, my); }
    else if (shapetype == 5) { drawcircleshape(mx, my); }    
    setsideedge(shape.sides.length - 1, 3, 'F', 0);    
    shapesides('drawpredefinedshapes');
    ActionShape('onendshapedraw');
    drawlogservice.add(shape, 'ondrawshape', 1);
}
function drawrectshape(x1, y1) {
    let angle = 0, w = (sdh * 5);   
    let npt = rotate_point1(x1, y1, -1, angle, w);
    let x2 = npt.dx, y2 = npt.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);  
}
function drawrlshape(x1, y1) {
    let angle1 = 90, angle2 = 0, w1 = (sdh * 2.5), w2 = (sdh * 2.5);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);   
}
function drawllshape(x1, y1) {
    let angle1 = 0, angle2 = 270, w1 = (sdh * 2.5), w2 = (sdh * 2.5);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);  
}
function drawushape(x1, y1) {
    let angle1 = 90, angle2 = 0, angle3 = 270, w1 = (sdh * 2.5), w2 = (sdh * 4), w3 = (sdh * 2.5);
    let npt1 = rotate_point1(x1, y1, -1, angle1, w1);
    let x2 = npt1.dx, y2 = npt1.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);
    let npt2 = rotate_point1(x2, y2, -1, angle2, w2);
    let x3 = npt2.dx, y3 = npt2.dy;
    setnewshapeside(x3, y3);
    shape.opoints.push([x3, y3]);
    let npt3 = rotate_point1(x3, y3, -1, angle3, w3);
    let x4 = npt3.dx, y4 = npt3.dy;
    setnewshapeside(x4, y4);
    shape.opoints.push([x4, y4]);   
}
function drawcircleshape(x1, y1) {
    let angle = 0, w = (sdh * 3);
    shape.h = w;
    let r = w / 2;
    let npt = rotate_point1(x1, y1, -1, angle, w);
    let x2 = npt.dx, y2 = npt.dy;
    setnewshapeside(x2, y2);
    shape.opoints.push([x2, y2]);   
    resetsidecorners32(r, r, r, 2, 10, 'drawcircleshape');
}
function svgclick() {
    removeshapecorners(0, 'svgclick');
    if (editmode == 1) { reseteditmode('svg click'); }
    if (bdraw) { onendshapedraw('svgclick'); removedrawhandles(); }
    if (d3.event.srcElement.tagName == 'svg' || d3.event.srcElement.id == 'shapesrect') {
        removehandles();
        if (drawmode == 1) {
            let m = d3.mouse(this);
            let mx = Math.round(m[0]), my = Math.round(m[1]);
           // console.log(mx, my, d3.event.x, d3.event.y);
            ondrawshape(mx, my);
            drawmode = 0;
        } else { setdrawmode(0); }

    }
    //  ActionDrawSideHide();
}
function svgblur() {
    setdrawmode(0);
}
function svgcontextmenu() {
    // d3.event.preventDefault();
}
function drawshapedrawhandle(x, y) {
    let x1 = 0, y1 = 0, x2 = 0, y2 = 0, h = shape.h;
    x1 = x - h / 2, x2 = x + h / 2, y1 = y2 = y;
    let sclass = 'shapesideblue';
    drawhandlesg = shapeouterg.select("#drawhandlesg");
    if (drawhandlesg.empty()) {drawhandlesg = shapeouterg.append("g").attr("id", "drawhandlesg").call(shapedraw);}
    let shapeline = drawhandlesg.select("#" + shape.mode +  "drawhandle1");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "drawhandle1"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);
    x1 = x2 = x, y1 = y - h / 2, y2 = y + h / 2;
    shapeline = drawhandlesg.select("#" + shape.mode + "drawhandle2");
    if (shapeline.empty()) { shapeline = drawhandlesg.append("line").attr("id", shape.mode + "drawhandle2"); }
    shapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sclass);   
}
function onendshapedraw(source) {
    setsideedge(shape.sides.length - 1, 3, 'F', 0);
    bdraw = false;
    drawshapeendside();   
    ActionShape('onendshapedraw');
    drawlogservice.add(shape, 'ondrawshape', 1);
}
function shapedrawstarted() {
    bdraw = true;
    let index = shape.opoints.length - 1;
    let x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];    
    drawshapedrawhandle(x1, y1);   
    reseteditmode('shapedrawstarted');
}
function shapedrawed() {
    let index = shape.opoints.length - 1;
    let x1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if (Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh) {
        setnewshapeside(x2, y2);
        shapesides('shapedrawed');
    }
    drawshapedrawhandle(x2, y2);
}
function shapedrawended() {
    let index = shape.opoints.length - 1;
    let x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, dh = shape.h / 2;
    if (index > 0) { x0 = shape.opoints[index - 1][0], y0 = shape.opoints[index - 1][1]; }
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    x2 = Math.round(d3.event.x), y2 = Math.round(d3.event.y);
    if (Math.abs(x2 - x1) < dh) { x2 = x1; } else { y2 = y1; }
    if ((Math.abs(x2 - x1) > dh || Math.abs(y2 - y1) > dh)) {
        if (index == 0) { shape.opoints.push([x2, y2]); } else {
            if (((x0 === x2) && (x1 === x2)) || ((y0 === y2) && (y1 === y2))) {
                shape.opoints[index][0] = x2;
                shape.opoints[index][1] = y2;
            } else {
                shape.opoints.push([x2, y2]);
            }
        }
    }
}
function onshape() {   
    d3.event.stopPropagation();
    let index = parseInt(this.getAttribute("index"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    let m = d3.mouse(this);
    if (mode == 'slabpart') {        
        if (drawmode == 7) {
            onsetslabpartshape31(sindex, spindex, partsrno, areaid, 'onshape');
            if (seamtype != 2) { onsetsideseam31(m[0], m[1], -1, index, sindex, seamtype, 'onshape'); } setdrawmode(0);
        }
    } if (mode == 'shape') {
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshape');
        if (drawmode == 2) {drawshapecorners(sindex, 'onshape');
        } else if (drawmode == 6) {
            onsetshapesidecutout(m[0], m[1], -1, index, sindex, 'onshape');
        } else if (drawmode == 9) {
            onsetshapelabel(m[0], m[1], -1, index, sindex, 'onshape'); setdrawmode(0);
        } else if (drawmode == 1) { }
        else { setdrawmode(0); }
    }
}
function onshapecontextmenu() {
    removeshapecorners(0,'onshapecontextmenu');
    d3.event.preventDefault();
    let m = d3.mouse(this);
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let mode = this.getAttribute("smode");
    //console.log(index, sindex, partsrno, areaid, mode);
    if (mode == 'shape') { setdrawshape31(sindex, partsrno, areaid, mode, 'onshapecontextmenu'); }
    else if (mode == 'slabpart') {onsetslabpartshape31(sindex, spindex, partsrno, areaid, 'onshape');}    
    drawshapecontrols(index, sideindex, m[0], m[1]);
}
function onduplshapecounter(val, index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    let newdupcount = dupcount + parseInt(val);
    if (newdupcount == 0) { newdupcount = 1; }
    $('#shapectlduplinput' + shape.index).val(newdupcount);
}
function onduplicateshape(index) {
    let dupcount = parseInt($('#shapectlduplinput' + shape.index).val());
    if (shape.unitcount > 1) { shape.dupcount = parseInt(shape.dupcount) + dupcount; }
    setduplicateshape31(dupcount);
   // ActionDuplicateShape(partlen, dupcount, 'onduplicateshape');
}
function ondeleteshape(index) {
    removeshapetools();   
    deleteshape1(index, 'ondeleteshape');
    drawlogservice.remove(shape, 'ondeleteshape', 1);
}
function deleteshape1(index, source) {
   deleteshape(index);   
   ActionShapeRemove(index, source);
}
function deleteshape(index) {    
    let areashapeindex =  shape.areaid + "" +  index;
    shapesg.select("#shapeouter" + areashapeindex).remove();
}
function resetduplicateshapesideitems(dupside, sindex) {
    dupside.sindex = sindex;
    for (var j = 0; j < dupside.edges.length; j++) {
        dupside.edges[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.splashs.length; j++) {
        dupside.splashs[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.corners.length; j++) {
        dupside.corners[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.cutouts.length; j++) {
        dupside.cutouts[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.sideshapes.length; j++) {
        dupside.sideshapes[j].sindex = sindex;
    }
    for (var j = 0; j < dupside.seams.length; j++) {
        dupside.seams[j].sindex = sindex;
    }
}
function shapedragstarted() {  
    if (bdraw) { onendshapedraw(); return; }
   // if (drawmode != 0) { return;}
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        removehandles();
        let index = parseInt(this.getAttribute("index"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let mode = this.getAttribute("smode");       
        if (mode == 'shape') {
            reseteditmode('shapedragstarted');
            drawlogservice.beforeupdate(shape, 'shapedragstarted', 1);
            bdrag = true;
            setdrawshape31(index, partsrno, areaid, mode, 'shapedragstarted');
        } else if (mode == 'slabpart') {
           // shapeouterg.attr("pointer-events", "none");
            bdrag = true;
            reseteditmode('slabpartdragstarted');
            //console.log(index, spindex, partsrno, areaid, 'shapedragstarted');
            onsetslabpartshape31(index, spindex, partsrno, areaid, 'shapedragstarted');
        }
    }
}
function shapedragged() {
    if (bdrag && shape!=undefined) {
        d3.event.sourceEvent.stopPropagation(); 
        let ndx = this.x || shape.tx;
        let ndy = this.y || shape.ty;
        ndx += d3.event.dx;
        ndy += d3.event.dy;
        let stx = shape.tx, sty = shape.ty;       
        if (shape.mode == 'shape') {
            let sgscale = getshapesgscale();
            shape.tx = Math.round(ndx), shape.ty = Math.round(ndy), shape.tscale = zscale;
            transformshape();
            if (!isshapeinbounds(sgscale)) {
                shape.tx = stx, shape.ty = sty;
                transformshape();
            }
        } else if (shape.mode == 'slabpart') {
            //shapeouterg.attr("pointer-events", "none");
            let sgscale = getslabpartshapesgscale();
            shape.tx = Math.round(ndx), shape.ty = Math.round(ndy), shape.tscale = zscale;
            transformshape();
            if (!isslabpartinbounds(sgscale)) {
                shape.tx = stx, shape.ty = sty;
                transformshape();
            }
        }
    }
}
function shapedragended() {
    if (bdrag && shape != undefined) {       
        bdrag = false;
        if (shape.mode == 'slabpart') {
            ondragslabpart32();            
            ActionSlabPart('shapedragended');
            shapeouterg.attr("pointer-events", "auto");
        } else {    
            drawlogservice.update(shape, 'shapedragended', 1);
            ActionUpdateShape('shapedragended');
        }
    }
}
function transformshape() {    
    let ztx = shape.tx, zty = shape.ty, stscale = shape.tscale;    
    if (shape.mode == 'slabpart') { stscale = lzscale; shape.ltscale = stscale; } else { stscale = zscale; shape.tscale = stscale; }
    ztx = Math.round(ztx * stscale), zty = Math.round(zty * stscale);
   // console.log("sindex:" + shape.index, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "stscale:" + shape.tscale, "sx:" + shape.x, "sy:" + shape.y);
    let npt = [ztx, zty];   
    shapeouterg.attr('transform', 'translate(' + npt + ') scale(' + stscale + ')');
}
function onrotateshape(type, index, angle) {
    rotateshape(type, index, angle);    
    if (shape.mode == 'slabpart') {     
        ActionSlabPart('onrotateshape');
       // onsetslabpartclipimage(index);
    }
    else if (shape.mode == 'shape') {
        drawshapesides(shape.index, 'onrotateshape');
        ActionRotateShape('onrotateshape');
       // onsetshapeslabpartsclipimage(index);
    }
}
function rotateshape(type, index, angle) {
    if (!shapeg.empty()) {
        if (type == 0) { shape.angle = angle; }
        else if (type == 1) { shape.angle += angle; }
        else if (type == -1) { shape.angle -= angle; }
        var gnode = shapeg.node();
        var sx = gnode.getBBox().x + gnode.getBBox().width / 2; sy = gnode.getBBox().y + gnode.getBBox().height / 2;
        var npt = [sx.toFixed(), sy.toFixed()];
        shapeg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");       
        if (shape.mode == 'shape') {
            //let shapeslabimagesg = d3.select("#shapeslabimgsg" + index);
            //shapeslabimagesg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");
        }        
        $('#shapectlinputangle' + index).val(shape.angle);
    }
}
function reseteditmode(source) {
    if (editmode == 1) {
        editmode = 0; drawshapesides(shape.index, source);
        if (bedit == true) { bedit = false; loguseraction("editshape", source); }
    }
}
function removedrawhandles() {
    if (drawhandlesg != undefined) { shapesg.select("#drawhandlesg").remove(); }
}
function removeanglehandles() {
    if (anglehandlesg != undefined) { anglehandlesg.selectAll('*').remove(); }
}
function removehandles() {
    removedrawhandles();
    removeanglehandles();
    removeshapetools();
}
/*Drawing log service*/
function undoredo(type) {
    if (type == 0) {
        drawlogservice.undodraw();
    } else {
        drawlogservice.redodraw();
    }
}
function onundodeleteshape(index) {
    //console.log(index,'onundodeleteshape');
    deleteshape1(index, 'onundodeleteshape');
}
function onundodrawshape(index) {
    console.log(index, 'shape', 'onundodrawshape');
    drawshape32(index, 'shape', 'onundodrawshape');
    ActionUndoRedoDrawShape('onundodrawshape');
}
function onredodrawshape(index) {
    console.log(index, 'shape', 'onredodrawshape');
    drawshape32(index, 'shape', 'onredodrawshape');
    ActionUndoRedoDrawShape('onredodrawshape');
}
function onundoudpateshape(item, type) {
    // console.log(item.index, shapes.length);
    let areashapeindex = item.areaid + "" + item.index;
    $("#shapeouter" + areashapeindex).remove();
    let partid = shape.partid;
    shape = angular.copy(item);
    shape.partid = partid;
    drawshape32(item.index, 'shape', 'onundoudpateshape');
    ActionUpdateShape('onundoudpateshape');    
}
function onredoudpateshape(item, type) {
    // console.log(item.index, shapes.length);
    let areashapeindex = item.areaid + "" + item.index;
    $("#shapeouter" + areashapeindex).remove();
    let partid = shape.partid;
    shape = angular.copy(item);
    shape.partid = partid;
    drawshape32(item.index, 'shape', 'onredoudpateshape');
    ActionUpdateShape('onundoudpateshape');
}
