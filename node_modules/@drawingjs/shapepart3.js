/*add shape to part*/
function onaddshapetoareapart(shapeindex, shapesides) {
    let version = _qscope.quote.header.Version, sqft = 0;
    //S1:prepare part
    let part = onsetpart(area.ID, version.ID, shapeindex);
    //S2:add part
    onaddareapart(part, version);
    //S3:prepare shape to part
    onshapetopart(part, shapeindex, shapesides);
}
function onsetpart(areaId, versionId, shapeindex) {
    let part = initpart();
    part.AreaID = areaId;
    part.VersionID = versionId;
    part.UserID = getloginuserId();
    part.ShapeIndex = shapeindex;
    return part;
}
function onaddareapart(part, version) {
    //S1:prepare part
    preparepartitems(part, version.LatestCoID, version.LatestCoSrNo, version.MatPercent, version.FabPercent, version.GradePercent, version.LaborPercent);
    //S2;get part srno if parts length grater than 0
    if (area.PartList == null || area.PartList.length == 0) { area.PartList = []; part.SrNo = 1; } else { part.SrNo = getpartserialno(area.PartList.length + 1); }
    //S3:add part
    area.PartList.push(part); _qscope.selectedPartSrNo = part.SrNo;
    return part;
}
function preparepartitems(part, coid, cono, matcent, fabcent, gradecent, laborcent) {
    //S1.set part material
    setpartmaterial1(part, coid, cono, matcent);
    let materialid = getpartmaterialid(part);
    //S2.set part fabrication
    setpartfab1(part, coid, cono, fabcent, materialid);
    //S3.set part spalsh
    setpartsplash1(part, coid, cono, gradecent, materialid);
    //S4.set part edges
    setpartedge1(part, coid, cono, gradecent);
    setdefaultpartedgelists1(part, _qscope.searchobj1.edgeList, coid, cono, gradecent);
    //S5.set cutouts
    setpartcutout1(part, coid, cono, gradecent, 1);//1-sinkcutout,2-oulet,3-appliance    
    setpartcutout1(part, coid, cono, gradecent, 3);//1-sinkcutout,2-oulet,3-appliance    
    setpartcutout1(part, coid, cono, gradecent, 2);//1-sinkcutout,2-oulet,3-appliance
    //S6:default labor lists
    //setdefaultpartlaborlists1(part, _qscope.searchobj1.defaultLaborList, coid, cono, laborcent);
    //S7:template & install items
    setdefaultpartLabor1(part, coid, cono, laborcent, 1);//template
    setdefaultpartLabor1(part, coid, cono, laborcent, 2);//install
    return part;
}
function getpartserialno(no) {
    let partno = no;
    if (area.PartList != null) {
        for (let i = 0; i < area.PartList.length; i++) { if (area.PartList[i].SrNo == no) { return no += 1; } }
    }
    return no;
}
function onshapetopart(part, shapeindex, shapesides) {
    if (part != "") {
        //S1:get material Id
        let partmat = "";
        if (part.PartMaterialList != null && part.PartMaterialList.length > 0) { partmat = part.PartMaterialList[part.PartMaterialList.length - 1]; }
        //s1:shape
        onsetshape(part, partmat);
        //s2:sizes
        if (part.PartFabList != null && part.PartFabList.length > 0) {
            onsetmeasurements(part, part.PartFabList[part.PartFabList.length - 1], shapeindex, shapesides);
        }
        //s3:part shapes
        let partshapes = getpartshapes(part.ID, part.SrNo, part.AreaID);
        //s4:default finished edge
        onsetdefaultfinishededge(part, partshapes);
        //s5:partmat sqft
        //let partmat = part.PartMaterialList[part.PartMaterialList.length - 1];
        if (partmat != "" && partmat.MaterialID > 0) {
            sqft = calcpartmaterialfinishedtotalsqft(part, partmat.MaterialID);
        }
        partmat.Sqft = sqft; partmat.Qty = sqft;
        //s6:shape string
        part.Shape = JSON.stringify(partshapes);
        //s7:qty restset when labor item unittype is Sqft.
        setpartlaborqty1(part);
    }
}
function onsetshape(part, partmat) {
    shape.areaid = part.AreaID;
    shape.partid = part.ID;
    shape.partsrno = part.SrNo;
    shape.materialid = partmat.MaterialID == "" ? 0 : partmat.MaterialID;
}
function onsetmeasurements(part, fab, shapeindex, sides) {
    let prsideheight = 0; //temp solution. would need to rework
    for (let i = 0; i < sides.length; i++) {
        setmeasurement(fab, shapeindex, sides[i], prsideheight);
        prsideheight = rounddecimal(sides[i].h / scale);
        setsideshapespart(part, fab, shapeindex, sides[i]);
    }
    fab.PartSqft = calcpartfabsqft(fab, fab.MaterialID);
    fab.SplashSqft = calcpartsplashstotalsqft(part.SplashList, fab.MaterialID);
}
function setmeasurement(fab, shapeindex, side, prsideh) {
    //let w1 = side.w1, w2 = side.w2, w = (w1 + w2) / 2, h = side.h / 4;
    let w1 = side.w1, w2 = side.w2, w = (w1 > w2 ? w1 : w2), h = rounddecimal(side.h / scale);
    if (w1 == w2) { w = w1; } else if (w1 > w2) { w = w1 - prsideh; } else if (w1 < w2) { w = w2 - prsideh; }
    pushmeasurement(fab, shapeindex, side, w, h);
}
function pushmeasurement(fab, shapeindex, side, w, h) {
    let size = {};
    size.Width = roundToTwo(w);
    size.Height = roundToTwo(h);
    size.Sqft = calcsqft(w, h);
    size.shapeindex = shapeindex;
    size.index = side.index;
    size.Note = side.note;
    size.CounterType = side.stype;
    size.CounterTypeID = side.stypeid;
    if (fab.MeasureList == null) { fab.MeasureList = []; }
    if (fab.MeasureList.length == 1 && fab.MeasureList[0].Width == 0 && fab.MeasureList[0].Height == 0) {//first size
        resetfabsize(fab, shapeindex, side, w, h);
    } else {
        fab.MeasureList.push(size);
    }
}
function setsideshapespart(part, fab, shapeindex, side) {
    //rework
    setsideshapespartmeasurement(part, fab, shapeindex, side);
    if (side.sideshapes != undefined) {
        for (let i = 0; i < side.sideshapes.length; i++) {
            setsideshapepartedge(part, fab, shapeindex, side, side.sideshapes[i]);
        }
    }
}
function setsideshapespartmeasurement(part, fab, shapeindex, side) {
    //1. one bumpout measurement per side with sideshape max height.
    if (side.sideshapes != undefined) {
        let h = 0, w = 0, bpush = false;
        for (let i = 0; i < side.sideshapes.length; i++) {
            let sideshape = side.sideshapes[i];
            if (sideshape.isactive == 1) {
                if (sideshape.type != 2 && sideshape.type != 5 && sideshape.type != 7) {
                    bpush = true;
                    let h1 = rounddecimal(sideshape.h / scale);
                    if (h1 > h) { h = h1; }
                    if (w == 0) { if (sideshape.sidecode == 1) { w = rounddecimal(side.w1); } else if (sideshape.sidecode == 2) { w = rounddecimal(side.w2); } else { w = rounddecimal(side.h / scale); } }
                }
            }
        }
        if (bpush) { pushmeasurement(fab, shapeindex, side, w, h); }
    }
}
function onsetdefaultfinishededge(part, partshapes) {
    let tempobj = { totalfinishedlf: 0 };
    //S1:finished edge
    oncaltotaldefaultfinishedlf(partshapes, tempobj);
    //S2:set finished edge
    onsetdefaultfedge(part, tempobj.totalfinishedlf, "Finished Edge");
    //setdefaultfedge(part, tempobj.totalfinishedlf, "Finished Edge(eased)");
}
function oncaltotaldefaultfinishedlf(partshapes, tempobj) {
    for (let i = 0; i < partshapes.length; i++) {
        onsetshapesidespart(partshapes[i].sides, tempobj);
    }
}
function onsetshapesidespart(sides, tempobj) {
    for (let i = 0; i < sides.length; i++) {
        let w1 = sides[i].w1, w2 = sides[i].w2, h1 = sides[i].h / 4;
        oncaltotalflatedgeslf(sides[i].edges, w1, w2, h1, tempobj);
    }
}
function oncaltotalflatedgeslf(edges, w1, w2, h1, tempobj) {
    for (let i = 0; i < edges.length; i++) {
        let width = 0;
        if (edges[i].code == 1) { width = w1; }
        else if (edges[i].code == 2) { width = w2; }
        else if (edges[i].code == 0 || edges[i].code == 3) { width = h1; }
        if (edges[i].type == 'F') { tempobj.totalfinishedlf += calclinerfeet(width); }
    }
}
function onsetdefaultfedge(part, edgelf, description) {
    let edgemodel = "";
    if (part.EdgeList != null) {
        part.EdgeList.map(function (elem) { if (elem.Description == description && elem.CoID == _qscope.quote.header.Version.LatestCoID) { edgemodel = elem; edgemodel.EdgeProfile = description; return elem } { return 0 } });
    }
    if (edgemodel != "") {
        edgemodel.LF = roundToTwo(edgelf); edgemodel.Isactive = edgelf != 0 ? 1 : 0; edgemodel.CopyQty = edgemodel.LF;
        //edgemodel.UnitPrice = (edgemodel.Description == 'Finished Edge(eased)' && edgemodel.UnitPrice == 0) ? 9 : edgemodel.UnitPrice;
    } else {
        onadddefaultedge(part, edgelf, description);
    }
}
function onadddefaultedge(part, totallf, description) {
    let edge = {}, coId = _qscope.quote.header.Version.LatestCoID, cono = _qscope.quote.header.Version.LatestCoSrNo;
    //if (coId > 0) {
    //    let emodel = "";
    //    part.EdgeList.map(function (elem) { if (elem.Description == description && elem.IsChg != 2) { emodel = elem; return elem } { return 0 } });
    //    if (emodel != "") { emodel.IsChg = 2; edge.ParentID = emodel.ID; }
    //}
    edge.ID = 0;
    edge.AreaID = part.AreaID;
    edge.VersionID = part.VersionID;
    edge.EdgeProfileID = 0;
    edge.EdgeProfile = description;
    edge.Description = description;
    edge.LF = roundToTwo(totallf); edge.CopyQty = edge.LF;
    edge.UnitPrice = 0; edge.IsChg = 0;
    //edge.UnitPrice = description == 'Finished Edge(eased)' ? 9 : 0;
    edge.IsChgFlag = 1;
    edge.ParentID = 0;
    edge.SaveFlag = 1; edge.IsPrint = 1;
    edge.IsOptional = 0;
    edge.Tax = _qscope.quote.header.Version.GradePercent > 0 ? 1 : 0;
    edge.Isactive = 1;
    edge.DiscAmt = 0;
    edge.CoID = coId;
    edge.CoSrNo = cono;
    edge.Amt = calcitemamt(edge.LF, edge.UnitPrice);
    part.EdgeList.push(edge);
}