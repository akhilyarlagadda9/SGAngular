function initshapeside(index) {
    var side = {
        index: index, spsideindex: index, sindex: shape.index, angle: 0, atype: 1, asign: 1, dsign: 1, h: shape.h, w: 0, w1: 0, w2: 0, x1: 0, y1: 0, x2: 0, y2: 0, stype: '', stypeid: 0, note: '',
        x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, cline: 0, edges: [], corners: [], sideshapes: [], cutouts: [], seams: [], splashs: [], sidesegs: []
    };
    shape.sides.push(side);
    initsidecorners(index);
    initsidesegs(side);
}
function initsidesegs(side) {
    side.sidesegs = [];
    side.sidesegs.push({ sidecode: 0, segs: [] });
    side.sidesegs.push({ sidecode: 1, segs: [] });
    side.sidesegs.push({ sidecode: 2, segs: [] });
    side.sidesegs.push({ sidecode: 3, segs: [] });
}
function setnewshapeside(x2, y2) {
    let dh = applymminchfact1(shape.h / 2, 3, 2, 'setnewshapeside');
    let x1 = 0, y1 = 0;
    let index = shape.opoints.length - 1;
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
    let npt2 = offsetline(x1, y1, x2, y2, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;
    setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22);
    for (var j = 0; j < shape.sides.length; j++) {
        shapesideintrpoints(j);
        shapesideintrpoints1(j);
        shapesideintrpoints2(j);
    }
    setsideedges(index, 'F');
}
function setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22) {
    if (index > shape.sides.length - 1) { initshapeside(index); }
    setsidecenterline(index, x1, y1, x2, y2);
    setsideouterline1(index, x11, y11, x12, y12);
    setsideouterline2(index, x21, y21, x22, y22);
}
function setsidecenterline(index, x1, y1, x2, y2) {
    let source = 'setsidecenterline';
    let side = shape.sides[index];
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
}
function setsideouterline1(index, x11, y11, x12, y12) {
    let source = 'setsideouterline1';
    let side = shape.sides[index];
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.w1 = applymminchfact(calchyplen(x11, y11, x12, y12), 2, 2, source);   
}
function setsideouterline2(index, x21, y21, x22, y22) {
    let source = 'setsideouterline1';
    let side = shape.sides[index];
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w2 = applymminchfact(calchyplen(x21, y21, x22, y22), 2, 2, source);    
}
function cornerbumpoutpos(index, sideindex, corner, sidepoints) {
    let side = shape.sides[sideindex];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1, type = corner.type,
    sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
    let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
    let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
    let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;
    let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
    let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
    let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));
    if (angle1 != angle2) {
        npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
        dx1 = npt1.dx, dy1 = npt1.dy;
        sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
    }
    if (index == 0) {
        x11 = sx1, y11 = sy1, sx22 = sx1, sy22 = sy1;
        let ipt1 = calintersection1(x11, y11, x21, y21, sx11, sy11, sx12, sy12);
        sx12 = ipt1.dx, sy12 = ipt1.dy;        
    } else if (index == 1) {
        x21 = sx1, y21 = sy1, sx22 = sx1, sy22 = sy1;       
    } else if (index == 2) {
        x12 = sx1, y12 = sy1, sx21 = sx1, sy21 = sy1;
        let ipt1 = calintersection1(x12, y12, x22, y22, sx11, sy11, sx12, sy12);
        sx11 = ipt1.dx, sy11 = ipt1.dy;    
    } else if (index == 3) {
        x22 = sx1, y22 = sy1, sx21 = sx1, sy21 = sy1;        
    }
    //drawpointcircle(20, index, sideindex, sidecode, sx11, sy11, 10, 'A');
    //drawpointcircle(30, index, sideindex, sidecode, sx12, sy12, 10, 'U');
    //drawpointcircle(40, index, sideindex, sidecode, sx21, sy21, 10, 'F');
    //drawpointcircle(50, index, sideindex, sidecode, sx22, sy22, 15, 'A');
    
    sidepoints.push({ dx: sx12, dy: sy12 });
    sidepoints.push({ dx: sx22, dy: sy22 });
    sidepoints.push({ dx: sx21, dy: sy21 });
    sidepoints.push({ dx: sx11, dy: sy11 });
   
   
    
}
function sidestartpos(sideindex, sidecode, source) {
    let side = shape.sides[sideindex];
    let x1 = 0, y1 = 0,cindex =0;
    if (sidecode == 0) { x1 = side.x11, y1 = side.y11; cindex = 0; } else if (sidecode == 1) { x1 = side.x11, y1 = side.y11; cindex = 0; }
    else if (sidecode == 2) { x1 = side.x21, y1 = side.y21; cindex = 1; } else if (sidecode == 3) { x1 = side.x12, y1 = side.y12; cindex = 2; }
    if (cindex != -1) {
        let corner1 = side.corners[cindex];       
        if (corner1.type != 0) {
            if (sidecode == 0 || sidecode == 3) {
                if (shape.mode == 'slabpart' && corner1.split == 1) {
                    x1 = corner1.sx1, y1 = corner1.sy1;
                } else { x1 = corner1.x3, y1 = corner1.y3; }               
            } else {
                x1 = corner1.x2, y1 = corner1.y2;
            }
        }       
    }
    return { dx: x1, dy: y1 };
}
function sidestartpos1(sideindex, sidecode, sidepoints, source) {
    let side = shape.sides[sideindex];
    let x1 = 0, y1 = 0, cindex = 0;
    if (sidecode == 0) { x1 = side.x11, y1 = side.y11; cindex = 0; } else if (sidecode == 1) { x1 = side.x11, y1 = side.y11; cindex = 0; }
    else if (sidecode == 2) { x1 = side.x21, y1 = side.y21; cindex = 1; } else if (sidecode == 3) { x1 = side.x12, y1 = side.y12; cindex = 2; }
    let corner1 = side.corners[cindex];
    if (corner1.type != 0) {
        if (sidecode == 0 || sidecode == 3) {
            if (shape.mode == 'slabpart' && corner1.split == 1) {
                if (corner1.type == 4) {
                    cornerbumpoutpos(cindex, sideindex, corner1, sidepoints);
                } else {
                    x1 = corner1.sx1, y1 = corner1.sy1;
                    sidepoints.push({ dx: x1, dy: y1 });
                }
            } else {
                x1 = corner1.x3, y1 = corner1.y3;
                sidepoints.push({ dx: x1, dy: y1 });
            }
        } else {
            x1 = corner1.x2, y1 = corner1.y2;
            sidepoints.push({ dx: x1, dy: y1 });
        }
    } else { sidepoints.push({ dx: x1, dy: y1 }); }
}
function sideendpos1(sideindex, sidecode, source) {   
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0, cindex = -1;
    if (sidecode == 1) { x2 = side.x12, y2 = side.y12, cindex = 2; } else if (sidecode == 2) { x2 = side.x22, y2 = side.y22, cindex = 3; }
    if (sideindex == shape.sides.length - 1) {       
        let corner1 = side.corners[cindex];
        if (corner1 != undefined && corner1.type != 0) {
            if (shape.mode == 'slabpart' && corner1.split == 1) {
                x2 = corner1.x3, y2 = corner1.y3;
            } else { x2 = corner1.x2, y2 = corner1.y2; }
        }
    } else if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];
        if (sidecode == 1) { x2 = side1.x11, y2 = side1.y11, cindex = 0; } else if (sidecode == 2) { x2 = side1.x21, y2 = side1.y21, cindex = 1; }
        let corner1 = side1.corners[cindex];
        if (corner1 != undefined && corner1.type != 0) {           
            x2 = corner1.x3, y2 = corner1.y3;
        }
    }
    return { dx: x2, dy: y2 };
}
function sideendpos2(sideindex, sidecode) {   
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0, cindex = 0;
    if (sidecode == 0) { x2 = side.x21, y2 = side.y21; cindex = 1; } else if (sidecode == 3) { x2 = side.x22, y2 = side.y22; cindex = 3; }
    let corner1 = side.corners[cindex];
    if (corner1 != undefined && corner1.type != 0) {
        if (shape.mode == 'slabpart' && corner1.split == 1) {
            //console.log(shape.index, sideindex, sidecode, cindex, corner1.type);
            x2 = corner1.sx1, y2 = corner1.sy1;
        } else { x2 = corner1.x3, y2 = corner1.y3; }
    }
    return { dx: x2, dy: y2 };
}
function sideendpos3(sideindex, sidecode, sidepoints, source) {
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0, cindex = -1;
    if (sidecode == 1) { x2 = side.x12, y2 = side.y12, cindex = 2; } else if (sidecode == 2) { x2 = side.x22, y2 = side.y22, cindex = 3; }
    if (sideindex == shape.sides.length - 1) {
        let corner1 = side.corners[cindex];
        if (corner1 != undefined && corner1.type != 0) {
            if (shape.mode == 'slabpart' && corner1.split == 1) {
                if (corner1.type == 4) { cornerbumpoutpos(cindex, sideindex, corner1, sidepoints); } else {
                    x2 = corner1.x3, y2 = corner1.y3;
                    sidepoints.push({ dx: x2, dy: y2 });
                }
            } else {
                x2 = corner1.x2, y2 = corner1.y2;
                sidepoints.push({ dx: x2, dy: y2 });
            }
        } else { sidepoints.push({ dx: x2, dy: y2 }); }
    } else if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];
        if (sidecode == 1) { x2 = side1.x11, y2 = side1.y11, cindex = 0; } else if (sidecode == 2) { x2 = side1.x21, y2 = side1.y21, cindex = 1; }
        let corner1 = side1.corners[cindex];
        if (corner1 != undefined && corner1.type != 0) {
            x2 = corner1.x3, y2 = corner1.y3;
        }
        sidepoints.push({ dx: x2, dy: y2 });
    }
  
}
function sideendpos4(sideindex, sidecode, sidepoints, source) {
    let side = shape.sides[sideindex];
    let x2 = 0, y2 = 0, cindex = 0;
    if (sidecode == 0) { x2 = side.x21, y2 = side.y21; cindex = 1; } else if (sidecode == 3) { x2 = side.x22, y2 = side.y22; cindex = 3; }
    let corner1 = side.corners[cindex];
    if (corner1 != undefined && corner1.type != 0) {
        if (shape.mode == 'slabpart' && corner1.split == 1) {
            if (corner1.type == 4) { cornerbumpoutpos(cindex, sideindex, corner1, sidepoints); } else {
                x2 = corner1.sx1, y2 = corner1.sy1;
                sidepoints.push({ dx: x2, dy: y2 });
            }
        } else {
            x2 = corner1.x3, y2 = corner1.y3;
            sidepoints.push({ dx: x2, dy: y2 });
        }
    } else { sidepoints.push({ dx: x2, dy: y2 }); }   
}
function sidecornerendpos(sideindex, sidecode) {    
    let x1 = 0, y1 = 0, x2 = 0, y2 = 0, cindex = 0;
    if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];
        if (sidecode == 1) { x1 = side1.x11, y1 = side1.y11, cindex = 0; } else if (sidecode == 2) { x1 = side1.x21, y1 = side1.y21, cindex = 1; }
        let corner1 = side1.corners[cindex];
        if (corner1 != undefined && corner1.type != 0) {
            x2 = corner1.x2, y2 = corner1.y2;
        }
    }
    return { dx: x2, dy: y2 };
}
function ressetshapesidesegs(source) {
    for (let i = 0; i < shape.sides.length; i++) {
        setshapesidesegs(i);
    }
}
function setshapesidesegs(sideindex) {
    if (sideindex == 0) { setsidesegs(sideindex, 0); }
    setsidesegs(sideindex, 1);
    setsidesegs(sideindex, 2);
    if (sideindex == shape.sides.length - 1) { setsidesegs(sideindex, 3); }
}
function setsidesegs(sideindex, sidecode) {
    let source = 'setsidesegs';
    let side = shape.sides[sideindex];
    if (side.sidesegs == undefined || side.sidesegs.length == 0) { initsidesegs(side); }
    let sidecodeseg = side.sidesegs[sidecode];
    sidecodeseg.segs = [];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let sx1 = 0, sy1 = 0, sgx1 = 0, sgy1 = 0, sgx2 = 0, sgy2 = 0, angle = 0, seamsplit = 0;
    let npt = sidestartpos(sideindex, sidecode, source);
    sx1 = npt.dx, sy1 = npt.dy, sgx1 = npt.dx, sgy1 = npt.dy, sw1 = 0, sw2 = 0;
    if (sidecode == 0) { angle = calclineangle2(x11, y11, x21, y21) }
    else if (sidecode == 1) { angle = calclineangle2(x11, y11, x12, y12); }
    else if (sidecode == 2) { angle = calclineangle2(x21, y21, x22, y22); }
    else if (sidecode == 3) { angle = calclineangle2(x12, y12, x22, y22); }

    let sidecodeshapes = [];
    for (let j = 0; j < side.sideshapes.length; j++) {
        let sideshape = side.sideshapes[j];
        if (sideshape.isactive == 1 && sideshape.sidecode == sidecode) {            
            let srw = Math.round(calchyplen(sx1, sy1, sideshape.x11, sideshape.y11));
            sideshape.srw = srw;
            sidecodeshapes.push(sideshape);
        }
    }
    sidecodeshapes = sidecodeshapes.sort((a, b) => (a.srw > b.srw) ? 1 : -1);   
    for (let j = 0; j < sidecodeshapes.length; j++) {
        let sideshape = sidecodeshapes[j];
        let npt = getsideshapecoords(sideshape, side), typeid = sideshape.typeid, sh = sideshape.h;
        seamsplit = npt.seamsplit;
        if (npt.seamsplit == 1 && (typeid == 1 || typeid == 2 || typeid == 3)) {
            //  console.log(j, sidecode, typeid);
            sgx2 = npt.x11, sgy2 = npt.y11;
            setsidecodeseg(sx1, sy1, sgx1, sgy1, sgx2, sgy2, sh, typeid, sidecodeseg);
            sgx1 = npt.x12, sgy1 = npt.y12;
        } else {
            sgx2 = npt.x11, sgy2 = npt.y11;
            setsidecodeseg(sx1, sy1, sgx1, sgy1, sgx2, sgy2, sh, typeid, sidecodeseg);
            sgx1 = npt.x12, sgy1 = npt.y12;
        }
    }    
    if (sidecode == 0 || sidecode == 3) { npt = sideendpos2(sideindex, sidecode, source); } else { npt = sideendpos1(sideindex, sidecode, source); }
    sgx2 = npt.dx, sgy2 = npt.dy;
    setsidecodeseg(sx1, sy1, sgx1, sgy1, sgx2, sgy2, 0, 0, sidecodeseg); 
}

function getsideshapecoords(sideshape, side) {   
    let index = sideshape.index, sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22
    typeid = sideshape.typeid, sidecode = sideshape.sidecode, sw = sideshape.w, seamsplit=0;
    if (shape.mode == 'slabpart') {
        if (sidecode == 1 || sidecode == 2) { npt = setsideshapeseampos31(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
        else { npt = setsideshapeseampos32(index, typeid, sidecode, side, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, sw); }
        sx11 = npt.sx11, sy11 = npt.sy11, sx12 = npt.sx12, sy12 = npt.sy12, sx21 = npt.sx21, sy21 = npt.sy21, sx22 = npt.sx22, sy22 = npt.sy22, seamsplit = npt.seamsplit;
    }
    return {
        x11: Math.round(sx11), y11: Math.round(sy11), x12: Math.round(sx12), y12: Math.round(sy12), x21: Math.round(sx21), y21: Math.round(sy21), 
        x22: Math.round(sx22), y22: Math.round(sy22), seamsplit:seamsplit
    };
}
function sidesegswidth(sideindex, sidecode) {
    let sw = 0;
    let side = shape.sides[sideindex];
    let sidecodeseg = side.sidesegs[sidecode];
    for (let i = 0; i < sidecodeseg.segs.length; i++) { sw += sidecodeseg.segs[i].sw; }
    return roundToTwo(sw);
}
function setsidecodeseg(sx1, sy1, sgx1, sgy1, sgx2, sgy2, sh, stypeid, sidecodeseg) {
    //console.log(sx1, sy1, sgx1, sgy1, sgx2, sgy2, sh, stypeid);
    let srw = Math.round(calchyplen(sx1, sy1, sgx1, sgy1));
    let segw = applymminchfact(calchyplen(sgx1, sgy1, sgx2, sgy2), 2, 2, 'setsidecodeseg');
    let seg = { x1: sgx1, y1: sgy1, x2: sgx2, y2: sgy2, srw: srw, sw: segw, sh: sh, stypeid: stypeid };
    sidecodeseg.segs.push(seg);
}
function getshapesidepoints(index) {
    let source = 'getshapesidepoints';
    let side = shape.sides[index];
    let sidepoints = [], npt = {};
    if (index == 0) { sidestartpos1(index, 0, sidepoints, source); } // sidecode==0
    sidestartpos1(index, 1, sidepoints, source); // sidecode==1
    sideendpos3(index, 1, sidepoints, source); // sidecode==1
    if (shape.sides.length > 0) {
        npt = sidecornerendpos(index, 1); if (npt.dx != 0 && npt.dy != 0) { sidepoints.push(npt); }// sidecode==1
        npt = sidecornerendpos(index, 2); if (npt.dx != 0 && npt.dy != 0) { sidepoints.push(npt); }// sidecode==2
    }
    if (index == shape.sides.length - 1) {
        sidestartpos1(index, 3, sidepoints, source);
        sideendpos4(index, 3, sidepoints, source);
    }// sidecode==3
    sideendpos3(index, 2, sidepoints, source);// sidecode==2
    sidestartpos1(index, 2, sidepoints, source);// sidecode==2
    if (index == 0) { sideendpos4(index, 0, sidepoints, source); }// sidecode==0
    return sidepoints;
}
function onshapeside() {
    let source = 'onshapeside';
    removeshapetools();
    d3.event.stopPropagation();
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        if (editmode == 1) { editmode = 0; drawshapesides(shape.index, source); }
        let m = d3.mouse(this);
        let index = parseInt(this.getAttribute("index"));
        let code = parseInt(this.getAttribute("code"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, source);
        if (drawmode == 3) {
            onsetsideshape(m[0], m[1], -1, index, code, source);
        } else if (drawmode == 4) {
            onsetsidesplash(index, code, 1, source);
        } else if (drawmode == 5) {
            onsetsideedge(index, code, edgetype, edgetypeid, source);
        } else if (drawmode == 8) {
            onsetsideapron(index, code, 1, edgetype, edgetypeid, countersidemode);
        }
    }
}
function oneditshapeside() {
    let source = 'oneditshapeside';
    let objVal = $(this).val().split(" ");
    let newval = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    if (isNaN(newval)) { return; }
    let mode = this.getAttribute("smode");
    let index = parseInt(this.getAttribute("index"));
    let code = parseInt(this.getAttribute("code"));   
    let prevval = parseFloat(this.getAttribute("prevval"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, source);
    drawlogservice.beforeupdate(shape, source, 3);
    editshapeside(index, code, prevval, newval);
    resetshapecorners(source)
    resetsideshapes(index, source);
    ressetshapesidesegs(source);
    resetshapesplashs(source);
    shapesides(source);    
    ActionShape(source);
    selectnextsideinputcontrol(sindex, index, code, source);
    drawlogservice.update(shape, source, 3);
}
function editshapeside(index, code, prevval, newval) {
    if (!validatesidechange(index, code, prevval, newval)) { return; }  
    let side = shape.sides[index];
    let w = side.w, w1 = side.w1, w2 = side.w2, h = side.h, dw = 0;
    let changetype = 1;
    if (code == 1 || code == 2) {
        if (prevval == w1) { dw = newval - side.w1, side.w1 = newval, side.w2 += dw, side.w += dw; changetype = 1; }
        else { dw = newval - side.w2, side.w2 = newval; side.w1 += dw, side.w += dw; changetype = 2; }
        //console.log(index, w1, w2, prevval, newval, dw, side.w1, side.w2, changetype, code, h);
        if (index == 0) { editshapeside1(index, changetype); } else {
            for (let i = index; i < shape.sides.length; i++) { editshapeside2(i, changetype); }
        }
        
    } else {
        dw = prevval - newval;       
        if (w1 >= w2) { changetype = 1; } else { changetype = 2; }
        side.h = applymminchfact1(newval, 1, 2, 'editshapeside');        
        editshapeside3(index, code, changetype);
        let sw1 = 0, sw2 = 0;
        if(shape.sides.length > 1){
            if (index == 0) {
                sw1 = shape.sides[index + 1].w1, sw2 = shape.sides[index + 1].w2;
              //  console.log(index, dw, sw1, sw2, w1, w2, code, changetype);
                if (sw1 >= sw2) { shape.sides[index + 1].w2 += dw; } else { shape.sides[index + 1].w1 += dw; }
            } else if (index == shape.sides.length - 1) {
                sw1 = shape.sides[index - 1].w1, sw2 = shape.sides[index - 1].w2;
             //   console.log(index, dw, sw1, sw2, w1, w2, code, changetype);
                if (sw1 >= sw2) { shape.sides[index - 1].w2 += dw; } else { shape.sides[index - 1].w1 += dw; }
            } else {
                sw1 = shape.sides[index + 1].w1, sw2 = shape.sides[index + 1].w2;
             //   console.log(index, dw, sw1, sw2, w1, w2, code, changetype);
                if (sw1 >= sw2) { shape.sides[index + 1].w2 += dw; } else { shape.sides[index + 1].w1 += dw; }
                sw1 = shape.sides[index - 1].w1, sw2 = shape.sides[index - 1].w2;
             //   console.log(index, dw, sw1, sw2, w1, w2, code, changetype);
                if (sw1 >= sw2) { shape.sides[index - 1].w2 += dw; } else { shape.sides[index - 1].w1 += dw; }
            }
        }       
    }  
}
function validatesidechange(index, code, prevval, newval) {
    let source='validatesidechange';
    let isvalid = true;
    let side = shape.sides[index], side1 = shape.sides[index - 1], side2 = shape.sides[index + 1], angle = 0, angle1 = 0, angle2 = 0;
    let w = side.w, w1 = side.w1, w2 = side.w2, h = side.h, dw = 0, h1 = 0, h2 = 0, dh = 24;
   // if (prevval == w1) { dw = newval - w1, w1 = newval, w2 += dw; } else { dw = newval - w2, w2 = newval; w1 += dw; }
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    angle = calclineangle2(x2, y2, x1, y1, source);
    if (newval < minwh) { isvalid = false; }
    if (isvalid && shape.sides.length > 1) {
        if (side1 != undefined) {
            h1 = applymminchfact1(side1.h, 2, 2, source);
            let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
            angle1 = calclineangle2(x2, y2, x1, y1, source);
            if (code == 1 || code == 2) {
                if (prevval == w1) {////console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                    if (w1 >= w2) {if ((newval - minwh) < h1) { isvalid = false;}} else {if (newval < minwh) { isvalid = false;}}
                }
                else {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                    if (w1 >= w2) {if (newval < minwh) { isvalid = false;}} else {if ((newval - minwh) < h1) { isvalid = false;}}
                }
            } else { //console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                if (side1.w1 >= side1.w2) {if ((newval + minwh) > side1.w1) { isvalid = false;}} else {if ((newval + minwh) > side1.w2) { isvalid = false;}}
            }
        }
        if (isvalid && side2 != undefined) {
            h2 = applymminchfact1(side2.h, 2, 2, source);
            let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
            angle2 = calclineangle2(x2, y2, x1, y1, source);
            if (code == 1 || code == 2) {
                if (prevval == w1) {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                    if (w1 >= w2) {if ((newval - minwh) < h2) { isvalid = false;}} else {if (newval < minwh) { isvalid = false;}}
                }
                else {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                    if (w1 >= w2) {if (newval < minwh) { isvalid = false;}} else {if ((newval - minwh) < h2) { isvalid = false;} }
                }
            } else {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                if (side2.w1 >= side2.w2) {if ((newval + minwh) > side2.w1) { isvalid = false;} } else {if ((newval + minwh) > side2.w2) { isvalid = false;}}
            }
        }
        if (isvalid && side1 != undefined && side2 != undefined) {
            if (code == 1 || code == 2) {
                if (prevval == w1) {
                    if (w1 >= w2) { if ((newval - minwh) < h1) { isvalid = false; } } else { if (newval < minwh) { isvalid = false; } }
                    //console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                }
                else {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                    if (w1 >= w2) {if (newval < minwh) { isvalid = false;}} else {if ((newval - minwh) < (h1 + h2)) { isvalid = false; }}
                }
            } else {//console.log("index:" + index, "code:" + code, "prevval:" + prevval, "newval:" + newval, "w1:" + w1, "w2:" + w2, "h1:" + h1, "h2:" + h2, "isvalid:" + isvalid);
                if (side2.w1 >= side2.w2) {if ((newval + minwh) > side2.w1) { isvalid = false;}} else {if ((newval + minwh) > side2.w2) { isvalid = false;}}
            }
        }
    }
   // console.log(index, code, prevval, newval, isvalid);
    if (isvalid) { isvalid = validatesidechangecorners32(index, code, prevval, newval, source); }
    if (!isvalid) {
        let mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
        drawmessagecontrols(shape.index, mx, my, 'Please check and enter valid counter measurement!', 'Invalid Shape Measurement Alert!' ,'shape');
    }
    return isvalid;    
}
function validatesidechangecorners32(sideindex, sidecode, prevval, newval, source) {
    //1. sides 
    let side = shape.sides[sideindex];
    let isvalid = true, w1 = side.w1, w2 = side.w2, h = applymminchfact(side.h, 2, 2), whr1 = 0, whr2 = 0;
    if (sidecode == 0) { //corner index =0, 1
        if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].h, 2, 2, source); }
        if (side.corners[1].type != 0) { whr2 = applymminchfact(side.corners[1].h, 2, 2, source); }
        if ((whr1 + whr2) > newval) { isvalid = false; }
    } else if (sidecode == 1) {
        if (sideindex == shape.sides.length - 1) { //corner index =0, 2
            if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].w, 2, 2, source); }
            if (side.corners[2].type != 0) { whr2 = applymminchfact(side.corners[2].w, 2, 2, source); }
            if ((whr1 + whr2) > newval) { isvalid = false; }
        } else {// 
            if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].w, 2, 2, source); }
            if (shape.sides[sideindex + 1].corners[0].type != 0) { whr2 = applymminchfact(shape.sides[sideindex + 1].corners[0].h, 2, 2, source); }
            if ((whr1 + whr2) > newval) { isvalid = false; }
        }
    } else if (sidecode == 2) {//corner index =1, 3
        if (sideindex == shape.sides.length - 1) { //corner index =0, 2
            if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].w, 2, 2, source); }
            if (side.corners[3].type != 0) { whr2 = applymminchfact(side.corners[3].w, 2, 2, source); }
            if ((whr1 + whr2) > newval) { isvalid = false; }
        } else {
            if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].w, 2, 2, source); }
            if (shape.sides[sideindex + 1].corners[3].type != 0) { whr2 = applymminchfact(shape.sides[sideindex + 1].corners[3].h, 2, 2, source); }
            if ((whr1 + whr2) > newval) { isvalid = false; }
        }
    } else if (sidecode == 3) {//corner index =2, 3
        if (side.corners[2].type != 0) { whr1 = applymminchfact(side.corners[2].h, 2, 2, source); }
        if (side.corners[3].type != 0) { whr2 = applymminchfact(side.corners[3].h, 2, 2, source); }
        if ((whr1 + whr2) > newval) { isvalid = false; }
    }
   // console.log("sideindex:" + sideindex, "sidecode:" + sidecode, "w1:" + w1, "w2:" + w2, "h:" + h, "newval:" + newval, "whr1:" + whr1, "whr2:" + whr2, "whr1 + whr2:" + (whr1 + whr2), "isvalid:" + isvalid);
    return isvalid;
}
function editshapeside1(index, changetype) {
    let source = 'oneditshapeside1';
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let w = applymminchfact(side.w, 1, 2, source), w1 = applymminchfact(side.w1, 1, 2, source), w2 = applymminchfact(side.w2, 1, 2, source), dx = 0, dy = 0, h = side.h, dw = 0;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x2, y2, x1, y1, source);
    if (side1 != undefined) { x2 = side1.x1, y2 = side1.y1, x12 = side1.x11, y12 = side1.y11, x22 = side1.x21, y22 = side1.y21; }

    let npt = rotate_point1(x2, y2, -1, angle, w);
    x1 = npt.dx, y1 = npt.dy;

    let npt1 = rotate_point1(x12, y12, -1, angle, w1);
    x11 = npt1.dx, y11 = npt1.dy;

    let npt2 = rotate_point1(x22, y22, -1, angle, w2);
    x21 = npt2.dx, y21 = npt2.dy;
    if (index == 0) {
        let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, x11, y11);
        x21 = npt3.dx, y21 = npt3.dy;
    }
    else if (index == shape.sides.length - 1) {
        let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, x12, y12);
        x22 = npt3.dx, y22 = npt3.dy;
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2; side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12; side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22; side.y22 = y22;
}
function editshapeside2(index, changetype) {
    let source = 'oneditshapeside2';
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let w = applymminchfact(side.w, 1, 2, source), w1 = applymminchfact(side.w1, 1, 2, source), w2 = applymminchfact(side.w2, 1, 2, source), dx = 0, dy = 0, h = side.h, dw = 0;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x1, y1, x2, y2, source);
    let angle1 = calclineangle2(x12, y12, x22, y22, source);
    if (side1 != undefined) { x1 = side1.x2, y1 = side1.y2, x11 = side1.x12, y11 = side1.y12, x21 = side1.x22, y21 = side1.y22; }

    let npt = rotate_point1(x1, y1, -1, angle, w);
    x2 = npt.dx, y2 = npt.dy;

    let npt1 = rotate_point1(x11, y11, -1, angle, w1);
    x12 = npt1.dx, y12 = npt1.dy;

    let npt2 = rotate_point1(x21, y21, -1, angle, w2);
    x22 = npt2.dx, y22 = npt2.dy;
    if (index == 0) {
        let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, x11, y11);
        x21 = npt3.dx, y21 = npt3.dy;
    }
    else if (index == shape.sides.length - 1) {
        let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, x12, y12);
        x22 = npt3.dx, y22 = npt3.dy;
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2; side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12; side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22; side.y22 = y22;
}
function editshapeside3(index, code, changetype) {
    let source = 'oneditshapeside3';
    let side = shape.sides[index], side1 = shape.sides[index + 1], side2 = shape.sides[index - 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, h = side.h;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    if (changetype == 1) {
        let npt1 = offsetline(x11, y11, x12, y12, -h / 2);
        x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
        let npt2 = offsetline(x11, y11, x12, y12, -h);
        x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;
    } else {
        let npt1 = offsetline(x21, y21, x22, y22, h / 2);
        x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
        let npt2 = offsetline(x21, y21, x22, y22, h);
        x11 = npt2.dx1, y11 = npt2.dy1, x12 = npt2.dx2, y12 = npt2.dy2;
    }
    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side1.x1 = x2, side1.y1 = y2;
        }
        let ipt1 = calintersection1(x11, y11, x12, y12, side1.x11, side1.y11, side1.x12, side1.y12);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x12 = ipt1.dx, y12 = ipt1.dy;
            side1.x11 = x12, side1.y11 = y12;
        }
        let ipt2 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt2.dx != 0 && ipt2.dy != 0) {
            x22 = ipt2.dx, y22 = ipt2.dy;
            side1.x21 = x22, side1.y21 = y22;
        }
        //side1.w = applymminchfact(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2), 2, 2, source);
        //if (side1.w1 >= side1.w2) { side1.w2 = applymminchfact(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22), 2, 2, source); }
        //else { side1.w1 = applymminchfact(calchyplen(side1.x11, side1.y11, side1.x12, side1.y12), 2, 2, source); }
    }
    if (side2 != undefined) {
        let ipt3 = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt3.dx != 0 && ipt3.dy != 0) {
            x1 = ipt3.dx, y1 = ipt3.dy;
            side2.x2 = x1, side2.y2 = y1;
        }
        let ipt4 = calintersection1(x11, y11, x12, y12, side2.x11, side2.y11, side2.x12, side2.y12);
        if (ipt4.dx != 0 && ipt4.dy != 0) {
            x11 = ipt4.dx, y11 = ipt4.dy;
            side2.x12 = x11, side2.y12 = y11;
        }
        let ipt5 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt5.dx != 0 && ipt5.dy != 0) {
            x21 = ipt5.dx, y21 = ipt5.dy;
            side2.x22 = x21, side2.y22 = y21;
        }
        //side2.w = applymminchfact(calchyplen(side2.x1, side2.y1, side2.x2, side2.y2), 2, 2, source);
        //if (side2.w1 >= side2.w2) { side2.w2 = applymminchfact(calchyplen(side2.x21, side2.y21, side2.x22, side2.y22), 2, 2, source); }
        //else { side2.w1 = applymminchfact(calchyplen(side2.x11, side2.y11, side2.x12, side2.y12), 2, 2, source); }
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    //side.w = applymminchfact(calchyplen(x1, y1, x2, y2), 2, 2, source);
    //if (changetype == 1) {
    //    side.w2 = applymminchfact(calchyplen(x21, y21, x22, y22), 2, 2, source);        
    //} else {
    //    side.w1 = applymminchfact(calchyplen(x11, y11, x12, y12), 2, 2, source);
    //} 
}
function shapesideintrpoints(index) {
    let side = shape.sides[index];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    if (index > 0) { let side1 = shape.sides[index - 1]; x1 = side1.x2; y1 = side1.y2; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt.dx != 0 && ipt.dy != 0) { x2 = ipt.dx, y2 = ipt.dy; }
    }
    setsidecenterline(index, x1, y1, x2, y2);
}
function shapesideintrpoints1(index) {
    let side = shape.sides[index];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    if (index > 0) { let side1 = shape.sides[index - 1]; x11 = side1.x12; y11 = side1.y12; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x11, y11, x12, y12, side2.x11, side2.y11, side2.x12, side2.y12);
        if (ipt.dx != 0 && ipt.dy != 0) { x12 = ipt.dx, y12 = ipt.dy; }
    }
    setsideouterline1(index, x11, y11, x12, y12);
}
function shapesideintrpoints2(index) {
    let side = shape.sides[index];
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    if (index > 0) { let side1 = shape.sides[index - 1]; x21 = side1.x22; y21 = side1.y22; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt1 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) { x22 = ipt1.dx, y22 = ipt1.dy; }
    }
    setsideouterline2(index, x21, y21, x22, y22);
}
function shapesidepath32(sidepoints) {    
    let x1 = sidepoints[0].dx, y1 = sidepoints[0].dy;
    let spath = "M" + x1 + "," + y1;
    for (let i = 1; i < sidepoints.length; i++) {
        let x2 = sidepoints[i].dx, y2 = sidepoints[i].dy;
        spath += " l" + (x2 - x1) + "," + (y2 - y1);       
        x1 = x2, y1 = y2;
    }
    spath += "z";
    return spath;
}
function shapesides(source) {
    drawshapesides(shape.index, source + ':shapesides');
    drawshapeangles();
    if (shape.mode != 'slabpart') { drawshapelabels(); }    
}
function drawshapesides(index, source) {
    if (shape.sides != null) {
        for (let j = 0; j < shape.sides.length; j++) {  
            drawsidecorners(j, source + ":drawshapesides");            
            drawsideshapes(j);
            drawsidesplashs(j);
            drawsidecutouts(j);
            drawsideseams(j);
            drawshapeside32(j, source + ":drawshapesides");
            if (shape.partsrno != undefined) { drawshapesidetext(j); }
        }
    }
}
function drawshapesides32(source) {
    for (let j = 0; j < shape.sides.length; j++) {
        drawshapeside32(j, source + ":drawshapesides");
    }
}
function drawshapeside32(index, source) {
    let side = shape.sides[index];  
    //setshapesidesegs(index);
    let swh = calcfabsidebumpoutmeasures32(index, source);
    //console.log(swh.scw1, swh.scw2, swh.sch1, swh.sch2);
    if (index == 0) { drawshapesideseglines32(index, 0, swh, source); }
    drawshapesideseglines32(index, 1, swh, source);
    drawshapesideseglines32(index, 2, swh, source);
    if (index == shape.sides.length - 1 && !bdraw) { drawshapesideseglines32(index, 3, swh, source); }
   // if (shape.mode != 'slabpartdg') {
        let sidepoints = getshapesidepoints(index);
        let spath = shapesidepath32(sidepoints);
        drawshapesidepath32(index, spath);
   // }
}
function drawshapesideseglines32(index, sidecode, swh, source) {
    let side = shape.sides[index];
    setsidesegs(index, sidecode);
    let sidecodeseg = side.sidesegs[sidecode];    
    let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + sidecode;
    let sidecodeg = sidesg.select("#" + sidecodegindex);
    if (!sidecodeg.empty()) { sidecodeg.selectAll('*').remove(); } else { sidecodeg = sidesg.append("g").attr("id", sidecodegindex); }

    let x1 = 0, y1 = 0, x2 = 0, y2 = 0;
    let w = applymminchfact(side.w, 1, 2, source), w1 = roundToTwo(side.w1), w2 = roundToTwo(side.w2), h = applymminchfact1(side.h, 2, 2, 'drawsidemarkers'), stwidth = 15;
    if (w <= 16 || h <= 16) { stwidth = 5; }
    let edgetype = sideedgetype(index, sidecode);
    let sidesh = 26, sidesw = 0, isseg = false, mtext = '';
    let segw = sidecodeseg.segs[0].sw;
    let angle = calclineangle2(x1, y1, x2, y2, 'drawshapesideseglines32');
    if (sidecode == 0) { x1 = side.x11, y1 = side.y11, x2 = side.x21, y2 = side.y21, sidesw = h; sidesh += applymminchfact1(swh.scw1, 1, 2, ''); mtext = h + swh.sch1;  }
    else if (sidecode == 1) { x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12, sidesw = w1 ; sidesh +=  applymminchfact1(swh.sch1, 1, 2, ''); mtext = w1 + swh.scw1; }
    else if (sidecode == 2) { x1 = side.x21, y1 = side.y21, x2 = side.x22, y2 = side.y22, sidesw = w2; sidesh += applymminchfact1(swh.sch2, 1, 2, ''); mtext = w2 + swh.scw2; }
    else if (sidecode == 3) { x1 = side.x12, y1 = side.y12, x2 = side.x22, y2 = side.y22, sidesw = h; sidesh += applymminchfact1(swh.scw2, 1, 2, ''); mtext = h + swh.sch2; }
    if (sidecodeseg.segs.length > 1) { isseg = true; } else {
        if (sidecode == 0) {
            if (side.corners[0].type != 0 || side.corners[1].type != 0) { isseg = true;}
        } else if (sidecode==1) {
            if (index == shape.sides.length - 1) { if (side.corners[0].type != 0 || side.corners[2].type != 0) { isseg = true; } }
            else { if (side.corners[0].type != 0 || shape.sides[index + 1].corners[0].type != 0) { isseg = true; } }
        } else if (sidecode == 2) {
            if (index == shape.sides.length - 1) { if (side.corners[1].type != 0 || side.corners[3].type != 0) { isseg = true; } }
            else { if (side.corners[1].type != 0 || shape.sides[index + 1].corners[1].type != 0) { isseg = true; } }
        } else if (sidecode == 3) {
            if (side.corners[2].type != 0 || side.corners[3].type != 0) { isseg = true; }
        }
    }
   // console.log(JSON.stringify(sidecodeseg.segs));
    if (isseg) {
       // sidesh = 30;
        for (let i = 0; i < sidecodeseg.segs.length; i++) {
            let sx1 = sidecodeseg.segs[i].x1, sy1 = sidecodeseg.segs[i].y1, sx2 = sidecodeseg.segs[i].x2, sy2 = sidecodeseg.segs[i].y2, sw = sidecodeseg.segs[i].sw, sh = sidecodeseg.segs[i].sh, stypeid = sidecodeseg.segs[i].stypeid, dh = 10;
            drawsideline32(i, index, sidecode, sx1, sy1, sx2, sy2, edgetype, stwidth);
            if (stypeid == 4 || stypeid == 5 || stypeid == 6) {
               // if (sh > sidesh) { sidesh = sh + 15; }
                if (sw > 0) {                    
                    let sgdh = 15;
                    if (sidecode == 0 || sidecode == 2) { sgdh = -sgdh; }
                    let npt = offsetline(sx1, sy1, sx2, sy2, sgdh);
                    let mtx = Math.round((npt.dx1 + npt.dx2) / 2), mty = Math.round((npt.dy1 + npt.dy2) / 2);
                    drawsidemarkertext32(i, index, sidecode, mtx, mty, sw, angle, false);
                }
            }
        }
    } else {
        drawsideline32(sidecodeseg.segs.length + 1, index, sidecode, x1, y1, x2, y2, edgetype, stwidth);
    }
   // if (sidecode == 1) { console.log(index, sidecode, sidecodeseg.segs.length, isseg, segw, w1, w2, h, sidesh, swh.scw1, swh.scw2, swh.sch1, applymminchfact1(swh.sch1, 1, 2, ''), swh.sch2, source); }
    
   
    drawsidemeasureline32(sidecodeseg.segs.length + 1, index, sidecode, x1, y1, x2, y2, sidesw, sidesh, sidesw, angle, true);

    if (index > 0 && (index < shape.sides.length - 1)) {//ushape and above  shapes center measure lines
        sidecode = 4;
        let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + sidecode;
        let sidecodeg = sidesg.select("#" + sidecodegindex);
        if (!sidecodeg.empty()) { sidecodeg.selectAll('*').remove(); } else { sidecodeg = sidesg.append("g").attr("id", sidecodegindex); }

        x1 = (side.x11 + side.x12) / 2, y1 = (side.y11 + side.y12) / 2, x2 = (side.x21 + side.x22) / 2, y2 = (side.y21 + side.y22) / 2;
        let mtx = Math.round((x1 + x2) / 2), mty = Math.round((y1 + y2) / 2);
       // console.log(index, sidecode, mtx, mty, h, angle, editmode);
        if (editmode == 1) {
            drawsideinputmarker32(index, sidecode, mtx, mty, h, angle);
        } else {
            drawsidemarkertext32(sidecodeseg.segs.length + 2, index, sidecode, mtx, mty, h, angle, true);
        }       
        //drawsidemeasureline32(sidecodeseg.segs.length + 2, index, sidecode, x1, y1, x2, y2, h, 0, angle, true);
    }
}
function drawsidemeasureline32(lnindex, index, sidecode, x1, y1, x2, y2, sw, dh, mtext, angle, isedit) {
    // console.log(lnindex, index, sidecode, x1, y1, x2, y2, sw, dh, angle, isseg, editmode);
    if (shape.mode == 'slabpart' || shape.mode == 'slabpartdg') { return; }
    if (dh != 0) {
        if (sidecode == 0 || sidecode == 2) { dh = -dh; }
        let npt = offsetline(x1, y1, x2, y2, dh);
        x1 = npt.dx1, y1 = npt.dy1, x2 = npt.dx2, y2 = npt.dy2;
    }    
    let mtx = Math.round((x1 + x2) / 2), mty = Math.round((y1 + y2) / 2); 
    drawsidemarkerline32(lnindex, index, sidecode, x1, y1, x2, y2);
    if (editmode == 1 && isedit == true) {
        drawsideinputmarker32(index, sidecode, mtx, mty, sw, angle);
    } else {
        drawsidemarkertext32(lnindex, index, sidecode, mtx, mty, mtext, angle, isedit);
    }   
}
function drawshapesidepath32(index, spath) {   
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, materialid = shape.materialid, spindex = shape.spindex, spsideindex = shape.spsideindex;
    //console.log(index, sindex, smode, partsrno, areaid, spindex);    
    let sidepathindex = areaid + "" + sindex + "" + index;
    let sidepathg = shapepathg.select("#" + smode + "sidepath" + sidepathindex);
    if (sidepathg.empty()) { sidepathg = shapepathg.append("path").attr("id", smode + "sidepath" + sidepathindex); }
    sidepathg.attr("index", index).attr("spsideindex", spsideindex).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid)
    .attr("materialid", materialid).attr("smode", smode).attr("d", spath).on("click", onshape).on("contextmenu", onshapecontextmenu).on("dblclick", ondblshape);
    sidepathg.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
}
function drawsideline32(lnindex, index, code, x1, y1, x2, y2, edgetype, stwidth) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;  
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let eclass = sideedgeclass(edgetype);
    let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + code;
    let sidecodeg = sidesg.select("#" + sidecodegindex);
    let sidelineindex = sindex + "" + index + "" + code + "" + lnindex;
    if (!sidecodeg.empty()) {
        let sideline = sidecodeg.select("#side" + sidelineindex);
        if (sideline.empty()) { sideline = sidecodeg.append("line").attr("id", "side" + sidelineindex); }
        sideline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("code", code).attr("edgetype", edgetype)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        if (etypes[1] != undefined) { sideline.attr("style", "stroke:" + etypes[1]); }
        if (shape.mode == 'shape') {
            // sideline.on("click", onshapeside).on("mouseover", showshapeside).on("mouseout", hideshapeside);
            let shapebandline = sidecodeg.select("#sideband" + sidelineindex);
            if (shapebandline.empty()) { shapebandline = sidecodeg.append("line").attr("id", "sideband" + sidelineindex).on("click", onshapeside); }
            shapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("code", code).attr("edgetype", edgetype).attr("stwidth", stwidth)
                .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
            shapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth)
                .on("mouseover", showshapeside).on("mouseout", hideshapeside);
        }
    }
}
function drawsidemarkerline32(lnindex, index, code, x1, y1, x2, y2) {
    if (shape.mode == 'slabpart' || shape.mode == 'slabpartdg') { return; }
    let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + code;
    let mindex = shape.index + "" + index + "" + code + "" + lnindex;
    let sidecodeg = sidesg.select("#" + sidecodegindex); 
    if (sidecodeg.empty()) { sidecodeg = sidesg.append("g").attr("id", sidecodegindex); }
    let markerline = sidecodeg.select("#mline" + mindex);
    if (markerline.empty()) { markerline = sidecodeg.append("line").attr("id", "mline" + mindex); }
    let arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    let arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("class", "sidearrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
}
function drawsidemarkertext32(lnindex, index, code, mtx, mty, mtext, angle, isedit) {
    if (shape.mode == 'slabpart' || shape.mode == 'slabpartdg') { return; }
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etype = sideedgetext(index, code);
    let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + code;
    let mindex = sindex + "" + index + "" + code + "" + lnindex;
    if (scale == 4) { mtext = decimaltofraction(mtext) + "" + '"'; }    
    let sidecodeg = sidesg.select("#" + sidecodegindex);
    if (!sidecodeg.empty()) {
        let markertext = sidecodeg.select("#mtext" + mindex);
        if (!markertext.empty()) { markertext.remove(); }
        markertext = sidecodeg.append("text").attr("id", "mtext" + mindex);
        markertext.attr("x", mtx).attr("y", mty).attr("lnindex", lnindex).attr("index", index).attr("code", code).attr("sindex", sindex).attr("spindex", spindex)
            .attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        let mtextspan = markertext.attr("x", mtx).attr("y", mty).append("tspan").attr("id", "mtextspan1" + mindex).attr("text-anchor", "middle").attr("alignment-baseline", "middle");
        if (etype.length > 0) { markertext.append("tspan").attr("id", "mtextspan2" + mindex).style("fill", "goldenrod").text(" | " + etype); }
        if (smode == 'shape' && isedit == true) { mtextspan.style("fill", "black").text(mtext); markertext.on("click", onsidemarkertext); }
        else { mtextspan.style("fill", "grey").text(mtext); }
        let angle1 = shape.angle;
       // console.log(index, code, mtx, mty, mtext, angle, angle1);
        markertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
    }
}
function drawsideinputmarker32(index, code, mtx, mty, mtext, angle) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let sidecodegindex = shape.mode + "sidecodeg" + shape.index + index + "" + code;
    let mindex = sindex + "" + index + "" + code;
    let sidecodeg = sidesg.select("#" + sidecodegindex);
    if (!sidecodeg.empty()) {
        let markertext = sidecodeg.select("#mfotext" + mindex);
        if (markertext.empty()) { markertext = sidecodeg.append("foreignObject").attr("id", "mfotext" + mindex); }
        markertext.attr("x", mtx).attr("y", mty).attr("width", "60").attr("height", "30");
        let markerinputtext = markertext.select("#mitext" + mindex);
        if (markerinputtext.empty()) { markerinputtext = markertext.append('xhtml:input').attr("id", "mitext" + mindex); }
        markerinputtext.attr("style", "padding-left:5px;width:60px;height:20px;").attr("type", "text").property("value", mtext).attr("index", index).attr("code", code).attr("prevval", mtext)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("text-anchor", "middle")
            .on("change", oneditshapeside).on("keydown", oneditsidekeydown).on("click", onsideinputcontrol);
        let angle1 = shape.angle;
       // console.log(index, code, mtx, mty, mtext, angle, angle1);
        markertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
    }
}
function drawshapeendside() {
    let source = 'drawshapeendside';
    if (shape.sides.length > 0) {
        let index = shape.sides.length - 1;
        //let side = shape.sides[index];
        //let x12 = side.x12, y12 = side.y12, x22 = side.x22, y22 = side.y22, lncode = 3;
        //let w = applymminchfact(side.w, 1, 2, source), h = applymminchfact1(side.h, 2, 2, source), stwidth = 15;
        //if (w <= 16 || h <= 16) { stwidth = 5; }
        //let etype = sideedgetype(index, 3);
        drawshapeside32(index, source);
       // drawsideline(index, lncode, side.x12, side.y12, side.x22, side.y22, etype, stwidth);
    }
    removedrawhandles();
}
function drawsideline(index, code, x1, y1, x2, y2, edgetype, stwidth) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let etypes = [];
    if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let eclass = sideedgeclass(edgetype);
    let sidegindex = smode + "sideg" + sindex + index;
    let sidelineindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (!sideg.empty()) {
        let sideline = sideg.select("#side" + sidelineindex);
        if (sideline.empty()) { sideline = sideg.append("line").attr("id", "side" + sidelineindex); }
        sideline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("code", code).attr("edgetype", edgetype)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("style", "stroke:" + etypes[1]);
        if (shape.mode == 'shape') {
            // sideline.on("click", onshapeside).on("mouseover", showshapeside).on("mouseout", hideshapeside);
            let shapebandline = sideg.select("#sideband" + sidelineindex);
            if (shapebandline.empty()) { shapebandline = sideg.append("line").attr("id", "sideband" + sidelineindex).on("click", onshapeside); }
            shapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("code", code).attr("edgetype", edgetype).attr("stwidth", stwidth)
                .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
            shapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth)
                .on("mouseover", showshapeside).on("mouseout", hideshapeside);
        }
    }
}
function ondblshape() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    return;
    // console.log('ondblshape');
}
function onsidemarkertext() {
    if (bdraw) { onendshapedraw(); }
    if (editmode == 1) { editmode = 0; drawshapesides(shape.index, 'onsidemarkertext-1'); } //check drawshapesides() called twice??
    let lnindex = parseInt(this.getAttribute("lnindex"));
    let index = parseInt(this.getAttribute("index"));
    let code = this.getAttribute("code");
    let type = this.getAttribute("stype");
    let mode = this.getAttribute("smode");
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    setdrawshape31(sindex, partsrno, areaid, mode, 'onsidemarkertext');
    editmode = 1;
    drawshapesides(sindex, 'onsidemarkertext-2');
    selectsideinputcontrol(sindex, index, code, 'onsidemarkertext');
}
function oneditsidekeydown() {
    let keycode = d3.event.keyCode;
    let inputctl;
    if (keycode == 9) {
        d3.event.preventDefault();        
        let index = parseInt(this.getAttribute("index"));
        let code = parseInt(this.getAttribute("code"));
        let sindex = parseInt(this.getAttribute("sindex"));
        selectnextsideinputcontrol(sindex, index, code, 'oneditsidekeydown');
    }
    if (bdraw) { onendshapedraw(); }
}
function onsideinputcontrol() {    
    let index = parseInt(this.getAttribute("index"));
    let code = parseInt(this.getAttribute("code"));
    let sindex = parseInt(this.getAttribute("sindex"));
    selectsideinputcontrol(sindex, index, code , 'onsideinputcontrol');
    if (bdraw) { onendshapedraw(); }
}
function selectnextsideinputcontrol(sindex, index, code, source) {    
    var index1 = 0, code1 = 0;
    if (code == 0) {
        index1 = index, code1 = 1;
    } else if (code == 1) {
        if (index < shape.sides.length - 1) {
            if ((index) > 0 && (index < shape.sides.length - 1)) {
                index1 = index, code1 = 4;
            } else {
                index1 = index + 1, code1 = code;
            }
        } else if (index == shape.sides.length - 1) { index1 = index, code1 = 3; }
    } else if (code == 2) {
        if (index > 0) {
            index1 = index - 1, code1 = code;
        } else if (index == 0) {
            index1 = index, code1 = 0;
        }
    } else if (code == 3) {
        index1 = index, code1 = 2;
    } else if (code == 4) {
        index1 = index + 1, code1 = 1;
    }
    selectsideinputcontrol(sindex, index1, code1, source);
}
function selectsideinputcontrol(sindex, index, code, source) {    
    let mindex = sindex + "" + index + "" + code;
    inputctl = $("#mitext" + mindex);  
    if (inputctl != undefined) {
        inputctl.focus();
        inputctl.select();
    }
}
function showshapeside() {
    if (drawmode == 3 || drawmode == 4 || drawmode == 5 || drawmode == 8) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
        d3.select(this).attr("class", "shapesideblue");
    } else if (drawmode == 1) {

    }
}
function hideshapeside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));
    if (drawmode == 3 || drawmode == 4 || drawmode == 5 || drawmode == 8) {//splash/edge mode
        let edgetype = this.getAttribute("edgetype");
        let scolor = d3.select(this).attr('scolor');
        d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
        d3.select(this).attr("class", sideedgeclass(edgetype));
    }
}
function removeshapesclipimages() {
    for (let i = 0; i < shapes.length; i++) {
        removeshapeclipimages(i);
    }
}
function setshapesopacity(fillopacity) {
    for (let i = 0; i < shapes.length; i++) {
        setshapepathopacity(i, fillopacity);
    }
}
function removeshapeclipimages(sindex) {
    let shapeslabimagesg = d3.select("#shapeslabimgsg" + sindex);
    if (!shapeslabimagesg.empty()) { shapeslabimagesg.selectAll('*').remove(); }
}
function setshapepathopacity(sindex, fillopacity) {
    if (shapes[sindex] != undefined) {
        for (let i = 0; i < shapes[sindex].sides.length; i++) {
            let sidepathindex = i + "" + sindex;
            let shapesidepath = d3.select("#shape" + "sidepath" + sidepathindex);
            if (!shapesidepath.empty()) { shapesidepath.style("fill-opacity", fillopacity); }
        }
    }
}