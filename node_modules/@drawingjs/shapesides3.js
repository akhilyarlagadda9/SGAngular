function initshapeside(index) {
    var side = {
        index: index, sindex: shape.index, angle: 0, atype: 1, asign: 1, dsign: 1, h: shape.h, w: 0, w1: 0, w2: 0, x1: 0, y1: 0, x2: 0, y2: 0, stype: '', stypeid: 0, note: '',
        x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, cline: 0, edges: [], corners: [], sideshapes: [], cutouts: [], seams: [], splashs: []
    };
    shape.sides.push(side);
    initsideedges(index);
    initsidecorners(index);
}
function initsideedges(index) {
    var side = shape.sides[index];
    if (index == 0) { side.edges.push(initsideedge(side.edges.length, index, 0, 'F', 0, 'F')); }
    side.edges.push(initsideedge(side.edges.length, index, 1, 'F', 0, 'F'));
    side.edges.push(initsideedge(side.edges.length, index, 2, 'F', 0, 'F'));
}
function initendsideedge() {
    var index = shape.sides.length - 1;
    var side = shape.sides[index];
    if (side != undefined) { side.edges.push(initsideedge(side.edges.length, index, 3, 'F', 0, 'F')); }
}
function initsideedge(index, sideindex, code, type, typeid, text) {
    var edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function setnewshapeside(x2, y2) {
    let dh = shape.h / 2;
    let x1 = 0, y1 = 0;
    let index = shape.opoints.length - 1;
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x1 = shape.opoints[index][0], y1 = shape.opoints[index][1];   
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
    let npt2 = offsetline(x1, y1, x2, y2, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;
    setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22);
    for (var j = 0; j < shape.sides.length; j++) {
        shapesideintrpoints(j);
        shapesideintrpoints1(j);
        shapesideintrpoints2(j);
    }
}
function setshapesidelines(index, x1, y1, x2, y2, x11, y11, x12, y12, x21, y21, x22, y22) {
    if (index > shape.sides.length - 1) { initshapeside(index); }
    setsidecenterline(index, x1, y1, x2, y2);
    setsideouterline1(index, x11, y11, x12, y12);
    setsideouterline2(index, x21, y21, x22, y22);
}
function setsidecenterline(index, x1, y1, x2, y2) {
    var side = shape.sides[index];
    side.x1 = Math.round(x1), side.y1 = Math.round(y1), side.x2 = Math.round(x2), side.y2 = Math.round(y2);
    if (x1 == x2) { side.w = Math.abs(y1 - y2) / scale; } else if (y1 == y2) { side.w = Math.abs(x1 - x2) / scale; }
    else { side.w = calchyplen(x1, y1, x2, y2) / scale; }
}
function setsideouterline1(index, x11, y11, x12, y12) {
    var side = shape.sides[index];
    side.x11 = Math.round(x11), side.y11 = Math.round(y11), side.x12 = Math.round(x12), side.y12 = Math.round(y12);
    if (x11 == x12) { side.w1 = Math.abs(y11 - y12) / scale; } else if (y11 == y12) { side.w1 = Math.abs(x11 - x12) / scale; }
    else { side.w1 = calchyplen(x11, y11, x12, y12) / scale; }
}
function setsideouterline2(index, x21, y21, x22, y22) {
    var side = shape.sides[index];
    side.x21 = Math.round(x21), side.y21 = Math.round(y21), side.x22 = Math.round(x22), side.y22 = Math.round(y22);
    if (x21 == x22) { side.w2 = Math.abs(y21 - y22) / scale; } else if (y21 == y22) { side.w2 = Math.abs(x21 - x22) / scale; }
    else { side.w2 = calchyplen(x21, y21, x22, y22) / scale; }
}
function onshapeside() {
    //removeshapetools();
    d3.event.stopPropagation();
    var mode = this.getAttribute("smode");
    if (mode == 'shape') {
        var index = parseInt(this.getAttribute("index"));
        var sindex = parseInt(this.getAttribute("sindex"));
        var code = parseInt(this.getAttribute("code"));
        var m = d3.mouse(this);
        if (editmode == 1) { editmode = 0; drawshapesides(sindex, 'onshapeside'); }
        initshapegroups(sindex, mode, 'onshapeside');       
        if (drawmode == 3) {
            onsetsideshape(m[0], m[1], -1, index, code);
        } else if (drawmode == 4) {
            onsetsidesplash(index, code, edgetype, edgetypeid, 1);
        } else if (drawmode == 5) {
            onsetsideedge(index, code, edgetype, edgetypeid, 0);
        }
    }
}
function oneditshapeside() {
    var objVal = $(this).val().split(" ");    
    var neww = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));   
    if (isNaN(neww)) { return; }   
    var index = parseInt(this.getAttribute("index"));
    var code = parseInt(this.getAttribute("code"));    
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    initshapegroups(sindex, mode, 'oneditshapeside');
    drawlogservice.beforeupdate(shape, 'oneditshapeside', 3);
    var side = shape.sides[index];
    var w = side.w, w1 = side.w1, w2 = side.w2, h = side.h, dw = 0, dh = 0, asign = side.asign, dsign = side.dsign;
    //neww = neww * scale;   
    if (code == 0) {
        side.h = neww * scale;
        resetsideonsizechange1(index, code);
    } else if (code == 1 || code == 2) {
        if (code == 1) { dw = neww - w1; } else if (code == 2) { dw = neww - w2; }
        dw = dw * scale;
        if (index == 0) { resetsideonsizechange2(index, code, dw); } else { resetsideonsizechange3(index, code, dw); }
        for (var j = index + 1; j < shape.sides.length; j++) {
            resetsideonsizechange4(j);
        }
    } else if (code == 3) {
        side.h = neww * scale;
        resetsideonsizechange5(index, code);
    } else if (code == 4) {
        side.h = neww * scale;
        resetsideonsizechange6(index, code);
    }    
    shapesides('oneditshapeside');
    ActionShapeReSize();
    selectnextsideinputcontrol(sindex, index, code);
    drawlogservice.update(shape, 'oneditshapeside', 3);
    if (layoutmode > 0) { onsetslabpart(0, 0, 'oneditshapeside'); }    
}
function resetsideonsizechange1(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side.x2 = x2, side.y2 = y2; side1.x1 = x2, side1.y1 = y2;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x22 = ipt1.dx, y22 = ipt1.dy;
            side.x22 = x22, side.y22 = y22, side1.x21 = x22, side1.y21 = y22;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function resetsideonsizechange2(index, code, dw) {
    let side = shape.sides[index];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x2, y2, x1, y1, 'resetsideonsizechange2');
    let nw = w + dw, nw1 = w1 + dw, nw2 = w2 + dw;

    let npt = rotate_point1(x2, y2, -1, angle, nw);
    x1 = npt.dx, y1 = npt.dy;
    side.x1 = x1; side.y1 = y1;

    let npt1 = rotate_point1(x12, y12, -1, angle, nw1);
    x11 = npt1.dx, y11 = npt1.dy;
    side.x11 = x11; side.y11 = y11;

    let npt2 = rotate_point1(x22, y22, -1, angle, nw2);
    x21 = npt2.dx, y21 = npt2.dy;
    side.x21 = x21; side.y21 = y21;

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;

}
function resetsideonsizechange3(index, code, dw) {
    let side = shape.sides[index];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x1, y1, x2, y2, 'resetsideonsizechange3');
    let nw = w + dw, nw1 = w1 + dw, nw2 = w2 + dw;
   // console.log(index, code, dw, nw, nw1, nw2);
    let npt = rotate_point1(x1, y1, -1, angle, nw);
    x2 = npt.dx, y2 = npt.dy;
    side.x2 = x2; side.y2 = y2;

    let npt1 = rotate_point1(x11, y11, -1, angle, nw1);
    x12 = npt1.dx, y12 = npt1.dy;
    side.x12 = x12; side.y12 = y12;

    let npt2 = rotate_point1(x21, y21, -1, angle, nw2);
    x22 = npt2.dx, y22 = npt2.dy;
    side.x22 = x22; side.y22 = y22;

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;

}
function resetsideonsizechange4(index) {
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h / 2;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let angle = calclineangle2(x1, y1, x2, y2, 'resetsideonsizechange2');
    x1 = side1.x2, y1 = side1.y2, x11 = side1.x12, y11 = side1.y12, x21 = side1.x22, y21 = side1.y22;

    let npt = rotate_point1(x1, y1, -1, angle, w);
    x2 = npt.dx, y2 = npt.dy;
    side.x1 = x1, side.y1 = y1, side.x2 = x2; side.y2 = y2;

    let npt1 = rotate_point1(x11, y11, -1, angle, w1);
    x12 = npt1.dx, y12 = npt1.dy;
    side.x11 = x11, side.y11 = y11, side.x12 = x12; side.y12 = y12;

    let npt2 = rotate_point1(x21, y21, -1, angle, w2);
    x22 = npt2.dx, y22 = npt2.dy;
    side.x21 = x21, side.y21 = y21, side.x22 = x22; side.y22 = y22;

    let nw = roundToTwo(calchyplen(x1, y1, x2, y2));
    let nw1 = roundToTwo(calchyplen(x11, y11, x12, y12));
    let nw2 = roundToTwo(calchyplen(x21, y21, x22, y22));

    side.w = nw / scale, side.w1 = nw1 / scale, side.w2 = nw2 / scale;
}
function resetsideonsizechange5(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side.x1 = x1, side.y1 = y1; side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side.x21 = x21, side.y21 = y21, side1.x22 = x21, side1.y22 = y21;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function resetsideonsizechange6(index, code) {
    let side = shape.sides[index], side1 = shape.sides[index - 1], side2 = shape.sides[index + 1];
    let w = side.w * scale, w1 = side.w1 * scale, w2 = side.w2 * scale, dx = 0, dy = 0, dh = side.h;
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;

    let npt1 = offsetline(x11, y11, x12, y12, -dh / 2);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;

    let npt2 = offsetline(x11, y11, x12, y12, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side1.x1, side1.y1, side1.x2, side1.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x1 = ipt.dx, y1 = ipt.dy;
            side.x1 = x1, side.y1 = y1; side1.x2 = x1, side1.y2 = y1;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side.x21 = x21, side.y21 = y21, side1.x22 = x21, side1.y22 = y21;
        }
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
    if (side2 != undefined) {
        let ipt = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x2 = ipt.dx, y2 = ipt.dy;
            side.x2 = x2, side.y2 = y2; side2.x1 = x2, side2.y1 = y2;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) {
            x22 = ipt1.dx, y22 = ipt1.dy;
            side.x22 = x22, side.y22 = y22, side2.x21 = x22, side2.y21 = y22;
        }
        side2.w = roundToTwo(calchyplen(side2.x1, side2.y1, side2.x2, side2.y2) / scale);
        side2.w2 = roundToTwo(calchyplen(side2.x21, side2.y21, side2.x22, side2.y22) / scale);
    }
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22;
    side.w = roundToTwo(calchyplen(side.x1, side.y1, side.x2, side.y2) / scale);
    side.w2 = roundToTwo(calchyplen(side.x21, side.y21, side.x22, side.y22) / scale);
}
function shapesides(action) {
    if (!bdraw) { drawshapecorners(shape.index, 'shapesides'); }   
    drawshapesides(shape.index, 'shapesides');
    drawshapeangles();
}
function shapesideintrpoints(index) {
    let side = shape.sides[index];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    if (index > 0) { let side1 = shape.sides[index - 1]; x1 = side1.x2; y1 = side1.y2; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x1, y1, x2, y2, side2.x1, side2.y1, side2.x2, side2.y2);
        if (ipt.dx != 0 && ipt.dy != 0) { x2 = ipt.dx, y2 = ipt.dy; }
    }
    setsidecenterline(index, x1, y1, x2, y2);
}
function shapesideintrpoints1(index) {
    let side = shape.sides[index];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    if (index > 0) { let side1 = shape.sides[index - 1]; x11 = side1.x12; y11 = side1.y12; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt = calintersection1(x11, y11, x12, y12, side2.x11, side2.y11, side2.x12, side2.y12);
        if (ipt.dx != 0 && ipt.dy != 0) { x12 = ipt.dx, y12 = ipt.dy; }
    }
    setsideouterline1(index, x11, y11, x12, y12);
}
function shapesideintrpoints2(index) {
    let side = shape.sides[index];
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    if (index > 0) { let side1 = shape.sides[index - 1]; x21 = side1.x22; y21 = side1.y22; }
    if (index < shape.sides.length - 1) {
        let side2 = shape.sides[index + 1];
        let ipt1 = calintersection1(x21, y21, x22, y22, side2.x21, side2.y21, side2.x22, side2.y22);
        if (ipt1.dx != 0 && ipt1.dy != 0) { x22 = ipt1.dx, y22 = ipt1.dy; }
    }
    setsideouterline2(index, x21, y21, x22, y22);
}

function drawshapesides(index, source) {
    if (shape.sides != null) {
        for (let j = 0; j < shape.sides.length; j++) {
            drawshapeside(j);
            drawsidemarkers(j);
            drawsidesplashs(j);
            drawsideshapes(j);
            drawsidecutouts(j);
            drawsideseams(j);
            if (shape.partsrno != undefined) { drawshapesidetext(j);}
        }
    }
}
function drawshapesidestext() {
    if (shape.sides != null) {
        for (let j = 0; j < shape.sides.length; j++) {
            drawshapesidetext(j);
        }
    }
}
function drawshapeside(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let w = side.w * scale, h = side.h / scale, stwidth = 15, w1 = side.w1, w2 = side.w2;
        let lncode1 = 1, lncode2 = 2;
        let edge1type = sideedgetype(index, lncode1), edge2type = sideedgetype(index, lncode2);
        let sidegindex = shape.mode + "sideg" + shape.index + index;
        let sideg = sidesg.select("#" + sidegindex);
        if (!sideg.empty()) { sideg.selectAll('*').remove(); } else { sideg = sidesg.append("g").attr("id", sidegindex); }      
        if (index == 0) { drawshapestartside(); }        
        if (w <= 16 || h <= 16) { stwidth = 5; }
        drawsideline(index, lncode1, x11, y11, x12, y12, edge1type, stwidth);
        drawsideline(index, lncode2, x21, y21, x22, y22, edge2type, stwidth);
        if (index == shape.sides.length - 1 && !bdraw) { drawshapeendside(); }        
        drawshapesidepath(index, x11, y11, x12, y12, x21, y21, x22, y22);
    }
}
function drawshapeside1(index) {
    var side = shape.sides[index];
    if (side != undefined) {
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, lncode1 = 1;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        var etype = sideedgetype(index, 1);
        drawsideline(index, lncode1, x11, y11, x12, y12, etype, stwidth);
    }
}
function drawshapeside2(index) {
    var side = shape.sides[index];
    if (side != undefined) {
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, lncode2 = 2;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        var etype = sideedgetype(index, 2);
        drawsideline(index, lncode2, x21, y21, x22, y22, etype, stwidth);
    }
}
function drawshapestartside() {
    if (shape.sides.length > 0) {
        let index = 0;
        let side = shape.sides[index];
        let x11 = side.x11, y11 = side.y11, x21 = side.x21, y21 = side.y21, lncode = 0;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        let etype = sideedgetype(index, 0);
        drawsideline(index, lncode, x11, y11, x21, y21, etype, stwidth);
    }
    removedrawhandles();
}
function drawshapeendside() {
    if (shape.sides.length > 0) {
        let index = shape.sides.length - 1;
        let side = shape.sides[index];
        let x12 = side.x12, y12 = side.y12, x22 = side.x22, y22 = side.y22, lncode = 3;
        let w = side.w * scale, h = side.h / scale, stwidth = 15;
        if (w <= 16 || h <= 16) { stwidth = 5; }
        let etype = sideedgetype(index, 3);
        drawsideline(index, lncode, side.x12, side.y12, side.x22, side.y22, etype, stwidth);
        drawendsidecorners();
    }
    removedrawhandles();
}
function drawshapesidepath(index, x11, y11, x12, y12, x21, y21, x22, y22) {
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sclass = 'shapepath', sindex = shape.index, smode = shape.mode;
    let sidepathindex = index + "" + sindex;
    let sidetext = 'P' + (shape.partsrno);
    let shapesidepath = shapepathg.select("#" + smode + "sidepath" + sidepathindex);
    if (shapesidepath.empty()) { shapesidepath = shapepathg.append("path").attr("id", smode + "sidepath" + sidepathindex); }
    shapesidepath.attr("index", index).attr("sindex", sindex).attr("smode", smode).attr("d", spath).on("click", onshape).on("contextmenu", onshapecontextmenu).on("dblclick", ondblshape);
    shapesidepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (shape.mode == 'shape') { shapesidepath.on("mouseover", onshapemouseover).on("mouseout", onshapemouseout); }   
}

function redrawshapessidestext(index) {
    for (let i = index + 1; i < shapes.length; i++) {
        shape = shapes[i];
        if (shape.isactive == 1) {
            initshapegroups(shape.index, 'shape', 'initshape');
            drawshapesidestext(i);
        }
    }
}
function drawshapesidetext(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, w1 = side.w1;
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w2 = side.w2;
        let npt = calcenterpoint(x11, y11, x12, y12, x21, y21, x22, y22, w1, w2);
        let sptx = npt.dx, spty = npt.dy;
        let sidepathindex = index + "" + shape.index;
        let sidetext = 'P' + (shape.partsrno);
        let sidepathtext = shapepathg.select("#sidepathtext" + sidepathindex);
        if (!sidepathtext.empty()) { sidepathtext.remove(); }
        sidepathtext = shapepathg.append("text").attr("id", "sidepathtext" + sidepathindex);
        sidepathtext.attr("x", sptx).attr("y", spty).append("tspan").attr("id", "sidepathtext" + sidepathindex).style("fill", "black").text(sidetext);
    }
}
function ondblshape() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    return;
   // console.log('ondblshape');
}
function drawsideline(index, code, x1, y1, x2, y2, edgetype, stwidth) {   
    let eclass = sideedgeclass(edgetype);
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let sidelineindex = index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (!sideg.empty()) {
        let sideline = sideg.select("#side" + sidelineindex);
        if (sideline.empty()) { sideline = sideg.append("line").attr("id", "side" + sidelineindex); }
        sideline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("code", code).attr("edgetype", edgetype).attr("sindex", shape.index).attr("smode", shape.mode);
        if (shape.mode == 'shape') {
            // sideline.on("click", onshapeside).on("mouseover", showshapeside).on("mouseout", hideshapeside);
            let shapebandline = sideg.select("#sideband" + sidelineindex);
            if (shapebandline.empty()) { shapebandline = sideg.append("line").attr("id", "sideband" + sidelineindex).on("click", onshapeside); }
            shapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("code", code).attr("edgetype", edgetype).attr("sindex", shape.index).attr("smode", shape.mode).attr("stwidth", stwidth);
            shapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth).on("mouseover", showshapeside).on("mouseout", hideshapeside);
        }
    }
}
function drawsidemarkers(index) {
    let side = shape.sides[index];
    if (side != undefined) {
        let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, dh = 10;
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
        let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let mtx = 0, mty = 0, mtx1 = 0, mty1 = 0, mtx2 = 0, mty2 = 0, mtext = side.w, mtext1 = side.w1, mtext2 = side.w2, h = side.h / scale;
        let lncode = 0, lncode1 = 1, lncode2 = 2, dsign = 1;

        let angle = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
        let npt1 = offsetline(x11, y11, x12, y12, dh);
        x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
        let npt2 = offsetline(x21, y21, x22, y22, -dh);
        x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;
        
        mtx1 = (x11 + x12) / 2, mty1 = (y11 + y12) / 2;
        mtx2 = (x21 + x22) / 2, mty2 = (y21 + y22) / 2;
        
        if (shape.mode != 'slabpart') {
            if (index == 0) { drawsidestartendmarker(index, 0, x11, y11, x21, y21, h); }
            drawsidemarkerline(index, lncode1, x11, y11, x12, y12);
            drawsidemarkerline(index, lncode2, x21, y21, x22, y22);
            if (editmode == 1) {
                drawsideinputmarker(index, lncode1, mtx1, mty1, rounddecimal(mtext1));
                drawsideinputmarker(index, lncode2, mtx2, mty2, rounddecimal(mtext2));
            } else {
                drawsidemarkertext(index, lncode1, mtx1, mty1, decimaltofraction(mtext1), angle);
                drawsidemarkertext(index, lncode2, mtx2, mty2, decimaltofraction(mtext2), angle);
            }
            if (index == shape.sides.length - 1) { drawsidestartendmarker(index, 3, x12, y12, x22, y22, h); }
            if ((index) > 0 && (index < shape.sides.length - 1)) {                
               drawsidecentermarker(index, '4', x11, y11, x12, y12, x21, y21, x22, y22, h);
            }
        }
    }
}
function drawsidestartendmarker(index, lncode, x1, y1, x2, y2, mtext) {
    let mtx = 0, mty = 0, mtx1 = 0, mty1 = 0, mtx2 = 0, mty2 = 0, dh = 10;   
    if (lncode == 0) { dh = -dh;}
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x1 = npt1.dx1, y1 = npt1.dy1, x2 = npt1.dx2, y2 = npt1.dy2;
    let angle = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
    mtx1 = (x1 + x2) / 2, mty1 = (y1 + y2) / 2;

    drawsidemarkerline(index, lncode, x1, y1, x2, y2);
    if (editmode == 1) {
        drawsideinputmarker(index, lncode, mtx1, mty1, rounddecimal(mtext));
    } else {
        drawsidemarkertext(index, lncode, mtx1, mty1, decimaltofraction(mtext), angle);
    }
}
function drawsidecentermarker(index, lncode, x11, y11, x12, y12, x21, y21, x22, y22, mtext) {
    let side = shape.sides[index], w1 = side.w1 * scale, w2 = side.w2 * scale;
    let mx1 = 0, my1 = 0, mx2 = 0, my2 = 0, mtx = 0, mty = 0;

    let angle = calclineangle2(x11, y11, x12, y12, 'calcshapeangle');    
    let npt1 = rotate_point1(x11, y11, -1, angle, w1/2); //first point on side
    mx1 = npt1.dx, my1 = npt1.dy;
    let npt2 = rotate_point1(x21, y21, -1, angle, w2/2); //first point on side
    mx2 = npt2.dx, my2 = npt2.dy;

    let npt3 = calcverticalvectorpoint(x21, y21, x22, y22, mx1, my1);
    mx2 = npt3.dx, my2 = npt3.dy;
    
    mtx = (mx1 + mx2) / 2, mty = (my1 + my2) / 2;
    drawsidemarkerline(index, lncode, mx1, my1, mx2, my2);
    if (editmode == 1) {
        drawsideinputmarker(index, lncode, mtx, mty, rounddecimal(mtext));
    } else {
        drawsidemarkertext(index, lncode, mtx, mty, decimaltofraction(mtext));
    }    
}
function drawsidemarkerline(index, code, x1, y1, x2, y2, edgetype) {    
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let mindex = shape.index + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (sideg.empty()) { sideg = sidesg.append("g").attr("id", sidegindex); }
    let markerline = sideg.select("#mline" + mindex);
    if (markerline.empty()) { markerline = sideg.append("line").attr("id", "mline" + mindex); }
    let arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    let arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("class", "sidearrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
}
function drawsidemarkertext(index, code, mtx, mty, mtext, angle) {
    let etype = sideedgetext(index, code);
    let sidegindex =  shape.mode + "sideg" + shape.index + index;
    let mindex = shape.index + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);   
    if (!sideg.empty()) {
        let markertext = sideg.select("#mtext" + mindex);
        if (!markertext.empty()) { markertext.remove(); }
        markertext = sideg.append("text").attr("id", "mtext" + mindex);
        markertext.attr("x", mtx).attr("y", mty).attr("sindex", shape.index).attr("smode", shape.mode).attr("index", index).attr("code", code);
        // var markertextpath = markertext.append("textPath").attr("id", "mtextpath" + mindex).attr("xlink:href", "#mline" + mindex).style("text-anchor", "middle").attr("startOffset", "50%");       
        markertext.attr("x", mtx).attr("y", mty).append("tspan").attr("id", "mtextspan1" + mindex).style("fill", "black").text(mtext);
        if (etype.length > 0) { markertext.append("tspan").attr("id", "mtextspan2" + mindex).style("fill", "goldenrod").text(" | " + etype); }
        if (shape.mode == 'shape') { markertext.on("click", onsidemarkertext); }
        let angseg = Math.floor(angle / 180);
        let angle1 = angle - (angseg * 180);
        if (angle1 > 90) { angle1 = angle1 + 180; }
        if (angle1 > 0) { markertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")"); }
    }
}
function updatesidemarkertext(index, code, mtext) {
    let etype = sideedgetext(index, code);
    let sindex = this.getAttribute("sindex");
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let mindex = sindex + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);
    if (!sideg.empty()) {
        var markertext = sideg.select("#mtext" + mindex);
        if (!markertext.empty()) {
            var mtx = markertext.getAttribute("x");
            var mty = markertext.getAttribute("y");
            var mtexttspan = markertext.select("#mtextspan1" + mindex);
            var mtext = mtexttspan.text();
            drawsidemarkertext(index, code, mtx, mty, mtext);
        }
    }
}
function onsidemarkertext() {
    if (bdraw) { onendshapedraw(); }
    var sindex = parseInt(this.getAttribute("sindex"));
    var index = parseInt(this.getAttribute("index"));
    var code = this.getAttribute("code");    
    var type = this.getAttribute("stype");
    var mode = this.getAttribute("smode");
    if (editmode == 1) { editmode = 0; drawshapesides(sindex, 'onsidemarkertext-1'); } //check drawshapesides() called twice??
    initshapegroups(sindex, mode, 'onsidemarkertext');
    editmode = 1;
    drawshapesides(sindex, 'onsidemarkertext-2');
    selectsideinputcontrol(sindex, index, code);
}
function drawsideinputmarker(index, code, mtx, mty, mtext) {
    let sidegindex = shape.mode + "sideg" + shape.index + index;
    let mindex = shape.index + "" + index + "" + code;
    let sideg = sidesg.select("#" + sidegindex);    
    if (!sideg.empty()) {
        var markertext = sideg.select("#mfotext" + mindex);
        if (markertext.empty()) { markertext = sideg.append("foreignObject").attr("id", "mfotext" + mindex); }
        markertext.attr("x", mtx).attr("y", mty).attr("width", "60").attr("height", "30");
        var markerinputtext = markertext.select("#mitext" + mindex);
        if (markerinputtext.empty()) { markerinputtext = markertext.append('xhtml:input').attr("id", "mitext" + mindex); }
        markerinputtext.attr("style", "padding-left:5px;width:60px;height:20px;").attr("type", "text").property("value", mtext).attr("index", index)
            .attr("sindex", shape.index).attr("smode", shape.mode).attr("code", code).on("change", oneditshapeside).on("keydown", oneditsidekeydown).on("click", onsideinputcontrol);
    }
}
function oneditsidekeydown() {
    var keycode = d3.event.keyCode;
    var inputctl;
    if (keycode == 9) {
        d3.event.preventDefault();
        var index = parseInt(this.getAttribute("index"));
        var code = parseInt(this.getAttribute("code"));        
        var sindex = parseInt(this.getAttribute("sindex"));
        selectnextsideinputcontrol(sindex, index, code);
    }
    if (bdraw) { onendshapedraw(); }
}

function onsideinputcontrol() {
    var index = parseInt(this.getAttribute("index"));
    var code = parseInt(this.getAttribute("code"));    
    var sindex = parseInt(this.getAttribute("sindex"));
    selectsideinputcontrol(sindex, index, code);
    if (bdraw) { onendshapedraw(); }
}
function selectnextsideinputcontrol(sindex, index, code) {
    var index1 = 0, code1 = 0;
    if (code == 0) {index1 = index, code1 = 1;
    } else if (code == 1) {
        if (index < shape.sides.length - 1) {
            if ((index) > 0 && (index < shape.sides.length - 1)) {
                index1 = index, code1 = 4;
            } else {
                index1 = index + 1, code1 = code;
            }
        } else if (index == shape.sides.length - 1) { index1 = index, code1 = 3; }
    } else if (code == 2) {
        if (index > 0) {
            index1 = index - 1, code1 = code;
        }else if (index == 0) {
            index1 = index, code1 = 0;
        }
    } else if (code == 3) {
        index1 = index, code1 = 2;
    } else if (code == 4) {
        index1 = index + 1, code1 = 1;
    }
    selectsideinputcontrol(sindex, index1, code1);
}
function selectsideinputcontrol(sindex, index, code) {
    let mindex = sindex + "" + index + "" + code;
    inputctl = $("#mitext" + mindex);
    if (inputctl != undefined) {
        inputctl.focus();
        inputctl.select();
    }
}

function sideedgeindex(side, code) {
    var edgeindex = -1;// rect shape 1 side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    if (side != undefined) {
        for (var i = 0; i < side.edges.length; i++) { if (side.edges[i].code == code) { edgeindex = i; break; } }
    }
    return edgeindex;
}
function edgeindex(sideindex, code) {
    var edgeindex = -1;// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { edgeindex = i; break; } }
    return edgeindex;
}
function sideedgetype(sideindex, code) {
    var etype = 'F';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    if (shape.sides[sideindex].edges != undefined && shape.sides[sideindex].edges != null) {
        for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { etype = shape.sides[sideindex].edges[i].type; break; } }
    }
    return etype;
}
function sideedgetext(sideindex, code) {
    let etype = '';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    if (shape.sides[sideindex].edges != undefined && shape.sides[sideindex].edges != null) {
        for (let i = 0; i < shape.sides[sideindex].edges.length; i++) {
            if (shape.sides[sideindex].edges[i].code == code) {
                if (shape.sides[sideindex].edges[i].typeid != 0) { etype = shape.sides[sideindex].edges[i].type; }
                break;
            }
        }
    }
    return etype;
}
function onsetsideedge(index, code, type, typeid, height) {
    drawlogservice.beforeupdate(shape, 'onsetsideedge', 5);
    setsideedge(index, code, type, typeid, height);    
    ActionAddEdge(index);
    onsetsideshapeedges1(index, code, type, typeid, height);
    ondeleteshapesidesplash1(-1, index, code);
    drawlogservice.update(shape, 'onsetsideedge', 5);
    onsetslabpart(0, 0,'onsetsideedge');
}
function setsideedge1(side, code, type, typeid, height) {
    if (side != undefined) {
        let edgeindex = sideedgeindex(side, code);
        if (edgeindex == -1) { side.edges.push(initsideedge(side.edges.length, side.index, code, type, typeid, type)); } else {
            let edge = side.edges[edgeindex];
            edge.type = type, edge.typeid = typeid, edge.code = code, edge.height = height, edge.text = type, edge.sideindex = side.index;
        }
    }
}
function setsideedge(index, code, type, typeid, height) {
    let side = shape.sides[index], w1 = side.w1, w2 = side.w2, h = side.h;
    let mtext = '';
    setsideedge1(side, code, type, typeid, height);
    if (code == 0) { drawshapestartside(index); mtext = decimaltofraction(h); } else if (code == 1) { drawshapeside1(index); mtext = decimaltofraction(w1); }
    else if (code == 2) { drawshapeside2(index); mtext = decimaltofraction(w2); } else if (code == 3) { drawshapeendside(index); mtext = decimaltofraction(h); }
    drawsidemarkers(index);   
}
function sideedgeclass(type) {
    let eclass = 'shapeside';
    if (type == 'A') {
        eclass = 'shapesidepurple';
    } else if (type == 'U') {
        eclass = 'shapesidered';
    } else if (type == 'S') {
        eclass = 'shapesidered';
    } else if (type == 'E') {
        eclass = 'shapesideorange';
    } else if (type == 'C') {
        eclass = 'shapeseam';
    } else if (type == 'F') {
        eclass = 'shapeside';
    } else if (type == 'W') {
        eclass = 'shapesidewhite';
    } else {
        eclass = 'shapesideblack';
    }
    return eclass;
}
function showshapeside() {
    if (drawmode == 3 || drawmode == 4 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
        d3.select(this).attr("class", "shapesideblue");
    } else if (drawmode == 1) {
        //work later
        //if (editmode != 1) {
        //    let index = parseInt(this.getAttribute("index"));
        //    let sindex = parseInt(this.getAttribute("sindex"));
        //    let code = parseInt(this.getAttribute("code"));                    
        //    if (code == 3) {
        //        if (shape.index != sindex) {initshapegroups(sindex, 'shape', 'onshapeside'); }                        
        //        onshapesidedrawhandle();
        //    }
        //}
    }
}
function hideshapeside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));  
    if (drawmode == 3 || drawmode == 4 || drawmode == 5) {//splash/edge mode
        let edgetype = this.getAttribute("edgetype");
        let scolor = d3.select(this).attr('scolor');
        d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
        d3.select(this).attr("class", sideedgeclass(edgetype));
    }
}
function removeshapesclipimages() {
    for (let i = 0; i < shapes.length; i++) {        
        removeshapeclipimages(i);
    }
}
function setshapesopacity(fillopacity) {
    for (let i = 0; i < shapes.length; i++) {
        setshapepathopacity(i, fillopacity);       
    }
}
function setslabpartsopacity(fillopacity) {
    for (let i = 0; i < slabparts.length; i++) {
        setslabppartpathopacity(i, fillopacity);
    }
}
function removeshapeclipimages(sindex) {
    let shapeslabimagesg = d3.select("#shapeslabimgsg" + sindex);
    if (!shapeslabimagesg.empty()) { shapeslabimagesg.selectAll('*').remove(); }
}
function setshapepathopacity(sindex, fillopacity) {    
    if (shapes[sindex] != undefined) {
        for (let i = 0; i < shapes[sindex].sides.length; i++) {
            let sidepathindex = i + "" + sindex;
            let shapesidepath = d3.select("#shape" + "sidepath" + sidepathindex);
            if (!shapesidepath.empty()) { shapesidepath.style("fill-opacity", fillopacity); }
        }
    }
}
function setslabppartpathopacity(sindex, fillopacity) {
    for (let i = 0; i < slabparts[sindex].sides.length; i++) {
        let sidepathindex = i + "" + sindex;
        let shapesidepath = d3.select("#slabpart" + "sidepath" + sidepathindex);
        if (!shapesidepath.empty()) { shapesidepath.style("fill-opacity", fillopacity); }       
    }
}