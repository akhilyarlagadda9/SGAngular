function calcshapeangle(index) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2;
    let x3 = side1.x1, y3 = side1.y1, x4 = side1.x2, y4 = side1.y2;
    let angle=0, angle1 = 0, angle2 = 0;
    angle1 = calclineangle2(x1, y1, x2, y2, 'calcshapeangle');
    angle2 = calclineangle2(x3, y3, x4, y4, 'calcshapeangle');   
    angle = Math.abs(angle1 - angle2);   
    if (angle > 90 && angle < 180) { angle = angle - 90; } else if (angle == 180) { angle = 0; }
    else if (angle > 180 && angle <= 270) { angle = angle - 180; } else if (angle > 270 && angle < 360) { angle = 360 - angle; } 
    return angle;
}
function onshapeangle() {
    if (bdraw) { onendshapedraw(); }
    removeanglehandles();
    d3.event.preventDefault();
    var m = d3.mouse(this);
    var index = parseInt(this.getAttribute("index"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var dsign = parseInt(this.getAttribute("dsign"));
    var cangle = parseInt(this.getAttribute("cangle"));   
    var mode = this.getAttribute("smode");
    if (editmode == 1) { editmode = 0; drawshapesides(); }
    initshapegroups(sindex, mode, 'onshapeangle');
    if (drawmode == 7) {     
        if (seamtype == 2) { onsetsideseam(m[0], m[1], -1, index, sindex, seamtype); }      
        setdrawmode(0);
    } else {
        if (mode == 'shape') { drawcorneranglehandles(index); }
    }
}
function drawcorneranglehandles(index) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2, cw = 72;

    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;

    let angle1 = 0, angle2 = 0;
    angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    let hangle1 = 0, hangle2 = 0;
    if (angle1 >= 180) { hangle1 = angle1 - 180; } else { hangle1 = angle1 + 180; }
    if (angle2 >= 180) { hangle2 = angle2 - 180; } else { hangle2 = angle2 + 180; }
   // console.log(hangle1, hangle2, angle1, angle2);
    for (let i = 0; i < 16; i++) {
        let hangle = i * 22.5;
        if (hangle != hangle1 && hangle != hangle2) {
          //  console.log(hangle, hangle1, hangle2, angle1,angle2);
            let npt1 = rotate_point1(cx, cy, -1, hangle, cw);
            let hx2 = npt1.dx, hy2 = npt1.dy;
            drawshapeanglehandle(index, cx, cy, hx2, hy2, hangle, 2);
        }
    }

    let npt1 = rotate_point1(cx, cy, -1, angle1, cw);
    let hx1 = npt1.dx, hy1 = npt1.dy;
    drawshapeanglehandle2(index, cx, cy, hx1, hy1, angle1, 1);

    npt1 = rotate_point1(cx, cy, -1, angle2, cw);
    hx1 = npt1.dx, hy1 = npt1.dy;
    drawshapeanglehandle2(index, cx, cy, hx1, hy1, angle2, 2);
}

function onshapeanglehandle(index, sindex, angle, atype) {
    drawlogservice.beforeupdate(shape, 'onshapeanglehandle', 8);
    if (angle == 360) { angle = 0; }
    if (atype == 1) {
        let sideindex = index;
        for (let i = index; i >= 0; i--) {
            onshapeanglehandle1(i, sideindex, angle);
        }
    } else if (atype == 2) {
        let sideindex = index + 1;
        for (let i = sideindex; i < shape.sides.length; i++) {
            onshapeanglehandle2(i, sideindex, angle);
        }
    }
    onsetshapesidecutouts(index, sindex);
    shapesides('onshapeanglehandle');
    drawlogservice.update(shape, 'onshapeanglehandle', 8);
    onsetslabpart(0, 0, 'onshapeanglehandle');   
}

function onshapeanglehandle1(index, sideindex, angle) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, w = side.w * scale, dh = side.h / 2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, w1 = side.w1 * scale;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w2 = side.w2 * scale;

    let angle1 = calclineangle2(x2, y2, x1, y1, 'resetsideonsizechange1');
    if (index == sideindex) { angle1 = angle; }
    if (side1 != undefined) {
        if (index != sideindex) { x2 = side1.x1, y2 = side1.y1, x12 = side1.x11, y12 = side1.y11, x22 = side1.x21, y22 = side1.y21; }
    }
   // console.log(index, sideindex, angle);
    let npt = rotate_point1(x2, y2, -1, angle1, w);
    x1 = npt.dx, y1 = npt.dy;
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
    let npt2 = offsetline(x1, y1, x2, y2, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x11, y11, x12, y12, side1.x11, side1.y11, side1.x12, side1.y12);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x12 = ipt.dx, y12 = ipt.dy;
            side.x12 = x12, side.y12 = y12, side1.x11 = x12, side1.y11 = y12;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt.dy != 0) {
            x22 = ipt1.dx, y22 = ipt1.dy;
            side.x22 = x22, side.y22 = y22, side1.x21 = x22, side1.y21 = y22;
        }
    }
    let nw = roundToTwo(calchyplen(x1, y1, x2, y2));
    let nw1 = roundToTwo(calchyplen(x11, y11, x12, y12));
    let nw2 = roundToTwo(calchyplen(x21, y21, x22, y22));
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2, side.w = nw / scale;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12, side.w1 = nw1 / scale;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22, side.w2 = nw2 / scale;
    if (side1 != undefined) {
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w1 = roundToTwo(calchyplen(side1.x11, side1.y11, side1.x12, side1.y12) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
}
function onshapeanglehandle2(index, sideindex, angle) {
    let side = shape.sides[index], side1 = shape.sides[index - 1];
    let x1 = side.x1, y1 = side.y1, x2 = side.x2, y2 = side.y2, w = side.w * scale, dh = side.h / 2;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, w1 = side.w1 * scale;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w2 = side.w2 * scale;

    let angle1 = calclineangle2(x1, y1, x2, y2, '');
    if (index == sideindex) { angle1 = angle; }
    if (side1 != undefined) { x1 = side1.x2, y1 = side1.y2; x11 = side1.x12, y11 = side1.y12; x21 = side1.x22, y21 = side1.y22; }
    //console.log(index, sideindex, angle);
    let npt = rotate_point1(x1, y1, -1, angle1, w);
    x2 = npt.dx, y2 = npt.dy;
    let npt1 = offsetline(x1, y1, x2, y2, dh);
    x11 = npt1.dx1, y11 = npt1.dy1, x12 = npt1.dx2, y12 = npt1.dy2;
    let npt2 = offsetline(x1, y1, x2, y2, -dh);
    x21 = npt2.dx1, y21 = npt2.dy1, x22 = npt2.dx2, y22 = npt2.dy2;

    if (side1 != undefined) {
        let ipt = calintersection1(x11, y11, x12, y12, side1.x11, side1.y11, side1.x12, side1.y12);
        if (ipt.dx != 0 && ipt.dy != 0) {
            x11 = ipt.dx, y11 = ipt.dy;
            side.x11 = x11, side.y11 = y11, side1.x12 = x11, side1.y12 = y11;
        }
        let ipt1 = calintersection1(x21, y21, x22, y22, side1.x21, side1.y21, side1.x22, side1.y22);
        if (ipt1.dx != 0 && ipt.dy != 0) {
            x21 = ipt1.dx, y21 = ipt1.dy;
            side.x21 = x21, side.y21 = y21, side1.x22 = x21, side1.y22 = y21;
        }
    }

    let nw = roundToTwo(calchyplen(x1, y1, x2, y2));
    let nw1 = roundToTwo(calchyplen(x11, y11, x12, y12));
    let nw2 = roundToTwo(calchyplen(x21, y21, x22, y22));
    side.x1 = x1, side.y1 = y1, side.x2 = x2, side.y2 = y2, side.w = nw / scale;
    side.x11 = x11, side.y11 = y11, side.x12 = x12, side.y12 = y12, side.w1 = nw1 / scale;
    side.x21 = x21, side.y21 = y21, side.x22 = x22, side.y22 = y22, side.w2 = nw2 / scale;
    if (side1 != undefined) {
        side1.w = roundToTwo(calchyplen(side1.x1, side1.y1, side1.x2, side1.y2) / scale);
        side1.w1 = roundToTwo(calchyplen(side1.x11, side1.y11, side1.x12, side1.y12) / scale);
        side1.w2 = roundToTwo(calchyplen(side1.x21, side1.y21, side1.x22, side1.y22) / scale);
    }
}
function drawshapeangles() {
    if (shape.sides != null) {
        for (let j = 0; j < shape.sides.length - 1; j++) {
            drawshapeangle(j);
        }
    }
}
function drawshapeangle(index) {
    let side = shape.sides[index], sindex = shape.index, smode = shape.mode;
    let cx = side.x2, cy = side.y2, cr = 24;
    let cangle = calcshapeangle(index);
    let caclass = 'shapesplash';
    let shapepathg = shapeg.select("#" + smode + "pathg" + index);
    if (shapepathg.empty()) { shapepathg = shapeg.append("g").attr("id", smode + "pathg" + index); }
    canglecircle = shapepathg.select("#canglecircle" + index);
    if (canglecircle.empty()) {
        canglecircle = shapepathg.append("circle").attr("id", "canglecircle" + index).attr("index", index).attr("sindex", sindex).attr("smode", smode);
    }
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr).attr("class", caclass).attr("smode", smode).on("click", onshapeangle);
    let cangletext = shapepathg.select("#cangletext" + sindex + "" + index);
    if (cangletext.empty()) { cangletext = shapepathg.append("text").attr("id", "cangletext" + sindex + "" + index); }
    cangletext.attr("x", cx - 7).attr("y", cy + 5).text(cangle).attr("index", index).attr("sindex", sindex).attr("smode", smode).on("click", onshapeangle);
}
function drawshapeanglehandle(index, x1, y1, x2, y2, angle, atype) {
    let hindex = index + angle.toFixed() + atype;
    let canglehandle = anglehandlesg.select("#canglehandle" + hindex);
    if (canglehandle.empty()) { canglehandle = anglehandlesg.append("line").attr("id", "canglehandle" + hindex); }
    canglehandle.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("marker-end", "url(#circle-end)").attr("class", "shapeside");
    let canglehandlecircle = anglehandlesg.select("#canglehandlecircle" + hindex);
    if (canglehandlecircle.empty()) { canglehandlecircle = anglehandlesg.append("circle").attr("id", "canglehandlecircle" + hindex); }
    canglehandlecircle.attr("cx", x2).attr("cy", y2).attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("r", 8).attr("cindex", index).attr("sindex", shape.index)
    .attr("smode", shape.mode).attr("angle", angle).attr("atype", atype).attr("style", "fill:gray").style("stroke-opacity", "0.2");
}
function drawshapeanglehandle2(index, x1, y1, x2, y2, angle, atype) {
    let hindex = index + atype;
    let canglehandle = anglehandlesg.select("#canglehandledrag" + hindex);
    if (canglehandle.empty()) { canglehandle = anglehandlesg.append("line").attr("id", "canglehandledrag" + hindex); }
    canglehandle.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("smode", shape.mode).attr("marker-end", "url(#circle-end)").attr("class", "shapeside");
    let canglehandlecircle = anglehandlesg.select("#canglehandledragcircle" + hindex);
    if (canglehandlecircle.empty()) { canglehandlecircle = anglehandlesg.append("circle").attr("id", "canglehandledragcircle" + hindex); }
    canglehandlecircle.attr("cx", x2).attr("cy", y2).attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("r", 8).attr("cindex", index)
    .attr("class", "arrowcircle").attr("sindex", shape.index).attr("smode", shape.mode).attr("angle", angle).attr("atype", atype).call(anglehandledrag);
}
function anglehandledragstarted() {
    let index = parseInt(this.getAttribute("cindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let atype = parseInt(this.getAttribute("atype"));
    let quardrant = parseInt(this.getAttribute("quardrant"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        if (shape.index != sindex) { initshapegroups(sindex, mode); }
        bdrag = true;
    }
}
function anglehandledragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("cindex"));
        let atype = parseInt(this.getAttribute("atype"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let x1 = parseInt(this.getAttribute("x1"));
        let y1 = parseInt(this.getAttribute("y1"));
        let x2 = parseInt(this.getAttribute("x2"));
        let y2 = parseInt(this.getAttribute("y2"));
        let nx2 = d3.event.x;
        let ny2 = d3.event.y;
        let angle = calclineangle2(x1, y1, nx2, ny2, 'anglehandledragged');
        // onshapeanglehandle(index, sindex, x1, y1, nx2, ny2, angle, atype);
        drawshapeanglehandle2(index, x1, y1, nx2, ny2, angle, atype);
    }
}
function anglehandledragended() {
    if (bdrag) {
        bdrag = false;
        let index = parseInt(this.getAttribute("cindex"));
        let atype = parseInt(this.getAttribute("atype"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let x1 = parseInt(this.getAttribute("x1"));
        let y1 = parseInt(this.getAttribute("y1"));
        let x2 = parseInt(this.getAttribute("x2"));
        let y2 = parseInt(this.getAttribute("y2"));
        let nx2 = d3.event.x;
        let ny2 = d3.event.y;
        let angle = calclineangle2(x1, y1, nx2, ny2, 'anglehandledragged');
        let angseg = parseFloat(angle / 22.5).toFixed(1);
        angseg = (angseg - Math.floor(angseg)) > 0.5 ? Math.round(angseg) : Math.floor(angseg);
        let angle1 = angseg * 22.5;
        angle1 = checkanglediff(index, angle1, atype);
        onshapeanglehandle(index, sindex, angle1, atype);
        drawcorneranglehandles(index);
        ActionChangeAngle();
    }
}
function checkanglediff(index, angle, atype) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2;

    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;
    let angle3 = 0;
    let angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    let angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    let hangle = 0, hangle1 = 0, hangle2 = 0, minangle = 0, maxangle = 0;
    if (angle1 >= 180) { hangle1 = angle1 - 180; } else { hangle1 = angle1 + 180; }
    if (angle2 >= 180) { hangle2 = angle2 - 180; } else { hangle2 = angle2 + 180; }
    if (angle != hangle1 && angle != hangle2) { hangle = angle; } else { hangle = angle + 22.5; }
    if (atype == 1) {
        hangle1 = angle2 - 90, hangle2 = angle2 + 90;
        if (hangle1 > 360) { hangle1 =  Math.abs(hangle1 - 360); } if (hangle2 > 360) { hangle2 = Math.abs(hangle2 - 360); }
        minangle = Math.min(hangle1, hangle2), maxangle = Math.max(hangle1, hangle2);
        if (minangle < angle && angle < maxangle) { hangle = angle1; } else { hangle = angle; }
       // console.log(atype, hangle1, hangle2, minangle, maxangle, hangle, angle, angle1, angle2);
    } else {
        hangle1 = angle1 - 90, hangle2 = angle1 + 90;
        if (hangle1 > 360) { hangle1 = Math.abs(hangle1 - 360); } if (hangle2 > 360) { hangle2 = Math.abs(hangle2 - 360); }
        minangle = Math.min(hangle1, hangle2), maxangle = Math.max(hangle1, hangle2);
        if (minangle < angle && angle < maxangle) { hangle = angle2; } else { hangle = angle;}
     //   console.log(atype, hangle1, hangle2, minangle, maxangle, hangle, angle, angle1, angle2);
    }  
    return hangle;
}
function checkanglediff1(index, angle, atype) {
    let side = shape.sides[index], side1 = shape.sides[index + 1];
    let cx = side.x2, cy = side.y2;
   
    let sx1 = side.x1, sy1 = side.y1, sx2 = side.x2, sy2 = side.y2;
    let s1x1 = side1.x1, s1y1 = side1.y1, s1x2 = side1.x2, s1y2 = side1.y2;
    let angle1 = 0, angle2 = 0, angle3 = 0;
    angle1 = calclineangle2(sx2, sy2, sx1, sy1, 'calcshapeangle');
    angle2 = calclineangle2(s1x1, s1y1, s1x2, s1y2, 'calcshapeangle');
    let hangle = 0, hangle1 = 0, hangle2 = 0;    
    if (angle1 >= 180) { hangle1 = angle1 - 180; } else { hangle1 = angle1 + 180; }
    if (angle2 >= 180) { hangle2 = angle2 - 180; } else { hangle2 = angle2 + 180; }

    if (angle != hangle1 && angle != hangle2) { hangle = angle; } else { hangle = angle + 22.5; }
    if (atype == 1) { angle3 = Math.abs(angle2 - hangle); } else { angle3 = Math.abs(angle1 - hangle); }   
    if (hangle > 270 && hangle < 360) {
        angle3 = 360 - hangle;
        if (angle1 < 90) { angle3 = angle3 + angle1; } else if (angle2 < 90) { angle3 = angle3 + angle2; }
    }
    if (angle3 < 90) {
        if (atype == 1) { hangle = angle1; } else { hangle = angle2; }
    }
    return hangle;
}