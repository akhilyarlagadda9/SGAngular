function initsidecorners(sideindex) {
    let side = shape.sides[sideindex];
    side.corners.push(initsidecorner(0, sideindex, 1));
    side.corners.push(initsidecorner(1, sideindex, 2));
    side.corners.push(initsidecorner(2, sideindex, 3));
    side.corners.push(initsidecorner(3, sideindex, 3));
    //for (let i = 0; i < 4; i++) {
    //    side.corners.push(initsidecorner(i, sideindex, i + 1));
    //}
}
function initsidecorner(index, sideindex, sidecode) {
    let edgetype = sideedgetype(sideindex, sidecode);
    let cr = Math.round(calchyplen1(cornerwh, cornerwh));    
    let corner = { index: index, sideindex: sideindex, sidecode: sidecode, sindex: shape.index, type: 0, w: cornerwh, h: cornerwh, r: cr, angle: 90, typeid: 0, edgetype: edgetype, edgetypeid: 0, edgeheight: 0, edges: [] };
    initcorneredges(corner, edgetype);
    return corner;
}
function initcorneredges(corner, edgetype) {
    let edges = [];
    edges.push(initcorneredge(0, corner.index, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(1, corner.index, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(2, corner.index, 0, edgetype, 0, edgetype));
    edges.push(initcorneredge(3, corner.index, 0, edgetype, 0, edgetype));
    edges.push(initcorneredge(4, corner.index, 0, edgetype, 0, edgetype));
    corner.edges = edges;
}
function initcorneredge(index, sideindex, sidecode, type, typeid, text) {
    let edge = { index: index, sideindex: sideindex, sidecode: sidecode, type: type, typeid: typeid, text: text, width:0, height:0 };
    return edge;
}
function sidecornerindex(sideindex, x1, y1) {
    let cindex = -1;
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.corners.length; i++) {       
        if (side.corners[i].x1 == x1 && side.corners[i].y1 == y1) { cindex = i; break; }
    }
    return cindex;
}
function setsidecorners32(sideindex,source) {
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.corners.length; i++) {
        setsidecorner32(i, sideindex, i, side.corners[i].type, side.corners[i].typeid, source + ':setsidecorners32');
    }
}
function setsidecorner32(index, sideindex, sidecode, type, typeid, source) {
    //type id: 10 - radius, 8-clip, 7-bump out, 9- Notch
    //type: 1-clip, 2- radius, 3- Notch, 4- Bumpout
 //   console.log(index, sideindex, sidecode, type, typeid, source);
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    if (corner == undefined) { corner = initsidecorner(index, sideindex, sidecode); }
    corner.type = type; corner.typeid = typeid;
    let w = corner.w, h = corner.h, r = corner.r, edgetype = corner.edgetype;
    //console.log(index, sideindex, sidecode, typeid, w, h, r, applymminchfact(w, 2, 2, source), applymminchfact(h, 2, 2, source), applymminchfact(r, 2, 2, source))
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let x1 = x11, y1 = y11, x2 = x12, y2 = y12, x3 = x21, y3 = y21;
    if (index == 0) { x1 = x11, y1 = y11, x2 = x12, y2 = y12, x3 = x21, y3 = y21; }
    else if (index == 1) { x1 = x21, y1 = y21, x2 = x22, y2 = y22, x3 = x11, y3 = y11; }
    else if (index == 2) { x1 = x12, y1 = y12, x2 = x11, y2 = y11, x3 = x22, y3 = y22; }
    else if (index == 3) { x1 = x22, y1 = y22, x2 = x21, y2 = y21, x3 = x12, y3 = y12; }
    //if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
    if (sideindex > 0) { let side1 = shape.sides[sideindex - 1]; if (sidecode == 1) { x3 = side1.x11, y3 = side1.y11; } else if (sidecode == 2) { x3 = side1.x21, y3 = side1.y21; } }
    let npt1 = calclinepoint(x1, y1, x2, y2, w);
    x2 = npt1.dx, y2 = npt1.dy;
    let npt2 = calclinepoint(x1, y1, x3, y3, h);
    x3 = npt2.dx, y3 = npt2.dy;
    corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;   
}
function onsetsidecorner(index, sideindex, type, typeid, source) {
    //console.log(index, sideindex, type, source);
    drawlogservice.beforeupdate(shape, 'onsetsidecorner', 2);
    let side = shape.sides[sideindex];
    let corner = side.corners[index], sidecode = corner.sidecode;
    let edgetype = sideedgetype(sideindex, sidecode);
    removeshapesidecorner(index, sideindex, shape.index);
    setsidecorner32(index, sideindex, sidecode, type, typeid, source + ':onsetsidecorner');
    setsidecorneredges(index, sideindex, edgetype, typeid, 'onsetsidecorner');
    drawsidecorner32(index, sideindex);  
    onsetcornerseam32(index, sideindex);
    resetshapesplashs(source);
    drawshapesides32(source);
    drawlogservice.update(shape, 'onsetsidecorner', 2);
    ActionCorner('onsetsidecorner');
}
function onsetcornertype(sindex) {
    //1. highlight shape corners to click corner and set corner type.    
    drawshapecorners(sindex, 'setcornertype');
}
function onsetsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source) {
    drawlogservice.beforeupdate(shape, 'setsidecorneredge', 2);
    setsidecorneredges(index, sideindex, edgetype, edgetypeid, edgeheight, source);
    drawlogservice.update(shape, 'setsidecorneredge', 2);
    ActionCorner('onsetsidecorneredge');
}
function setsidecorneredges(index, sideindex, edgetype, edgetypeid, source) {
    //0,1 - white line corner line edges
    setsidecorneredge(2, index, sideindex, edgetype, edgetypeid, 0, source);
    setsidecorneredge(3, index, sideindex, edgetype, edgetypeid, 0, source);
    setsidecorneredge(4, index, sideindex, edgetype, edgetypeid, 0, source);
}
function setsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source) {    
    let side = shape.sides[sideindex];
    let corner = side.corners[index], sidecode = corner.sidecode;
    if (corner.edges == undefined) { initcorneredges(corner); }
    let corneredge = corner.edges[lnindex];
    corneredge.type = edgetype, corneredge.typeid = edgetypeid, corneredge.text = edgetype;
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    //console.log(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source, corner.type, cornerindex);
    if (!cornerg.empty()) {
        //let etypes = [];
        //if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
        let eclass = sideedgeclass(edgetype);       
        if (corner.type ==2) {
            let cornerpath = cornerg.select("#corner" + cornerindex);
            if (!cornerpath.empty()) { cornerpath.attr("edgetype", edgetype); }//mouseout hideshapecorner will set class based on edgetype
        } else {            
            let clineindex = cornerindex + "" + lnindex;
            let cornerline = cornerg.select("#corner" + clineindex);
            //console.log(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source, clineindex);
            if (!cornerline.empty()) { cornerline.attr("class", eclass).attr("edgetype", edgetype); }//mouseout hideshapecorner will set class based on edgetype
        }
    }   
}
function onshapesidecorner() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    let mode = this.getAttribute("smode");
    let lnindex = parseInt(this.getAttribute("lnindex"));
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));   
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecorner');
    if (drawmode == 2) {
        onsetsidecorner(index, sideindex, cornertype, cornertypeid, 'onshapesidecorner');
    } else if (drawmode == 4) {
        onsetcornersplash(lnindex, index, sideindex, sidecode, edgetype, edgetypeid, 2, 'onshapesidecorner');
    } else if (drawmode == 5) {
        let lnindex = this.getAttribute("lnindex");
       // console.log(lnindex, index, sideindex, cornertype, drawmode);
        if (lnindex != undefined) {
            onsetsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, 0, 'onshapesidecorner');
        }
    }
}
function onshapesidecornercontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode == 'shape') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecornercontextmenu');
        drawshapesidecornercontrols(index, sideindex, m[0], m[1]);
    }
}
function resetsidecorner32(index, sideindex, w, h, r, type, typeid, source) {
    //type id: 10 - radius, 8-clip, 7-bump out, 9- Notch
    //type: 1-clip, 2- radius, 3- Notch, 4- Bumpout   
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    corner.w = w, corner.h = h, corner.r = r, sidecode = corner.sidecode, corner.type = type; corner.typeid = typeid;
    let edgetype = sideedgetype(sideindex, sidecode);
    setsidecorner32(index, sideindex, sidecode, type, typeid, source);
    drawsidecorner32(index, sideindex);
    onsetcornerseam32(index, sideindex);
    drawshapesides32(source);
}
function resetsidecorners32(w, h, r, type, typeid, source) {
    for (i = 0; i < shape.sides.length; i++) {
        for (j = 0; j < shape.sides[i].corners.length; j++) {
            resetsidecorner32(j, i, w, h, r, type, typeid, source);
        }
    }
    resetshapesplashs(source); ActionCorner(source);
}
function onresizesidecorner(obj, changetype, index, sideindex) {
    let source = 'onresizesidecorner';
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let objVal = obj.value.split(" ");
    let whr = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    let isvalid = true;
    if (isNaN(whr)) { isvalid = false; }
    //console.log(index, sideindex, changetype, whr, corner.type);
    if (whr > 0) {
        if (corner.type == 4 && changetype == 3) {
            isvalid = true;
        }else if (changetype == 3) {
            if (!validatecornerchange32(index, sideindex, 1, calcsidelen(whr))) { isvalid = false; }
            if (!validatecornerchange32(index, sideindex, 2, calcsidelen(whr))) { isvalid = false; }
        } else {
            if (!validatecornerchange32(index, sideindex, changetype, whr)) { isvalid = false; }
        }        
    } else { isvalid = false;}
    if (!isvalid) { $('#shapectlerrormsg' + index).attr("style", "color:red;display:block;"); } else { $('#shapectlerrormsg' + index).attr("style", "display:none;"); }
    if (isvalid) {
        let ncw = applymminchfact(corner.w, 2, 2, source), nch = applymminchfact(corner.h, 2, 2, source), ncr = applymminchfact(corner.r, 2, 2, source), ctype = corner.type, ctypeid = corner.typeid;
        if (changetype == 1) {
            //if (ctype == 1) {
            //    ncr = calchyplen1(whr, nch);
            //    $('#shapectlinputdepth' + index).val(decimaltofraction(ncr));
            //}           
            ncw = whr;
            if (ctype == 4) { nch = ncw; }
        } else if (changetype == 2) {
            //if (ctype == 1) {
            //    ncr = calchyplen1(ncw, whr);
            //    $('#shapectlinputdepth' + index).val(decimaltofraction(ncr));
            //}           
            if (ctype == 4) { ncr = whr; } else { nch = whr; }
        }
        else if (changetype == 3) {
            if (ctype == 1 || ctype == 2) {
                ncw = nch = calcsidelen(whr);
                $('#shapectlinputwidth' + index).val(decimaltofraction(ncw));
                $('#shapectlinputheight' + index).val(decimaltofraction(nch));
            }
            ncr = whr;
        }
       
        ncw = applymminchfact(ncw, 1, 2, source);
        nch = applymminchfact(nch, 1, 2, source);
        ncr = applymminchfact(ncr, 1, 2, source);
        //console.log(index, sideindex, ncw, nch, ncr);
        drawlogservice.beforeupdate(shape, source, 2);
        resetsidecorner32(index, sideindex, ncw, nch, ncr, ctype, ctypeid, source);
        ActionCorner(source);
        resetshapesplashs(source);
        drawshapesides32(source);
        drawlogservice.update(shape, source, 2);
    }
}
function validatecornerchange32(index, sideindex, changetype, whr, source) {
    //1. sides 
    let side = shape.sides[sideindex];
    let isvalid = true, w1 = side.w1, w2 = side.w2, h = applymminchfact(side.h, 2, 2), whr1 = 0;
    if (index == 0) {
        if (changetype == 1) {
            if (sideindex == shape.sides.length - 1) {//second side corner index = 2
                if (side.corners[2].type != 0) { whr1 = applymminchfact(side.corners[2].w, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex + 1].corners[0].type != 0) { whr1 = applymminchfact(shape.sides[sideindex + 1].corners[0].h, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            }
        } else if (changetype == 2) {
            if (sideindex == 0) {//second side corner index = 2
                if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].h, 2, 2, source); }
                if ((whr + whr1) > h) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex - 1].corners[0].type != 0) { whr1 = applymminchfact(shape.sides[sideindex - 1].corners[0].w, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            }
        }
    } else if (index == 1) {
        if (changetype == 1) {
            if (sideindex == shape.sides.length - 1) {//second side corner index = 3
                if (side.corners[3].type != 0) { whr1 = applymminchfact(side.corners[3].w, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            } else { //second side corner index = 1
                if (shape.sides[sideindex + 1].corners[1].type != 0) { whr1 = applymminchfact(shape.sides[sideindex + 1].corners[1].h, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            }
        } else if (changetype == 2) { //second side corner index = 1
            if (sideindex == 0) {//second side corner index = 2
                if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].h, 2, 2, source); }
                if ((whr + whr1) > h) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex - 1].corners[1].type != 0) { whr1 = applymminchfact(shape.sides[sideindex - 1].corners[1].w, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            }
        }
    } else if (index == 2) {
        if (changetype == 1) {//second side corner index = 0
            if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].w, 2, 2, source); }
            if ((whr + whr1) > w1) { isvalid = false; }
        } else if (changetype == 2) {//second side corner index = 3
            if (side.corners[3].type != 0) { whr1 = applymminchfact(side.corners[3].h, 2, 2, source); }
            if ((whr + whr1) > h) { isvalid = false; }
        }
    } else if (index == 3) {
        if (changetype == 1) {//second side corner index = 1
            if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].w, 2, 2, source); }
            if ((whr + whr1) > w2) { isvalid = false; }
        } else if (changetype == 2) {//second side corner index = 2
            if (side.corners[2].type != 0) { whr1 = applymminchfact(side.corners[2].h, 2, 2, source); }
            if ((whr + whr1) > h) { isvalid = false; }
        }
    }
   // console.log("index:" + index, "sideindex:" + sideindex, "changetype:" + changetype, "w1:" + w1, "w2:" + w2, "h:" + h, "whr:" + whr, "whr1:" + whr1, "whr + whr1:" + (whr + whr1), "isvalid:" + isvalid);
    return isvalid;   
}
function resetshapecorners(source) {
    for (i = 0; i < shape.sides.length; i++) {
        onsidechangeresetcorners(i,source);
    }
}
function onsidechangeresetcorners(sideindex, source) {   
    let side = shape.sides[sideindex];
    for (j = 0; j < 2; j++) {
        setsidecorner32(j, sideindex, side.corners[j].sidecode, side.corners[j].type, side.corners[j].typeid, source);
        setsidecorneredges(j, sideindex, side.corners[j].edgetype, side.corners[j].typeid, source);
        drawsidecorner32(j, sideindex);
    }
}
function onresizesetallsidescorners(index, sideindex) {
    let source = 'onresizesetallsidescorners';
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let ncw = corner.w, nch = corner.h, ncr = corner.r, ctype = corner.type, ctypeid = corner.typeid;
    if (ctype == 4) {
        let objrVal = $('#shapectlinputdepth' + index).val().split(" ");
        let cr = parseFloat(fractionToDecimal(objrVal[0])) + parseFloat(fractionToDecimal(objrVal[1]));
        ncr = applymminchfact(cr, 1, 2, source);
    }   
    let isupdate = false;
    for (i = 0; i < shape.sides.length; i++) {
        for (j = 0; j < shape.sides[i].corners.length; j++) {
            if (j == index && sideindex == i){}else{         
                if (shape.sides[i].corners[j].type == ctype) {
                    let ncw1 = shape.sides[i].corners[j].w; nch1 = shape.sides[i].corners[j].h, ncr1 = shape.sides[i].corners[j].r;
                   // console.log("index:" + j, "sideindex:" + i, "changetype:width", "ncw:" + ncw, "ncw1:" + ncw1, "nch:" + nch, "nch1:" + nch1);
                    if (validatecornerchange32(j, i, 1, applymminchfact(ncw, 2, 2, source))) { ncw1 = ncw; isupdate = true; }
                    if (validatecornerchange32(j, i, 2, applymminchfact(nch, 2, 2, source))) { nch1 = nch; isupdate = true; }
                    if (ctype == 1) { ncr1 = calchyplen1(ncw1, applymminchfact(nch1, 2, 2, source));}
                    if (isupdate) { resetsidecorner32(j, i, ncw1, nch1, ncr1, ctype, ctypeid, source); }
                }
            }
        }
    }
    if (isupdate) {
        resetshapesplashs(source); ActionCorner(source);
        drawshapesides32(source);
    }
}
function ondeleteshapesidecorner(index, sideindex) {
    onsetsidecorner(index, sideindex, 0, 0, 'ondeleteshapesidecorner');
    removeshapecontrols();
}
function drawshapecorners(index, source) {  
    if (shape != undefined && shape.sides!=null) {
        for (let j = 0; j < shape.sides.length; j++) {
            drawsidecorners(j, source);
        }
    }
}
function drawsidecorners(sideindex, source) {  
    let side = shape.sides[sideindex];
    if (side.corners.length == 2) {
        side.corners.push(initsidecorner(2, sideindex, 3));
        side.corners.push(initsidecorner(3, sideindex, 4));
    }
    for (let i = 0; i < side.corners.length; i++) {       
        if (shape.mode != 'slabpart') { setsidecorner32(i, sideindex, side.corners[i].sidecode, side.corners[i].type, side.corners[i].typeid, source + ':drawsidecorners'); }        
        drawsidecorner32(i, sideindex, source + ':drawsidecorners');
    }
}
function setsidecornereampos32(index, sideindex, sidecode) {
    //console.log(index, sideindex, sidecode, cx1, cy1, cx2, cy2, cx3, cy3, cw, shape.sides.length);
    let side = shape.sides[sideindex];
    let dx = 0, dy = 0, issplit = 0, seamline = 0, smtype = 0, seamheight = 0, tfact = 0;
    for (let j = 0; j < side.seams.length; j++) {
        let seam = side.seams[j];
        if (seam.isactive == 1) {
            let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2;
            issplit = seam.split, smtype = seam.type;
            //console.log(j, smtype, sidecode, x1, y1, x2, y2, seam.split, side.seams.length);
            if (smtype == 2 && issplit == 1) {
                //drawpointcircle(10, index, 1, 1, seam.sx1, seam.sy1, 10, 'A');
                //drawpointcircle(11, index, 1, 1, seam.sx2, seam.sy2, 10, 'A');
                // if (index == 0) { cx3 = seam.sx1, cy3 = seam.sy1; } else if (index == 2) { cx2 = seam.sx1, cy2 = seam.sy1; }
                dx = seam.sx1, dy = seam.sy1;
            }
        }
    }
    return {
        dx: Math.round(dx), dy: Math.round(dy), seamsplit: issplit, seamline: seamline, smtype: smtype, seamheight: seamheight, tfact: tfact
    };
}
function drawsidecorner32(index, sideindex, source) {    
    let side = shape.sides[sideindex];
    if (side != undefined) {
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let corner = side.corners[index];        
        let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1,
        type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
        if (corner.edges == undefined) { initcorneredges(corner); }
        let edgetype1 = corner.edges[0].type, edgetype2 = corner.edges[1].type, edgetype3 = corner.edges[2].type, edgetype4 = corner.edges[3].type, edgetype5 = corner.edges[3].type;
        //console.log('shapeindex:' + shape.index, 'sideindex:' + sideindex, 'cornerindex:' + index, 'cornertype:' + type, 'cornerseam:' + sx1 + ',' + sy1, 'cornerseamsplit:' + issplit, 'cornerseamindex:' + cornerseamindex, source);
        if (type == 0) {//No corner
            if (shape.mode == 'shape') {              
                if (index < 2) { drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type); }
                else { if (sideindex == shape.sides.length - 1) { drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type); } }
            }
        } 
        if (type == 1) {  //Clip corner   
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                    if (index == 0) {
                        x3 = sx1, y3 = sy1, x11 = sx1, y11 = sy1;                     
                    } else if (index == 1) {
                        x3 = sx1, y3 = sy1, x21 = sx1, y21 = sy1;                       
                    } else if (index == 2) {
                        x2 = sx1, y2 = sy1, x12 = sx1, y12 = sy1;
                    } else if (index == 3) {
                        x2 = sx1, y2 = sy1, x22 = sx1, y22 = sy1;
                    }
                }               
                drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x3, y3, edgetype3, type);
            }
            else {
                //drawpointcircle(20, index, sideindex, sidecode, x2, y2, 10, 'A');
                //drawpointcircle(30, index, sideindex, sidecode, x3, y3, 10, 'U');
                //drawpointcircle(40, index, sideindex, sidecode, x1, y1, 10, 'F');
                corner.edges[2].width = applymminchfact(calchyplen(x2, y2, x3, y3), 2, 2, source);
                drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x3, y3, edgetype3, type);
                if (shape.mode != 'slabpart') {
                    let mtext = "L " + decimaltofraction(applymminchfact(r, 2, 2, source));
                    let mtx = (x2 + x3) / 2 + 10, mty = (y2 + y3) / 2;
                    drawshapecornermarkertext(index, sideindex, sidecode, mtx, mty, mtext, type);
                }
            }
        }
        else if (type == 2) {//Curve corner
           if (shape.mode == 'slabpart' && issplit == 1) {
               if (sx1 != undefined && sy1 != undefined) {   
                   if (index == 0) {
                       //drawpointcircle(1, index, 1, 1, x21, y21, 10, 'A');
                       //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                       let angle = calclineangle2(x21, y21, x11, y11), asign = -1;
                       let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x21, y21, angle, asign, w, 'drawsidecorner32:0');
                       let etype = sideedgetype(sideindex, 0);
                       drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, sx1, sy1,x2, y2, tfact, 1, w, edgetype3, type);
                       drawsideline(sideindex, 0, sx1, sy1, x21, y21, etype, 15);
                   } else if (index == 1) {
                       //drawpointcircle(1, index, 1, 1, x21, y21, 10, 'A');
                       //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                       let angle = calclineangle2(x21, y21, x11, y11), asign = 1;
                       let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x11, y11, angle, asign, w, 'drawsidecorner32:0');
                       let etype = sideedgetype(sideindex, 0);
                       drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, sx1, sy1, x2, y2, tfact, 1, w, edgetype3, type);
                       drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);
                   } else if (index == 2) {
                       //drawpointcircle(1, index, 1, 1, x22, y22, 10, 'A');
                       //drawpointcircle(2, index, 1, 1, x12, y12, 10, 'U');
                       //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                       let angle = calclineangle2(x22, y22, x12, y12), asign = -1;
                       let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x22, y22, angle, asign, w, 'drawsidecorner32:2');
                       let etype = sideedgetype(sideindex, 2);
                       drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x3, y3, sx1, sy1, 0, tfact, w, edgetype3, type);
                       drawsideline(sideindex, 3, sx1, sy1, x22, y22, etype, 15);
                   } else if (index == 3) {
                       //drawpointcircle(1, index, 1, 1, x22, y22, 10, 'A');
                       //drawpointcircle(2, index, 1, 1, x12, y12, 10, 'U');
                       //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                       let angle = calclineangle2(x22, y22, x12, y12), asign = 1;
                       let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x12, y12, angle, asign, w, 'drawsidecorner32:3');
                       let etype = sideedgetype(sideindex, 3);
                       drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x3, y3, sx1, sy1, 0, tfact, w, edgetype3, type);
                       drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);
                   }
                }
            } else {                
               drawshapecornerarcpath(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, w, edgetype3, type);
               if (shape.mode != 'slabpart' && shape.mode != 'slabpartdg') {
                   let mtext = "R " + decimaltofraction(applymminchfact(r, 2, 2, source));
                   let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
                   drawshapecornermarkertext(index, sideindex, sidecode, mtx, mty, mtext, type);
               }
            }
        }
        else if (type == 3) {//Notch corner        
            //console.log('shapeindex:' + shape.index, 'sideindex:' + sideindex, 'cornerindex:' + index, 'cornertype:' + type, 'cornerseam:' + sx1 + ',' + sy1, 'cornerseamsplit:' + issplit, 'cornerseamindex:' + cornerseamindex, source);           
            if (shape.mode == 'slabpart' && issplit == 1) {                
                if (sx1 != undefined && sy1 != undefined) {
                    let x4 = 0, y4 = 0, asign = -1;
                    let angle1 = calclineangle2(x1, y1, x2, y2);
                    let npt1 = rotate_point1(x3, y3, asign, angle1, w);
                    x4 = npt1.dx, y4 = npt1.dy;                                                         
                    let angle2 = calclineangle2(x3, y3, sx1, sy1);
                    let angle3 = calclineangle2(x2, y2, x4, y4);
                    let angle4 = calclineangle2(x2, y2, sx1, sy1);
                   // console.log(index, angle1, angle2, angle3, angle4);                    
                    if (index == 0) {
                       // drawpointcircle(1, index, 1, 1, sx1, sy1, 10, 'F');                       
                        let etype = sideedgetype(sideindex, 0);
                        if (angle1 == angle2) {
                            drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x4, y4, edgetype3, type);
                            drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                        } else { drawshapecornerline(2, index, sideindex, sidecode, x2, y2, sx1, sy1, edgetype3, type); }                       
                        drawsideline(sideindex, 0, sx1, sy1, x21, y21, etype, 15); 
                    } else if (index == 1) {
                       // drawpointcircle(1, index, 1, 1, sx1, sy1, 10, 'F');
                        if (angle1 == angle2) {
                            drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x4, y4, edgetype3, type);
                            drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                        } else { drawshapecornerline(2, index, sideindex, sidecode, x2, y2, sx1, sy1, edgetype3, type); }
                        drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, edgetype3, type);
                    } else if (index == 2) {
                        //drawpointcircle(2, index, 1, 1, sx1, sy1, 10, 'A');                        
                        let etype = sideedgetype(sideindex, 2);
                        if (angle1 == angle2) {
                            drawshapecornerline(2, index, sideindex, sidecode, x3, y3, sx1, sy1, edgetype3, type);
                        } else {
                            drawshapecornerline(2, index, sideindex, sidecode, x3, y3, x4, y4, edgetype3, type);
                            drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                        }                       
                        drawsideline(sideindex, 3, sx1, sy1, x22, y22, etype, 15);                                              
                    } else if (index == 3) {
                        let etype = sideedgetype(sideindex, 2);
                       // drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'A');                                 
                        if (angle1 == angle2) {
                            drawshapecornerline(2, index, sideindex, sidecode, x3, y3, sx1, sy1, edgetype3, type);
                        } else {
                            drawshapecornerline(2, index, sideindex, sidecode, x3, y3, x4, y4, edgetype3, type);
                            drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                        }                        
                        drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);                       
                    }
                }
            } else {
                let x4 = 0, y4 = 0, asign = -1;
                let angle = calclineangle2(x1, y1, x2, y2);
                let npt1 = rotate_point1(x3, y3, asign, angle, w);
                x4 = npt1.dx, y4 = npt1.dy;
                corner.edges[2].width = applymminchfact(calchyplen(x2, y2, x4, y4), 2, 2, source);
                corner.edges[3].width = applymminchfact(calchyplen(x3, y3, x4, y4), 2, 2, source);    
                if (shape.mode != 'slabpart' && shape.mode != 'slabpartdg') { drawshapecornernotchpath(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype3, type); }
                drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x4, y4, edgetype3, type);
                drawshapecornerline(3, index, sideindex, sidecode, x3, y3, x4, y4, edgetype3, type);
                if (shape.mode != 'slabpart' && shape.mode != 'slabpartdg') {
                    let mtext = decimaltofraction(applymminchfact(w, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(h, 2, 2, source));
                    let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
                    drawshapecornermarkertext(index, sideindex, sidecode, mtx, mty, mtext, type);
                }
            }
        }
        else if (type == 4) {//Bumpout corner  
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
                    let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
                    let dx1 = npt1.dx, dy1 = npt1.dy;
                    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                    let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;
                    let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
                    let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
                    let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));
                    if (angle1 != angle2) {
                        npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
                        dx1 = npt1.dx, dy1 = npt1.dy;
                        sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                    }
                    if (index == 0) {                      
                        x11 = sx1, y11 = sy1, sx22 = sx1, sy22 = sy1;
                        let ipt1 = calintersection1(x11, y11, x21, y21, sx11, sy11, sx12, sy12);
                        sx12 = ipt1.dx, sy12 = ipt1.dy;
                        //drawpointcircle(1, index, 1, 1, ipt1.dx, ipt1.dy, 10, 'F');
                        let etype = sideedgetype(sideindex, 0);
                        drawsideline(sideindex, 0, x11, y11, x21, y21, etype, 15);
                    } else if (index == 1) {
                        x21 = sx1, y21 = sy1, sx22 = sx1, sy22 = sy1;
                       // drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let etype = sideedgetype(sideindex, 1);
                        drawsideline(sideindex, 0, x11, y11, x21, y21, etype, 15);
                    } else if (index == 2) {                                            
                        x12 = sx1, y12 = sy1, sx21 = sx1, sy21 = sy1;
                        let ipt1 = calintersection1(x12, y12, x22, y22, sx11, sy11, sx12, sy12);
                        sx11 = ipt1.dx, sy11 = ipt1.dy;                                              
                        let etype = sideedgetype(sideindex, 2);
                        drawsideline(sideindex, 3, x12, y12, x22, y22, etype, 15);
                    } else if (index == 3) {
                        x22 = sx1, y22 = sy1, sx21 = sx1, sy21 = sy1;
                       // drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let etype = sideedgetype(sideindex, 2);
                        drawsideline(sideindex, 3, x12, y12, x22, y22, etype, 15);
                    }
                    //drawpointcircle(4, index, 1, 1, sx22, sy22, 10, 'A');
                    corner.edges[2].width = applymminchfact(calchyplen(sx21, sy21, sx22, sy22), 2, 2, source);
                    corner.edges[3].width = applymminchfact(calchyplen(sx11, sy11, sx21, sy21), 2, 2, source);
                    corner.edges[4].width = applymminchfact(calchyplen(sx12, sy12, sx22, sy22), 2, 2, source);
                    drawshapecornerline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edgetype3, type);
                    if (index != 3) { drawshapecornerline(3, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edgetype4, type); }
                    if (index != 1) { drawshapecornerline(4, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edgetype5, type); }
                
                    //drawshapecornerbumpoutpath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, edgetype3, type);
                }
            } else {
                let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;              
                let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
                let dx1 = npt1.dx, dy1 = npt1.dy;
                sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;                
                let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;                
                let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
                let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
                let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));               
                if (Math.abs(angle1 - angle2) > 10) {  
                    npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
                    dx1 = npt1.dx, dy1 = npt1.dy;
                    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                }               
                corner.edges[2].width = applymminchfact(calchyplen(sx21, sy21, sx22, sy22), 2, 2, source);
                corner.edges[3].width = applymminchfact(calchyplen(sx11, sy11, sx21, sy21), 2, 2, source);
                corner.edges[4].width = applymminchfact(calchyplen(sx12, sy12, sx22, sy22), 2, 2, source);
                drawshapecornerline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, edgetype3, type);
                drawshapecornerline(3, index, sideindex, sidecode, sx11, sy11, sx21, sy21, edgetype4, type);
                drawshapecornerline(4, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edgetype5, type);               
                drawshapecornerbumpoutpath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, edgetype3, type);
                let mtext = decimaltofraction(applymminchfact(w, 2, 2, source)) + " x " + decimaltofraction(applymminchfact(r, 2, 2, source));
                let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
                drawshapecornermarkertext(index, sideindex, sidecode, mtx, mty, mtext, type);
                
            }
        }
    } else {
        //console.log(shape.index, index, sideindex, shape.sides.length, shapes.length);
    }
}
function drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type) {
    if (drawmode == 2) {
        let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
        let eclass = 'shapecornerblue';
        let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;       
        let cpath = "M" + x1 + "," + y1 + " l" + (x2 - x1) + "," + (y2 - y1);
        cpath += " l" + (x3 - x2) + "," + (y3 - y2) + "z";       
        //console.log(lnindex,index, sideindex, sidecode, x1, y1, x2, y2, cornerindex);
        let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
        if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
        let cornerpath = cornerg.select("#corner" + index);
        if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + index); }
        cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        if (smode == 'shape') { cornerpath.on("click", onshapesidecorner); }
    }
}
function drawshapecornerline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
   //let etypes = [];
    //if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let eclass = type == 0 ? 'shapesidewhite' : sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, cornerindex, eclass ,edgetype);
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let clineindex = shape.index + "" + sideindex + "" + sidecode + "" + index + "" + lnindex;
    let cornerline = cornerg.select("#corner" + clineindex);
    if (cornerline.empty()) { cornerline = cornerg.append("line").attr("id", "corner" + clineindex); }
    cornerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("lnindex", lnindex).attr("index", index).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    if (type != 0) {
        cornerline.attr("type", type);
        if (smode == 'shape') { cornerline.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
    }

}
function drawshapecornernotchpath(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;    
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;    
    let cpath = "M" + x1 + "," + y1 + " l" + (x2 - x1) + "," + (y2 - y1);
    cpath += " l" + (x4 - x2) + "," + (y4 - y2) + " l" + (x3 - x4) + "," + (y3 - y4) + "z";
    //  console.log(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, edgetype, type);
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex)
        .attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("edgetype", edgetype).attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");   
    if (smode == 'shape') { cornerpath.on("click", onshapesidecorner).on("contextmenu", onshapesidecornercontextmenu); }
}
function drawshapecornerbumpoutpath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = 'sideshape';
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cpath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    cpath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");     
    if (smode == 'shape') { cornerpath.on("click", onshapesidecorner).on("contextmenu", onshapesidecornercontextmenu);}
}
function drawshapecornerarcpath(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;   
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cpath = "";
    //cpath = quadraticcurvepath(x2, y2, x1, y1, x3, y3);
    if (shape.sides.length == 1) {
        let swflag = 1; if (index == 0 || index == 3) { swflag = 0; }
        cpath = quadraticcurvepath1(x2, y2, x3, y3, r, 0, 0, swflag);
    } else { cpath = quadraticcurvepath(x2, y2, x1, y1, x3, y3); }

    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    cornerpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (smode == 'shape') { cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
}
function drawshapecornerarcpath1(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, lx1, ly1, lx2, ly2, t1, t2, cw, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    //let etypes = [];
    //if (edgetype != '' && edgetype != null) { etypes = edgetype.split(':'); edgetype = etypes[0]; }
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cpath = quadraticcurvesplitpath33(x3, y3, x1, y1, x2, y2, lx1, ly1, t1, t2, cw, 'drawshapecornerarcpath1');
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype, type);
    cornerpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (smode == 'shape') { cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
}
function drawshapecornermarkertext(index, sideindex, sidecode, mtx, mty, mtext, type) {
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    let sidecornertext = cornerg.select("#sidecornertext" + cornerindex);
    let mtextlen = 0;
    if (sidecornertext.empty()) { sidecornertext = cornerg.append("text").attr("id", "sidecornertext" + cornerindex).attr("class", "shapemarker"); }    
    if (type == 3 || type == 4) {
        if (cornerg.node() != null) {
            let cornergnode = cornerg.node().getBBox(), w = cornergnode.width, h = cornergnode.height;
            mtx = cornergnode.x + w / 2, mty = cornergnode.y + h / 2;
            sidecornertext.attr("x", (mtx)).attr("y", mty).text(mtext);
            mtextlen = sidecornertext.node().getComputedTextLength();
        }
        sidecornertext.attr("x", (mtx - (mtextlen / 2))).attr("y", mty).text(mtext);
    } else { sidecornertext.attr("x", (mtx)).attr("y", mty).text(mtext); }
    let angle1 = shape.angle;
    // console.log(index, code, mtx, mty, mtext, angle, angle1);
    sidecornertext.attr("transform", "rotate(" + -angle1 + "," + [mtx, mty] + ")");
}
function showshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    if (type == 0) { d3.select(this).attr("class", "shapecornerblue"); }
    else { d3.select(this).attr("class", "shapesideblue"); }
}
function hideshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    let edgetype = this.getAttribute("edgetype");   
    if (type == 0) { d3.select(this).attr("class", "shapecorner"); }
    else { d3.select(this).attr("class", sideedgeclass(edgetype)); }
}
function removeshapecorners(type, source) {   
    if (shape!=undefined && shape.sides == undefined) { return;}
    for (let j = 0; j < shape.sides.length; j++) {
        removeshapesidecorners(j, type, shape.index);
    }
}
function removeshapesidecorners(sideindex, type, sindex) {   
    let side = shape.sides[sideindex];   
    for (let j = 0; j < side.corners.length; j++) {
        if (side.corners[j].type == type) {
            removeshapesidecorner(j, sideindex, sindex);
        }
    }
}
function removeshapesidecorner(index, sideindex, sindex) {  
    let side = shape.sides[sideindex];
    let corner = side.corners[index];   
    corner.w = corner.h = cornerwh;
    corner.r = Math.round(calchyplen1(cornerwh, cornerwh));
  //  console.log(index, sideindex, sindex, corner.sidecode);
    let cornerindex = "#shapecornerg" + sindex + "" + sideindex + "" + corner.sidecode + "" + index;  
    $(cornerindex).remove();
}
function onfocusinputcontrol32(objinputctrl) { 
    objinputctrl.select();
}
function getshapesidecornerpath32(index, sideindex) {
    let side = shape.sides[sideindex];
    let cpath = '';
    if (side != undefined) {
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let corner = side.corners[index];
        let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1,
        type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
        if (corner.edges == undefined) { initcorneredges(corner); }
        let edgetype1 = corner.edges[0].type, edgetype2 = corner.edges[1].type, edgetype3 = corner.edges[2].type, edgetype4 = corner.edges[3].type, edgetype5 = corner.edges[3].type;        
        if (type == 1) {  //Clip corner   
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                    if (index == 0) {
                        x3 = sx1, y3 = sy1, x11 = sx1, y11 = sy1;
                    } else if (index == 1) {
                        x3 = sx1, y3 = sy1, x21 = sx1, y21 = sy1;
                    } else if (index == 2) {
                        x2 = sx1, y2 = sy1, x12 = sx1, y12 = sy1;
                    } else if (index == 3) {
                        x2 = sx1, y2 = sy1, x22 = sx1, y22 = sy1;
                    }
                }
                cpath = "M" + x2 + "," + y2;
                cpath += " l" + (x3 - x2) + "," + (y3 - y2);
            }
            else {               
                cpath = "M" + x2 + "," + y2;
                cpath += " l" + (x3 - x2) + "," + (y3 - y2);
            }
        }
        else if (type == 2) {//Curve corner
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    if (index == 0) {
                        //drawpointcircle(1, index, 1, 1, x21, y21, 10, 'A');
                        //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let angle = calclineangle2(x21, y21, x11, y11), asign = -1;
                        let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x21, y21, angle, asign, w, 'drawsidecorner32:0');
                        let etype = sideedgetype(sideindex, 0);
                        cpath = quadraticcurvesplitpath33(x3, y3, x1, y1, x2, y2, sx1, sy1, tfact, 1, w, 'drawshapecornerarcpath1');
                        //drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, sx1, sy1, x2, y2, tfact, 1, w, edgetype3, type);
                       // drawsideline(sideindex, 0, sx1, sy1, x21, y21, etype, 15);
                    } else if (index == 1) {
                        //drawpointcircle(1, index, 1, 1, x21, y21, 10, 'A');
                        //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let angle = calclineangle2(x21, y21, x11, y11), asign = 1;
                        let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x11, y11, angle, asign, w, 'drawsidecorner32:0');
                        let etype = sideedgetype(sideindex, 0);
                        cpath = quadraticcurvesplitpath33(x3, y3, x1, y1, x2, y2, sx1, sy1, tfact, 1, w, 'drawshapecornerarcpath1');
                        //drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, sx1, sy1, x2, y2, tfact, 1, w, edgetype3, type);
                        //drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);
                    } else if (index == 2) {
                        //drawpointcircle(1, index, 1, 1, x22, y22, 10, 'A');
                        //drawpointcircle(2, index, 1, 1, x12, y12, 10, 'U');
                        //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let angle = calclineangle2(x22, y22, x12, y12), asign = -1;
                        let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x22, y22, angle, asign, w, 'drawsidecorner32:2');
                        let etype = sideedgetype(sideindex, 2);
                        cpath = quadraticcurvesplitpath33(x3, y3, x1, y1, x2, y2, sx1, sy1, 0, tfact, w, 'drawshapecornerarcpath1');
                        //drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x3, y3, sx1, sy1, 0, tfact, w, edgetype3, type);
                        //drawsideline(sideindex, 3, sx1, sy1, x22, y22, etype, 15);
                    } else if (index == 3) {
                        //drawpointcircle(1, index, 1, 1, x22, y22, 10, 'A');
                        //drawpointcircle(2, index, 1, 1, x12, y12, 10, 'U');
                        //drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'U');
                        let angle = calclineangle2(x22, y22, x12, y12), asign = 1;
                        let tfact = calccurveinterecttfact32(x3, y3, x1, y1, x2, y2, x12, y12, angle, asign, w, 'drawsidecorner32:3');
                        let etype = sideedgetype(sideindex, 3);
                        cpath = quadraticcurvesplitpath33(x3, y3, x1, y1, x2, y2, sx1, sy1, 0, tfact, w, 'drawshapecornerarcpath1');
                        //drawshapecornerarcpath1(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x3, y3, sx1, sy1, 0, tfact, w, edgetype3, type);
                        //drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);
                    }
                }
            } else {              
                if (shape.sides.length == 1) {
                    let swflag = 1; if (index == 0 || index == 3) { swflag = 0; }
                    cpath = quadraticcurvepath1(x2, y2, x3, y3, r, 0, 0, swflag);
                } else { cpath = quadraticcurvepath(x2, y2, x1, y1, x3, y3); }               
            }
        }
        else if (type == 3) {//Notch corner        
            //console.log('shapeindex:' + shape.index, 'sideindex:' + sideindex, 'cornerindex:' + index, 'cornertype:' + type, 'cornerseam:' + sx1 + ',' + sy1, 'cornerseamsplit:' + issplit, 'cornerseamindex:' + cornerseamindex, source);           
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    let x4 = 0, y4 = 0, asign = -1;
                    let angle1 = calclineangle2(x1, y1, x2, y2);
                    let npt1 = rotate_point1(x3, y3, asign, angle1, w);
                    x4 = npt1.dx, y4 = npt1.dy;
                    let angle2 = calclineangle2(x3, y3, sx1, sy1);
                    let angle3 = calclineangle2(x2, y2, x4, y4);
                    let angle4 = calclineangle2(x2, y2, sx1, sy1);
                    // console.log(index, angle1, angle2, angle3, angle4);                    
                    //if (index == 0) {
                    //    // drawpointcircle(1, index, 1, 1, sx1, sy1, 10, 'F');                       
                    //    let etype = sideedgetype(sideindex, 0);
                    //    if (angle1 == angle2) {
                    //        cpath = "M" + x2 + "," + y2 + "l" + (x4 - x2) + "," + (y4 - y2) + "l" + (sx1 - x4) + "," + (sy1 - y4);
                    //        //drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x4, y4, edgetype3, type);
                    //        //drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                    //    } else {
                    //        cpath = "M" + x2 + "," + y2 + "l" + (sx1 - x2) + "," + (sy1 - y2);
                    //       // drawshapecornerline(2, index, sideindex, sidecode, x2, y2, sx1, sy1, edgetype3, type);
                    //    }
                    //    cpath += "l" + (x21 - sx1) + "," + (y21 - sy1) + "z";
                    //    //drawsideline(sideindex, 0, sx1, sy1, x21, y21, etype, 15);
                    //} else if (index == 1) {
                    //    // drawpointcircle(1, index, 1, 1, sx1, sy1, 10, 'F');
                    //    if (angle1 == angle2) {
                    //        cpath = "M" + x2 + "," + y2 + "l" + (x4 - x2) + "," + (y4 - y2) + "l" + (sx1 - x4) + "," + (sy1 - y4);
                    //        //drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x4, y4, edgetype3, type);
                    //        //drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                    //    } else {
                    //        cpath = "M" + x2 + "," + y2 + "l" + (sx1 - x2) + "," + (sy1 - y2) + "z";
                    //        //drawshapecornerline(2, index, sideindex, sidecode, x2, y2, sx1, sy1, edgetype3, type);
                    //    }
                    //    cpath += "l" + (sx1 - sx1) + "," + (y21 - sy1) + "z";
                    //   // drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, edgetype3, type);
                    //} else if (index == 2) {
                    //    //drawpointcircle(2, index, 1, 1, sx1, sy1, 10, 'A');                        
                    //    let etype = sideedgetype(sideindex, 2);
                    //    if (angle1 == angle2) {
                    //        drawshapecornerline(2, index, sideindex, sidecode, x3, y3, sx1, sy1, edgetype3, type);
                    //    } else {
                    //        drawshapecornerline(2, index, sideindex, sidecode, x3, y3, x4, y4, edgetype3, type);
                    //        drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                    //    }
                    //    drawsideline(sideindex, 3, sx1, sy1, x22, y22, etype, 15);
                    //} else if (index == 3) {
                    //    let etype = sideedgetype(sideindex, 2);
                    //    // drawpointcircle(3, index, 1, 1, sx1, sy1, 10, 'A');                                 
                    //    if (angle1 == angle2) {
                    //        drawshapecornerline(2, index, sideindex, sidecode, x3, y3, sx1, sy1, edgetype3, type);
                    //    } else {
                    //        drawshapecornerline(2, index, sideindex, sidecode, x3, y3, x4, y4, edgetype3, type);
                    //        drawshapecornerline(3, index, sideindex, sidecode, x4, y4, sx1, sy1, edgetype3, type);
                    //    }
                    //   // drawshapecornerline(4, index, sideindex, sidecode, x1, y1, sx1, sy1, etype, type);
                    //}
                    cpath = "M" + x2 + "," + y2 + "l" + (x4 - x2) + "," + (y4 - y2) + "l" + (x3 - x4) + "," + (y3 - y4) + "z";
                }
            } else {
                let x4 = 0, y4 = 0, asign = -1;
                let angle = calclineangle2(x1, y1, x2, y2);
                let npt1 = rotate_point1(x3, y3, asign, angle, w);
                x4 = npt1.dx, y4 = npt1.dy;                
                cpath = "M" + x2 + "," + y2 + "l" + (x4 - x2) + "," + (y4 - y2);
                cpath += "l" + (x3 - x4) + "," + (y3 - y4)  + "z";
            }
        }
        else if (type == 4) {//Bumpout corner  
            if (shape.mode == 'slabpart' && issplit == 1) {
                if (sx1 != undefined && sy1 != undefined) {
                    let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
                    let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
                    let dx1 = npt1.dx, dy1 = npt1.dy;
                    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                    let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;
                    let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
                    let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
                    let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));
                    if (angle1 != angle2) {
                        npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
                        dx1 = npt1.dx, dy1 = npt1.dy;
                        sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                    }
                    if (index == 0) {
                        x11 = sx1, y11 = sy1, sx22 = sx1, sy22 = sy1;
                        let ipt1 = calintersection1(x11, y11, x21, y21, sx11, sy11, sx12, sy12);
                        sx12 = ipt1.dx, sy12 = ipt1.dy;                      
                    } else if (index == 1) {
                        x21 = sx1, y21 = sy1, sx22 = sx1, sy22 = sy1;                     
                    } else if (index == 2) {
                        x12 = sx1, y12 = sy1, sx21 = sx1, sy21 = sy1;
                        let ipt1 = calintersection1(x12, y12, x22, y22, sx11, sy11, sx12, sy12);
                        sx11 = ipt1.dx, sy11 = ipt1.dy;                      
                    } else if (index == 3) {
                        x22 = sx1, y22 = sy1, sx21 = sx1, sy21 = sy1;                     
                    }                   
                    cpath = "M" + sx11 + "," + sy11 + "l" + (sx12 - sx11) + "," + (sy12 - sy11);
                    cpath += "l" + (sx22 - sx12) + "," + (sy22 - sy12) + "l" + (sx21 - sx22) + "," + (sy21 - sy22) + "z";                    
                }
            } else {
                let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
                let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
                let dx1 = npt1.dx, dy1 = npt1.dy;
                sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;
                let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
                let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
                let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));
                if (Math.abs(angle1 - angle2) > 10) {
                    npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
                    dx1 = npt1.dx, dy1 = npt1.dy;
                    sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
                }                
                cpath = "M" + sx11 + "," + sy11 + "l" + (sx12 - sx11) + "," + (sy12 - sy11);
                cpath += "l" + (sx22 - sx12) + "," + (sy22 - sy12) + "l" + (sx21 - sx22) + "," + (sy21 - sy22) + "z";
                console.log(cpath);
            }
        }
    }
    return cpath;
}