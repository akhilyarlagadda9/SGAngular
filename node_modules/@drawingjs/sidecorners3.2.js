function initsidecorners(sideindex) {
    let side = shape.sides[sideindex];
    side.corners.push(initsidecorner(0, sideindex, 1));
    side.corners.push(initsidecorner(1, sideindex, 2));
    side.corners.push(initsidecorner(2, sideindex, 3));
    side.corners.push(initsidecorner(3, sideindex, 3));   
}
function initsidecorner(index, sideindex, sidecode) {
    let edgetype = sideedgetype(sideindex, sidecode);
    let cr = Math.round(calchyplen1(cornerwh, cornerwh));    
    let corner = { index: index, sideindex: sideindex, sidecode: sidecode, sindex: shape.index, type: 0, w: cornerwh, h: cornerwh, r: cr, angle: 90, typeid: 0, edgetype: edgetype, edgetypeid: 0, edgeheight: 0, edges: [] };
    initcorneredges(corner, edgetype);
    return corner;
}
function initcorneredges(corner, edgetype) {
    let edges = [];
    edges.push(initcorneredge(0, corner.sideindex, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(1, corner.sideindex, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(2, corner.sideindex, 0, edgetype, 0, edgetype));
    edges.push(initcorneredge(3, corner.sideindex, 0, edgetype, 0, edgetype));
    edges.push(initcorneredge(4, corner.sideindex, 0, edgetype, 0, edgetype));
    corner.edges = edges;
}
function initcorneredge(index, sideindex, sidecode, type, typeid, text) {
    let edge = { index: index, sideindex: sideindex, sidecode: sidecode, type: type, typeid: typeid, text: text, width:0, height:0 };
    return edge;
}
function sidecornerindex(sideindex, x1, y1) {
    let cindex = -1;
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.corners.length; i++) {       
        if (side.corners[i].x1 == x1 && side.corners[i].y1 == y1) { cindex = i; break; }
    }
    return cindex;
}
function setsidecorners32(sideindex,source) {
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.corners.length; i++) {
        setsidecorner32(i, sideindex, i, side.corners[i].type, side.corners[i].typeid, source + ':setsidecorners32');
    }
}
function setsidecorner32(index, sideindex, sidecode, type, typeid, source) {
    //type id: 10 - radius, 8-clip, 7-bump out, 9- Notch
    //type: 1-clip, 2- radius, 3- Notch, 4- Bumpout
 //   console.log(index, sideindex, sidecode, type, typeid, source);
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    if (corner == undefined) { corner = initsidecorner(index, sideindex, sidecode); }   
    let w = corner.w, h = corner.h, r = corner.r, edgetype = corner.edgetype;
    if (typeid == undefined) {
        typeid = type;       
        if (type == 1) { corner.r = calchyplen1(applymminchfact(w, 2, 2, source), applymminchfact(h, 2, 2, source)); }
      //  resetsidecorner32(index, sideindex, w, h, r, type, typeid, source);
    }    
    //console.log(index, sideindex, sidecode, type, typeid, w, h, r, applymminchfact(w, 2, 2, source), applymminchfact(h, 2, 2, source), applymminchfact(r, 2, 2, source));
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let x1 = x11, y1 = y11, x2 = x12, y2 = y12, x3 = x21, y3 = y21;
    if (index == 0) { x1 = x11, y1 = y11, x2 = x12, y2 = y12, x3 = x21, y3 = y21; }
    else if (index == 1) { x1 = x21, y1 = y21, x2 = x22, y2 = y22, x3 = x11, y3 = y11; }
    else if (index == 2) { x1 = x12, y1 = y12, x2 = x11, y2 = y11, x3 = x22, y3 = y22; }
    else if (index == 3) { x1 = x22, y1 = y22, x2 = x21, y2 = y21, x3 = x12, y3 = y12; }
    //if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
    if (sideindex > 0) { let side1 = shape.sides[sideindex - 1]; if (sidecode == 1) { x3 = side1.x11, y3 = side1.y11; } else if (sidecode == 2) { x3 = side1.x21, y3 = side1.y21; } }
    let npt1 = calclinepoint(x1, y1, x2, y2, w);
    x2 = npt1.dx, y2 = npt1.dy;
    let npt2 = calclinepoint(x1, y1, x3, y3, h);
    x3 = npt2.dx, y3 = npt2.dy;
    corner.type = type, corner.typeid = typeid, corner.sideindex = sideindex, corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;
}
function onsetsidecorner(index, sideindex, type, typeid, source) {
    source += ":onsetsidecorner";
    let side = shape.sides[sideindex];
    let corner = side.corners[index], sidecode = corner.sidecode;
    if (corner.type == type) { return; }   
    if (corner.type != 0) {corner.w = corner.r = corner.h; }
    //let edgetype = sideedgetype(sideindex, sidecode);
    //console.log("index:" + index, "sideindex:" + sideindex, "type:" + type, "typeid:" + typeid, "ctype:" + corner.type);
    removeshapesidecorner(index, sideindex, shape.index);
    setsidecorner32(index, sideindex, sidecode, type, typeid, source);
    //setsidecorneredges(index, sideindex, edgetype, edgetypeid, source);
    drawsidecorner32(index, sideindex, source);  
    onsetcornerseam32(index, sideindex);
    resetshapesplashs(source);
    drawshapesides32(source);    
    ActionCorner(source);
}
function onsetcornertype(sindex) {
    //1. highlight shape corners to click corner and set corner type.    
    drawshapecorners(sindex, 'onsetcornertype');
}
function onsetsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, source) {
    source += ":onsetsidecorneredge";
    //console.log("lnindex:" + lnindex, "index:" + index, "sideindex:" + sideindex, "edgetype:" + edgetype, "edgetypeid:" + edgetypeid, source);
    setsidecorneredges(index, sideindex, edgetype, edgetypeid, source);
    drawsidecorner32(index, sideindex, source);
    ActionCorner(source);
}
function setsidecorneredges(index, sideindex, edgetype, edgetypeid, source) {
    //console.log(index, sideindex, edgetype, edgetypeid, source);
    //0,1 - white line corner line edges
    source += ":setsidecorneredges";
    setsidecorneredge(2, index, sideindex, edgetype, edgetypeid, source);
    setsidecorneredge(3, index, sideindex, edgetype, edgetypeid, source);
    setsidecorneredge(4, index, sideindex, edgetype, edgetypeid, source);
}
function setsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, source) {
    source += ":setsidecorneredge";
    let side = shape.sides[sideindex];
    let corner = side.corners[index], sidecode = corner.sidecode;
    if (corner.edges == undefined) { initcorneredges(corner); }
    let corneredge = corner.edges[lnindex];    
    corneredge.sideindex = sideindex, corneredge.type = edgetype, corneredge.typeid = edgetypeid, corneredge.text = edgetype;    
    //drawsidecorner32(index, sideindex, source);
}
function onshapesidecorner() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    let mode = this.getAttribute("smode");
    let lnindex = parseInt(this.getAttribute("lnindex"));
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let spindex = parseInt(this.getAttribute("spindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));   
    setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecorner');
    if (drawmode == 2) {
        onsetsidecorner(index, sideindex, cornertype, cornertypeid, 'onshapesidecorner');
    } else if (drawmode == 4) {
        onsetcornersplash(lnindex, index, sideindex, sidecode, edgetype, edgetypeid, 2, 'onshapesidecorner');
    } else if (drawmode == 5) {
        let lnindex = this.getAttribute("lnindex");
       // console.log(lnindex, index, sideindex, cornertype, drawmode);
        if (lnindex != undefined) {
            onsetsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, 'onshapesidecorner');
        }
    }
}
function onshapesidecornercontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode == 'shape') {
        let mode = this.getAttribute("smode");
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let spindex = parseInt(this.getAttribute("spindex"));
        let partsrno = parseInt(this.getAttribute("partsrno"));
        let areaid = parseInt(this.getAttribute("areaid"));
        setdrawshape31(sindex, partsrno, areaid, mode, 'onshapesidecornercontextmenu');
        drawshapesidecornercontrols(index, sideindex, m[0], m[1]);
    }
}
function resetsidecorner32(index, sideindex, w, h, r, type, typeid, source) {
    //type id: 10 - radius, 8-clip, 7-bump out, 9- Notch
    //type: 1-clip, 2- radius, 3- Notch, 4- Bumpout   
    source += ":resetsidecorner32";
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    corner.w = w, corner.h = h, corner.r = r, sidecode = corner.sidecode, corner.type = type; corner.typeid = typeid;    
    setsidecorner32(index, sideindex, sidecode, type, typeid, source);
    drawsidecorner32(index, sideindex, source);
    onsetcornerseam32(index, sideindex);
    drawshapesides32(source);
}
function resetsidecorners32(w, h, r, type, typeid, source) {
    for (i = 0; i < shape.sides.length; i++) {
        for (j = 0; j < shape.sides[i].corners.length; j++) {
            resetsidecorner32(j, i, w, h, r, type, typeid, source);
        }
    }
    resetshapesplashs(source); ActionCorner(source);
}
function onresizesidecorner(obj, changetype, index, sideindex) {    
    let source = 'onresizesidecorner';
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let objVal = obj.value.split(" ");
    let whr = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    let isvalid = true;
    if (isNaN(whr)) { isvalid = false; }
    //console.log(index, sideindex, changetype, whr, corner.type, changetype);
    if (whr > 0) {
        if (corner.type == 4 && changetype == 3) {
            isvalid = true;
        }else if (changetype == 3) {
            if (!validatecornerchange32(index, sideindex, 1, calcsidelen(whr))) { isvalid = false; }
            if (!validatecornerchange32(index, sideindex, 2, calcsidelen(whr))) { isvalid = false; }
        } else {
            if (!validatecornerchange32(index, sideindex, changetype, whr)) { isvalid = false; }
        }        
    } else { isvalid = false;}
    if (!isvalid) { $('#shapectlerrormsg' + index).attr("style", "color:red;display:block;"); } else { $('#shapectlerrormsg' + index).attr("style", "display:none;"); }
    if (isvalid) {
        let ncw = applymminchfact(corner.w, 2, 2, source), nch = applymminchfact(corner.h, 2, 2, source), ncr = applymminchfact(corner.r, 2, 2, source), ctype = corner.type, ctypeid = corner.typeid;
        if (changetype == 1) {
            if (ctype == 1) {
                ncr = calchyplen1(whr, nch);
                $('#shapectlinputdepth' + index).val(decimaltofraction(ncr));
            }           
            ncw = whr;
            if (ctype == 4) { nch = ncw; }
        } else if (changetype == 2) {
            if (ctype == 1) {
                ncr = calchyplen1(ncw, whr);
                $('#shapectlinputdepth' + index).val(decimaltofraction(ncr));
            }           
            if (ctype == 4) { ncr = whr; } else { nch = whr; }
        }
        else if (changetype == 3) {
            if (ctype == 1 || ctype == 2) {
                ncw = nch = calcsidelen(whr);
                $('#shapectlinputwidth' + index).val(decimaltofraction(ncw));
                $('#shapectlinputheight' + index).val(decimaltofraction(nch));
            }
            ncr = whr;
        }       
        ncw = applymminchfact(ncw, 1, 2, source);
        nch = applymminchfact(nch, 1, 2, source);
        ncr = applymminchfact(ncr, 1, 2, source);
        //console.log(index, sideindex, ncw, nch, ncr);        
        resetsidecorner32(index, sideindex, ncw, nch, ncr, ctype, ctypeid, source);
        ActionCorner(source);
        resetshapesplashs(source);
        drawshapesides32(source);       
    }
}
function validatecornerchange32(index, sideindex, changetype, whr, source) {
    //1. sides 
    let side = shape.sides[sideindex];
    let isvalid = true, w1 = side.w1, w2 = side.w2, h = applymminchfact(side.h, 2, 2), whr1 = 0;
    if (index == 0) {
        if (changetype == 1) {
            if (sideindex == shape.sides.length - 1) {//second side corner index = 2
                if (side.corners[2].type != 0) { whr1 = applymminchfact(side.corners[2].w, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex + 1].corners[0].type != 0) { whr1 = applymminchfact(shape.sides[sideindex + 1].corners[0].h, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            }
        } else if (changetype == 2) {
            if (sideindex == 0) {//second side corner index = 2
                if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].h, 2, 2, source); }
                if ((whr + whr1) > h) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex - 1].corners[0].type != 0) { whr1 = applymminchfact(shape.sides[sideindex - 1].corners[0].w, 2, 2, source); }
                if ((whr + whr1) > w1) { isvalid = false; }
            }
        }
    } else if (index == 1) {
        if (changetype == 1) {
            if (sideindex == shape.sides.length - 1) {//second side corner index = 3
                if (side.corners[3].type != 0) { whr1 = applymminchfact(side.corners[3].w, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            } else { //second side corner index = 1
                if (shape.sides[sideindex + 1].corners[1].type != 0) { whr1 = applymminchfact(shape.sides[sideindex + 1].corners[1].h, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            }
        } else if (changetype == 2) { //second side corner index = 1
            if (sideindex == 0) {//second side corner index = 2
                if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].h, 2, 2, source); }
                if ((whr + whr1) > h) { isvalid = false; }
            } else { //second side corner index = 2
                if (shape.sides[sideindex - 1].corners[1].type != 0) { whr1 = applymminchfact(shape.sides[sideindex - 1].corners[1].w, 2, 2, source); }
                if ((whr + whr1) > w2) { isvalid = false; }
            }
        }
    } else if (index == 2) {
        if (changetype == 1) {//second side corner index = 0
            if (side.corners[0].type != 0) { whr1 = applymminchfact(side.corners[0].w, 2, 2, source); }
            if ((whr + whr1) > w1) { isvalid = false; }
        } else if (changetype == 2) {//second side corner index = 3
            if (side.corners[3].type != 0) { whr1 = applymminchfact(side.corners[3].h, 2, 2, source); }
            if ((whr + whr1) > h) { isvalid = false; }
        }
    } else if (index == 3) {
        if (changetype == 1) {//second side corner index = 1
            if (side.corners[1].type != 0) { whr1 = applymminchfact(side.corners[1].w, 2, 2, source); }
            if ((whr + whr1) > w2) { isvalid = false; }
        } else if (changetype == 2) {//second side corner index = 2
            if (side.corners[2].type != 0) { whr1 = applymminchfact(side.corners[2].h, 2, 2, source); }
            if ((whr + whr1) > h) { isvalid = false; }
        }
    }
   // console.log("index:" + index, "sideindex:" + sideindex, "changetype:" + changetype, "w1:" + w1, "w2:" + w2, "h:" + h, "whr:" + whr, "whr1:" + whr1, "whr + whr1:" + (whr + whr1), "isvalid:" + isvalid);
    return isvalid;   
}
function resetsidecorner34(index, sideindex) {
    let source = 'resetsidecorner34';
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let ncw = applymminchfact(corner.w, 2, 2, source), nch = applymminchfact(corner.h, 2, 2, source), ncr = applymminchfact(corner.r, 2, 2, source), ctype = corner.type, ctypeid = corner.typeid;
    if (ctype == 1) {
        ncw = nch = calcsidelen(ncr);
    }
    ncw = applymminchfact(ncw, 1, 2, source);
    nch = applymminchfact(nch, 1, 2, source);
    ncr = applymminchfact(ncr, 1, 2, source);
    corner.w = ncw, corner.h = nch, corner.r = ncr;
    //console.log(index, sideindex, ncw, nch, ncr);
   // resetsidecorner32(index, sideindex, ncw, nch, ncr, ctype, ctypeid, source);      
}
function resetshapecorners(source) {
    for (i = 0; i < shape.sides.length; i++) {
        onsidechangeresetcorners(i,source);
    }
}
function resetshapecorners34(source) {
    source += ':resetshapecorners34';
    for (i = 0; i < shape.sides.length; i++) {
        onsidechangeresetcorners34(i, source);
    }
}
function onsidechangeresetcorners34(sideindex, source) {
    source += ':onsidechangeresetcorners34';
    let side = shape.sides[sideindex];
    for (j = 0; j < 2; j++) {
        setsidecorner32(j, sideindex, side.corners[j].sidecode, side.corners[j].type, side.corners[j].typeid, source);
        //setsidecorneredges(j, sideindex, side.corners[j].edgetype, side.corners[j].typeid, source);        
    }
}
function onsidechangeresetcorners(sideindex, source) {
    source += ':onsidechangeresetcorners';
    let side = shape.sides[sideindex];
    for (j = 0; j < 2; j++) {
        setsidecorner32(j, sideindex, side.corners[j].sidecode, side.corners[j].type, side.corners[j].typeid, source);
        //setsidecorneredges(j, sideindex, side.corners[j].edgetype, side.corners[j].typeid, source);
        //drawsidecorner32(j, sideindex);
    }
}
function onresizesetallsidescorners(index, sideindex) {
    let source = 'onresizesetallsidescorners';
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let ncw = corner.w, nch = corner.h, ncr = corner.r, ctype = corner.type, ctypeid = corner.typeid;
    if (ctype == 4) {
        let objrVal = $('#shapectlinputdepth' + index).val().split(" ");
        let cr = parseFloat(fractionToDecimal(objrVal[0])) + parseFloat(fractionToDecimal(objrVal[1]));
        ncr = applymminchfact(cr, 1, 2, source);
    }   
    let isupdate = false;
    for (i = 0; i < shape.sides.length; i++) {
        for (j = 0; j < shape.sides[i].corners.length; j++) {
            if (j == index && sideindex == i){}else{         
                if (shape.sides[i].corners[j].type == ctype) {
                    let ncw1 = shape.sides[i].corners[j].w; nch1 = shape.sides[i].corners[j].h, ncr1 = shape.sides[i].corners[j].r;
                   // console.log("index:" + j, "sideindex:" + i, "changetype:width", "ncw:" + ncw, "ncw1:" + ncw1, "nch:" + nch, "nch1:" + nch1);
                    if (validatecornerchange32(j, i, 1, applymminchfact(ncw, 2, 2, source))) { ncw1 = ncw; isupdate = true; }
                    if (validatecornerchange32(j, i, 2, applymminchfact(nch, 2, 2, source))) { nch1 = nch; isupdate = true; }
                    if (ctype == 1) { ncr1 = calchyplen1(ncw1, applymminchfact(nch1, 2, 2, source));}
                    if (isupdate) { resetsidecorner32(j, i, ncw1, nch1, ncr1, ctype, ctypeid, source); }
                }
            }
        }
    }
    if (isupdate) {
        resetshapesplashs(source); ActionCorner(source);
        drawshapesides32(source);
    }
}
function ondeleteshapesidecorner(index, sideindex) {
    let source = 'ondeleteshapesidecorner';
    //console.log("index:" + index, "sideindex:" + sideindex, source);
    onsetsidecorner(index, sideindex, 0, 0, source);
    removeshapecontrols();
}
function drawshapecorners(index, source) {  
    if (shape != undefined && shape.sides!=null) {
        for (let j = 0; j < shape.sides.length; j++) {
            drawsidecorners(j, source);
        }
    }
}
function drawsidecorners(sideindex, source) {
    source += ':drawsidecorners';
    let side = shape.sides[sideindex];
    if (side.corners.length == 2) {
        side.corners.push(initsidecorner(2, sideindex, 3));
        side.corners.push(initsidecorner(3, sideindex, 4));
    }
    for (let i = 0; i < side.corners.length; i++) {       
        if (shape.mode != 'slabpart') {
            //resetsidecorner34(i, sideindex);
            setsidecorner32(i, sideindex, side.corners[i].sidecode, side.corners[i].type, side.corners[i].typeid, source);
        }
        drawsidecorner32(i, sideindex, source);
    }
}
function setsidecornereampos32(index, sideindex, sidecode) {
    //console.log(index, sideindex, sidecode, cx1, cy1, cx2, cy2, cx3, cy3, cw, shape.sides.length);
    let side = shape.sides[sideindex];
    let dx = 0, dy = 0, issplit = 0, seamline = 0, smtype = 0, seamheight = 0, tfact = 0;
    for (let j = 0; j < side.seams.length; j++) {
        let seam = side.seams[j];
        if (seam.isactive == 1) {
            let x1 = seam.x1, y1 = seam.y1, x2 = seam.x2, y2 = seam.y2, sx1 = seam.sx1, sy1 = seam.sy1, sx2 = seam.sx2, sy2 = seam.sy2;
            issplit = seam.split, smtype = seam.type;
            //console.log(j, smtype, sidecode, x1, y1, x2, y2, seam.split, side.seams.length);
            if (smtype == 2 && issplit == 1) {
                //drawpointcircle(10, index, 1, 1, seam.sx1, seam.sy1, 10, 'A');
                //drawpointcircle(11, index, 1, 1, seam.sx2, seam.sy2, 10, 'A');
                // if (index == 0) { cx3 = seam.sx1, cy3 = seam.sy1; } else if (index == 2) { cx2 = seam.sx1, cy2 = seam.sy1; }
                dx = seam.sx1, dy = seam.sy1;
            }
        }
    }
    return {
        dx: Math.round(dx), dy: Math.round(dy), seamsplit: issplit, seamline: seamline, smtype: smtype, seamheight: seamheight, tfact: tfact
    };
}
function drawsidecorner32(index, sideindex, source) {    
    let side = shape.sides[sideindex];
    if (side != undefined) {
        let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        let corner = side.corners[index];        
        let x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, sx1 = corner.sx1, sy1 = corner.sy1,
        type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r, cornerseamindex = corner.seamindex, issplit = corner.split;
        if (corner.edges == undefined) { initcorneredges(corner); }
        let edgetype1 = corner.edges[0].type, edgetype2 = corner.edges[1].type, edgetype3 = corner.edges[2].type, edgetype4 = corner.edges[3].type, edgetype5 = corner.edges[4].type;
        //console.log('shapeindex:' + shape.index, 'sideindex:' + sideindex, 'cornerindex:' + index, 'cornertype:' + type, 'x1:' + x1, 'y1:' + y1, 'x2:' + x2 + 'y2:' + y2, 'x3:' + x3, 'y3:' + y3, source);
        //console.log('shapeindex:' + shape.index, 'sideindex:' + sideindex, 'cornerindex:' + index, 'cornertype:' + type, 'edgetype1:' + edgetype1, 'edgetype2:' + edgetype2, 'edgetype3:' + edgetype3, 'edgetype4:' + edgetype4, source);
        if (edgetype3 == undefined) { edgetype3 = linetxt;}
        if (type == 0) {//No corner           
            if (shape.mode == 'shape') {              
                if (x1 != undefined && y1 != undefined && x2 != undefined && y2 != undefined && x3 != undefined && y3 != undefined && drawmode == 2) {
                    if (index < 2) { drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type); }
                    else { if (sideindex == shape.sides.length - 1) { drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type); } }
                }
            }
        } 
        else if (type == 1) {  //Clip corner 
            let x4 = 0, y4 = 0, asign = -1;
            let angle = calclineangle2(x1, y1, x2, y2);
            let npt1 = rotate_point1(x3, y3, asign, angle, w);
            x4 = npt1.dx, y4 = npt1.dy;
            corner.edges[2].width = applymminchfact(calchyplen(x2, y2, x3, y3), 2, 2, source);          
            drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x3, y3, edgetype3, type);
            let mtext = "L " + decimaltofraction(applymminchfact(r, 2, 2, source));
            let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
            drawshapecornermarkertext(2, index, sideindex, sidecode, mtx, mty, mtext, "", type);           
            drawshapecornerlinepath34(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype3, type);
        }
        else if (type == 2) {//Curve corner
            let x4 = 0, y4 = 0, asign = -1;
            let angle = calclineangle2(x1, y1, x2, y2);
            let npt1 = rotate_point1(x3, y3, asign, angle, w);
            x4 = npt1.dx, y4 = npt1.dy;
            corner.edges[2].width = applymminchfact(r, 2, 2, source);
            drawshapecornerarcpath(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, w, edgetype3, type);
            let mtext = "R " + decimaltofraction(applymminchfact(r, 2, 2, source));
            let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
            drawshapecornermarkertext(2, index, sideindex, sidecode, mtx, mty, mtext, "", type);
            drawshapecornerlinepath34(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype3, type);
        }
        else if (type == 3) {//Notch corner        
            let x4 = 0, y4 = 0, asign = -1;
            let angle = calclineangle2(x1, y1, x2, y2);
            let npt1 = rotate_point1(x3, y3, asign, angle, w);
            x4 = npt1.dx, y4 = npt1.dy;
            corner.edges[2].width = applymminchfact(calchyplen(x2, y2, x4, y4), 2, 2, source);
            corner.edges[3].width = applymminchfact(calchyplen(x3, y3, x4, y4), 2, 2, source);           
            drawshapecornerline(2, index, sideindex, sidecode, x4, y4, x2, y2, edgetype3, type);
            drawshapecornerline(3, index, sideindex, sidecode, x3, y3, x4, y4, edgetype4, type);
            let mtext1 = decimaltofraction(applymminchfact(w, 2, 2, source)); mtext2 = decimaltofraction(applymminchfact(h, 2, 2, source));
            let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
            drawshapecornermarkertext(2, index, sideindex, sidecode, mtx, mty, mtext1, mtext2, type);
            drawshapecornernotchpath(2, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype3, type);
        }
        else if (type == 4) {//Bumpout corner  
            let sx11 = x2, sy11 = y2, sx12 = x3, sy12 = y3, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0, asign = -1, dsign = 1;
            let npt1 = calcTranslationExact1(r, x2, y2, x3, y3);
            let dx1 = npt1.dx, dy1 = npt1.dy;
            sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
            let x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2;
            let ipt = calintersection1(x23, y23, x1, y1, sx21, sy21, sx22, sy22);
            let angle1 = Math.floor(calclineangle2(x23, y23, x1, y1));
            let angle2 = Math.floor(calclineangle2(x23, y23, ipt.dx, ipt.dy));
            if (Math.abs(angle1 - angle2) > 10) {
                npt1 = calcTranslationExact1(-r, x2, y2, x3, y3);
                dx1 = npt1.dx, dy1 = npt1.dy;
                sx21 = x2 + dx1, sy21 = y2 + dy1, sx22 = x3 + dx1, sy22 = y3 + dy1;
            }
            corner.edges[2].width = applymminchfact(calchyplen(sx21, sy21, sx22, sy22), 2, 2, source);
            corner.edges[3].width = applymminchfact(calchyplen(sx11, sy11, sx21, sy21), 2, 2, source);
            corner.edges[4].width = applymminchfact(calchyplen(sx12, sy12, sx22, sy22), 2, 2, source);                   
            drawshapecornerline(2, index, sideindex, sidecode, sx22, sy22, sx21, sy21, edgetype3, type);
            drawshapecornerline(3, index, sideindex, sidecode, sx21, sy21, sx11, sy11, edgetype4, type);
            drawshapecornerline(4, index, sideindex, sidecode, sx12, sy12, sx22, sy22, edgetype5, type);            
            let mtext1 = decimaltofraction(applymminchfact(w, 2, 2, source)); mtext2 = decimaltofraction(applymminchfact(r, 2, 2, source));
            let mtx = (x2 + x3) / 2, mty = (y2 + y3) / 2;
            drawshapecornermarkertext(2, index, sideindex, sidecode, mtx, mty, mtext1, mtext2, type);
            drawshapecornerbumpoutpath(2, index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, edgetype3, type);
        }
    } else {
        //console.log(shape.index, index, sideindex, shape.sides.length, shapes.length);
    }
}
function drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type) {
    if (drawmode == 2) {
        let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
        let eclass = 'shapecornerblue';
        let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;
        let cpath = "M" + x1 + "," + y1 + " l" + (x2 - x1) + "," + (y2 - y1);
        cpath += " l" + (x3 - x2) + "," + (y3 - y2) + "z";
        let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
        if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
        let cornerpath = cornerg.select("#" + smode + "corner" + cornerindex);
        if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
        cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type)
            .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        if (smode == 'shape') { cornerpath.on("click", onshapesidecorner); }
    }
}
function drawshapecornerlinepath34(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index + "" + lnindex;
    let cpath = "M" + x2 + "," + y2 + " l" + (x4 - x2) + "," + (y4 - y2);
    cpath += " l" + (x3 - x4) + "," + (y3 - y4) + " l" + (x1 - x3) + "," + (y1 - y3) + "z";
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#" + smode + "corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", smode + "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex)
        .attr("scolor", shape.color).attr("edgetype", edgetype).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("edgetype", edgetype)      
        .attr("style", "fill:" + shape.color + ";fill-opacity:0;cursor:pointer;");
    if (smode == 'shape') {
        cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
    }
}
function drawshapecornerline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex, stwidth=15;
    let eclass = type == 0 ? 'shapesidewhite' : sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;   
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, cornerindex, eclass ,edgetype);
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }    
    let clineindex = cornerindex + "" + lnindex;
    let cornerline = cornerg.select("#" + smode + "corner" + clineindex);
    if (cornerline.empty()) { cornerline = cornerg.append("path").attr("id", smode + "corner" + clineindex); }   
    let angle = calclineangle2(x1, y1, x2, y2);   
    let cpath="";
    if (angle < 180) { cpath = "M" + x1 + "," + y1 + " l" + (x2 - x1) + "," + (y2 - y1); } else { cpath = "M" + x2 + "," + y2 + " l" + (x1 - x2) + "," + (y1 - y2); }   
    cornerline.attr("d", cpath).attr("class", eclass).attr("lnindex", lnindex).attr("index", index).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode)
    if (smode == 'shape') {
        cornerline.on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
        let cornerbandline = cornerg.select("#" + smode + "cornerband" + cornerindex);
        if (cornerbandline.empty()) { cornerbandline = cornerg.append("path").attr("id", smode + "cornerband" + cornerindex).on("click", onshapesidecorner); }
        cornerbandline.attr("d", cpath).attr("class", eclass).attr("lnindex", lnindex).attr("index", index).attr("sideindex", sideindex)
    .attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        cornerbandline.attr("scolor", shape.color).attr("stwidth", stwidth).attr("style", "stroke:" + shape.color + ";stroke-opacity:0.1;stroke-width:" + stwidth)
            .on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
    }
   // console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, cornerindex, eclass, edgetype, cornerg.empty(), angle, cpath);
}
function drawshapecornernotchpath(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, x4, y4, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex;
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;   
    let cpath = "M" + x2 + "," + y2 + " l" + (x4 - x2) + "," + (y4 - y2);
    cpath += " l" + (x3 - x4) + "," + (y3 - y4) + " l" + (x1 - x3) + "," + (y1 - y3); 
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#" + smode + "corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", smode + "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex).attr("scolor", shape.color).attr("edgetype", edgetype)
        .attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("edgetype", edgetype).attr("style", "fill:" + shape.color + ";fill-opacity:0;cursor:pointer;");
    if (smode == 'shape') {
        cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
    }
}
function drawshapecornerbumpoutpath(lnindex, index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex
    let eclass = 'sideshape';
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;   
    let cpath = "M" + x12 + "," + y12 + "l" + (x22 - x12) + "," + (y22 - y12);
    cpath += "l" + (x21 - x22) + "," + (y21 - y22) + "l" + (x11 - x21) + "," + (y11 - y21);  
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#" + smode + "corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", smode + "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("lnindex", lnindex).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("scolor", shape.color).attr("edgetype", edgetype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode).attr("style", "fill:" + shape.color + ";fill-opacity:0.2;cursor:pointer;");
    if (smode == 'shape') {
        cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);       
    }
}
function drawshapecornerarcpath(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex, stwidth = 15;
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;
    let cpath = "";
    //console.log(sindex, lnindex, index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype, type)
    //cpath = quadraticcurvepath(x2, y2, x1, y1, x3, y3);
    if (shape.sides.length == 1) {
        let swflag = 0; if (index == 0 || index == 3) { swflag = 1; }
        cpath = quadraticcurvepath1(x3, y3, x2, y2, r, 0, 0, swflag);
    } else { cpath = quadraticcurvepath(x3, y3, x1, y1, x2, y2); }
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", smode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#" + smode + "corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", smode + "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
    cornerpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (smode == 'shape') {
        //cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
        let cornerbandpath = cornerg.select("#" + smode + "cornerband" + cornerindex);
        if (cornerbandpath.empty()) { cornerbandpath = cornerg.append("path").attr("id", smode + "cornerband" + cornerindex).on("click", onshapesidecorner); }
        cornerbandpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype)
        .attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        cornerbandpath.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth).attr("stwidth", stwidth)
            .on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu);
    }
}
function drawshapecornermarkertext(lnindex, index, sideindex, sidecode, mtx, mty, mtext1, mtext2, type) {
    let sindex = shape.index, smode = shape.mode, partsrno = shape.partsrno, areaid = shape.areaid, spindex = shape.spindex, tsoffset = "30%";
    let cornerindex = shape.index + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + index;    
    let cornerg = cornersg.select("#" + smode + "cornerg" + cornerindex); 
    if (type == 1) {
        cornerindex += "" + lnindex;
        let sidecornertext = cornerg.select("#" + smode + "cornertext" + cornerindex);
        if (sidecornertext.empty()) { sidecornertext = cornerg.append("text").append("textPath").attr("id", smode + "cornertext" + cornerindex); }
        //console.log(cornerindex, lnindex, index, sideindex, sidecode, mtx, mty, mtext1, mtext2, type, sidecornertext.empty());
        sidecornertext.attr("xlink:href", "#" + smode + "corner" + cornerindex).attr("startOffset", "50%").attr("text-anchor", "middle").attr("alignment-baseline", "ideographic").attr("style", "fill:grey;font-size:10px;").text(mtext1);
        sidecornertext.attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        //if (smode == 'shape') { sidecornertext.on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
        //sidecornertext.on("conetextmenu", svgcontextmenu);        
    } else if (type == 2) {
        let sidecornertext = cornerg.select("#" + smode + "cornertext" + cornerindex);
        if (sidecornertext.empty()) { sidecornertext = cornerg.append("text").append("textPath").attr("id", smode + "cornertext" + cornerindex); }
        sidecornertext.attr("xlink:href", "#" + smode + "corner" + cornerindex).attr("startOffset", tsoffset).attr("text-anchor", "middle").attr("alignment-baseline", "ideographic").attr("style", "fill:grey;font-size:10px;").text(mtext1);
        sidecornertext.attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        //if (smode == 'shape') { sidecornertext.on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
        //sidecornertext.on("conetextmenu", svgcontextmenu);        
    } else if (type == 3 || type == 4) {       
        let sidecornertext1 = cornerg.select("#" + smode + "cornertext" + cornerindex + "2");
        if (sidecornertext1.empty()) { sidecornertext1 = cornerg.append("text").append("textPath").attr("id", smode + "cornertext" + cornerindex + "2"); }
        sidecornertext1.attr("xlink:href", "#" + smode + "corner" + cornerindex + "2").attr("startOffset", tsoffset).attr("text-anchor", "start").attr("alignment-baseline", "ideographic").attr("style", "fill:grey;font-size:10px;").text(mtext1);
        sidecornertext1.attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        //sidecornertext1.on("conetextmenu", svgcontextmenu);
        let sidecornertext2 = cornerg.select("#" + smode + "cornertext" + cornerindex + "3");
        if (sidecornertext2.empty()) { sidecornertext2 = cornerg.append("text").append("textPath").attr("id", smode + "cornertext" + cornerindex + "3"); }
        sidecornertext2.attr("xlink:href", "#" + smode + "corner" + cornerindex + "3").attr("startOffset", tsoffset).attr("text-anchor", "start").attr("alignment-baseline", "ideographic").attr("style", "fill:grey;font-size:10px;").text(mtext2);
        sidecornertext2.attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", sindex).attr("spindex", spindex).attr("partsrno", partsrno).attr("areaid", areaid).attr("smode", smode);
        //sidecornertext2.on("conetextmenu", svgcontextmenu);
    }    
}
function showshapecorner01() {
    let type = parseInt(this.getAttribute("type"));
    let edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    if (type == 0) { d3.select(this).attr("class", "shapecornerblue"); }
    else if (type == 3 || type == 4) {
        d3.select(this).attr("style", "fill:blue;fill-opacity:1.0;cursor:pointer;");
    }
    else if (type == 1 || type == 2) {
        let stwidth = parseInt(this.getAttribute("stwidth"));       
        d3.select(this).attr("style", "storke:blue;fill-opacity:1.0;cursor:pointer;stroke-width", 15);
        d3.select(this).attr("class", "shapesideblue");        
    }    
}
function showshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    let edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    let cclass = colorflag == 1 ? 'shapecornerblue' : 'shapecornergreen1';
    let sclass = colorflag == 1 ? 'shapesideblue' : 'shapesidegreen1';
    let fcolor = colorflag == 1 ? 'blue' : 'green';
    if (type == 0) { d3.select(this).attr("class", cclass); }
    else if (type == 3 || type == 4) {
        d3.select(this).attr("style", "fill:" + fcolor + ";fill-opacity:1.0;cursor:pointer;");
    }
    else if (type == 1 || type == 2) {
        d3.select(this).attr("style", "fill:" + fcolor + ";fill-opacity:1.0;cursor:pointer;");
        //let stwidth = parseInt(this.getAttribute("stwidth"));
        //d3.select(this).attr("style", "storke:" + fcolor + ";fill-opacity:1.0;cursor:pointer;stroke-width", 15);
        //d3.select(this).attr("class", sclass);
    }
}
function hideshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    let edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    if (type == 0) {
        d3.select(this).attr("class", "shapecorner");
    } else if (type == 1 || type == 2) {
        d3.select(this).attr("style", "fill:" + scolor + ";fill-opacity:0;cursor:pointer;");
        //let stwidth = parseInt(this.getAttribute("stwidth"));
        //d3.select(this).attr("style", "stroke-opacity:0.1;cursor:pointer;stroke-width", stwidth);
        //d3.select(this).attr("class", sideedgeclass(edgetype));
    } else if (type == 3) {
        d3.select(this).attr("style", "fill:" + scolor + ";fill-opacity:0;cursor:pointer;");         
    } else if (type == 4) {
        d3.select(this).attr("style", "fill:" + scolor + ";fill-opacity:0.2;cursor:pointer;");
    }   
}
function removeshapecorners(type, source) {   
    if (shape != undefined && shape.sides != undefined) {
        for (let j = 0; j < shape.sides.length; j++) {
            removeshapesidecorners(j, type, shape.index);
        }
    }
}
function removeshapesidecorners(sideindex, type, sindex) { 
    let side = shape.sides[sideindex];   
    for (let j = 0; j < side.corners.length; j++) {
        if (side.corners[j].type == type) {
            removeshapesidecorner(j, sideindex, sindex);
        }
    }
}
function removeshapesidecorner(index, sideindex, sindex) {
    if (cornersg != undefined) {
        let side = shape.sides[sideindex];
        let corner = side.corners[index];
        let cornerindex = sindex + "" + shape.areaid + "" + shape.partsrno + "" + sideindex + "" + corner.sidecode + "" + index;
        let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
        if (!cornerg.empty()) { cornerg.remove(); }
    }
}
function onfocusinputcontrol32(objinputctrl) { 
    objinputctrl.select();
}
