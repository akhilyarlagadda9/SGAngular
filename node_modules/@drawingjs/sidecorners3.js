function initsidecorners(index) {
    var side = shape.sides[index];
    side.corners.push(initsidecorner(0, index, 1));
    side.corners.push(initsidecorner(1, index, 2));
}
function initendsidecorners(index) {
    var side = shape.sides[index];
    if (side != undefined && side.corners != undefined) {
        if (side.corners.length == 2) {
            side.corners.push(initsidecorner(2, index, 3));
            side.corners.push(initsidecorner(3, index, 4));
        }
        setendsidecorner1(2, index, 3);
        setendsidecorner2(3, index, 4);
    }
}
function initsidecorner(index, sideindex, sidecode) {
    let corner = { index: index, sideindex: sideindex, sidecode: sidecode, sindex: shape.index, type: 0, w: 51, h: 51, r: 51, angle: 90, edgetype: 'F', edgetypeid: 0, edgeheight: 0, edges: [] };
    initcorneredges(corner);
    return corner;
}
function initcorneredges(corner) {
    let edges = [];
    edges.push(initcorneredge(0, corner.index, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(1, corner.index, 0, 'W', 0, 'W'));
    edges.push(initcorneredge(2, corner.index, 0, 'F', 0, 'F'));
    edges.push(initcorneredge(3, corner.index, 0, 'F', 0, 'F'));
    edges.push(initcorneredge(4, corner.index, 0, 'F', 0, 'F'));
    corner.edges = edges;
}
function initcorneredge(index, sideindex, sidecode, type, typeid, text) {
    let edge = { index: index, sideindex: sideindex, sidecode: sidecode, type: type, typeid: typeid, text: text };
    return edge;
}
function onsetsidecorner(index, sideindex, type) {
    drawlogservice.beforeupdate(shape, 'onsetsidecorner', 2);
    var side = shape.sides[sideindex];
    var corner = side.corners[index], sidecode = corner.sidecode;
    removeshapesidecorner(index, sideindex,shape.index);
    var splindex = -1;
    splindex = sidesplashindex(side, sidecode, 2);
    if (splindex != -1) { deletesidesplash(splindex, sideindex, sidecode); }
    setsidecorner(index, sideindex, type);
    splindex = sidesplashactiveindex(side, sidecode, 1);
    if (splindex != -1) { setsidesplash(splindex, sideindex, sidecode, 0); }
    drawlogservice.update(shape, 'onsetsidecorner', 2);
    onsetslabpart(0, 0, 'onsetsidecorner');
}
function setsidecorners(index) {
    setsidecorner1(0, index, 1);
    setsidecorner2(1, index, 2);
    drawsidecorner(0, index);
    drawsidecorner(1, index);

}
function setsidecorner(index, sideindex, type) {    
    var side = shape.sides[sideindex];
    var corner = side.corners[index], sidecode = corner.sidecode;
    corner.type = type; corner.typeid = cornertypeid;
    if (corner.edges == undefined) { initcorneredges(corner); }
    //console.log(index, sideindex, type, sidecode);
    if (sidecode == 1) { setsidecorner1(index, sideindex); } else if (sidecode == 2) { setsidecorner2(index, sideindex); }
    else if (sidecode == 3) { setendsidecorner1(index, sideindex); } else if (sidecode == 4) { setendsidecorner2(index, sideindex); }
    drawsidecorner(index, sideindex);
    oncornerchangedrawsidesplashs(sideindex);
    ActionShapeReSize();   
}
function setsidecorner1(index, sideindex) {
    var side = shape.sides[sideindex];
    if (side.corners != undefined) {
        var corner = side.corners[index], w = corner.w, h = corner.h, type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype;
        var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        var x1 = x11, y1 = y11, x2 = x12, y2 = y12, x3 = x21, y3 = y21;
        if (sideindex > 0) { let side1 = shape.sides[sideindex - 1]; x3 = side1.x11, y3 = side1.y11; }
        if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
        let npt1 = calclinepoint(x1, y1, x2, y2, w);
        x2 = npt1.dx, y2 = npt1.dy;
        let npt2 = calclinepoint(x1, y1, x3, y3, h);
        x3 = npt2.dx, y3 = npt2.dy;
        corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;
    }
}
function setsidecorner2(index, sideindex) {
    var side = shape.sides[sideindex];
    if (side.corners != undefined) {
        var corner = side.corners[index], w = corner.w, h = corner.h, type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype;
        var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
        var x1 = x21, y1 = y21, x2 = x22, y2 = y22, x3 = x11, y3 = y11;
        if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
        // w = calcsidelen(w); h = calcsidelen(h);
        if (sideindex > 0) { let side1 = shape.sides[sideindex - 1]; x3 = side1.x21, y3 = side1.y21; }
        let npt1 = calclinepoint(x1, y1, x2, y2, w);
        x2 = npt1.dx, y2 = npt1.dy;
        let npt2 = calclinepoint(x1, y1, x3, y3, h);
        x3 = npt2.dx, y3 = npt2.dy;
        corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;
    }
}
function setendsidecorner1(index, sideindex) {
    var side = shape.sides[sideindex];
    var corner = side.corners[index], w = corner.w, h = corner.h, type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype;
    var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    var x1 = x12, y1 = y12, x2 = x11, y2 = y11, x3 = x22, y3 = y22;
    var angle1 = 0, asign1 = 0;
    if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
    // w = calcsidelen(w); h = calcsidelen(h);
    let npt1 = calclinepoint(x1, y1, x2, y2, w);
    x2 = npt1.dx, y2 = npt1.dy;
    let npt2 = calclinepoint(x1, y1, x3, y3, h);
    x3 = npt2.dx, y3 = npt2.dy;
    corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;
}
function setendsidecorner2(index, sideindex) {
    var side = shape.sides[sideindex];
    var corner = side.corners[index], w = corner.w, h = corner.h, type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype;
    var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    var x1 = x22, y1 = y22, x2 = x21, y2 = y21, x3 = x12, y3 = y12;
    if (type == 1) { w = calcsidelen(w); h = calcsidelen(h); }
    // w = calcsidelen(w); h = calcsidelen(h);
    let npt1 = calclinepoint(x1, y1, x2, y2, w);
    x2 = npt1.dx, y2 = npt1.dy;
    let npt2 = calclinepoint(x1, y1, x3, y3, h);
    x3 = npt2.dx, y3 = npt2.dy;
    corner.x1 = x1, corner.y1 = y1, corner.x2 = x2, corner.y2 = y2, corner.x3 = x3, corner.y3 = y3;
}
function setsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source) {    
    drawlogservice.beforeupdate(shape, 'setsidecorneredge', 2);
    let side = shape.sides[sideindex];
    let corner = side.corners[index], sidecode = corner.sidecode;
    if (corner.edges == undefined) { initcorneredges(corner); }
    //console.log(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source);
    let corneredge = corner.edges[lnindex];
    corneredge.type = edgetype, corneredge.typeid = edgetypeid, corneredge.text = edgetype;
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);    
    if (!cornerg.empty()) {
        let eclass = sideedgeclass(edgetype);       
        if (corner.type == 1 || corner.type == 4) {
            let clineindex = cornerindex + "" + lnindex;
            let cornerline = cornerg.select("#corner" + clineindex);
            //console.log(lnindex, index, sideindex, edgetype, edgetypeid, edgeheight, source, clineindex);
            if (!cornerline.empty()) { cornerline.attr("class", eclass).attr("edgetype", edgetype); }//mouseout hideshapecorner will set class based on edgetype
        } else {
            let cornerpath = cornerg.select("#corner" + cornerindex);
            if (!cornerpath.empty()) { cornerpath.attr("edgetype", edgetype); }//mouseout hideshapecorner will set class based on edgetype
        }
    }
    drawlogservice.update(shape, 'setsidecorneredge', 2);
}
function onshapesidecorner() {
    d3.event.stopPropagation();
    d3.event.preventDefault();
    let index = parseInt(this.getAttribute("index"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let mode = this.getAttribute("smode");
    initshapegroups(sindex, mode, 'onshapesidecorner');    
    if (drawmode == 2) {
        onsetsidecorner(index, sideindex, cornertype);
    } else if (drawmode == 4) {
        onsetcornersplash(index, sideindex, sidecode, edgetype, edgetypeid, 2, 'onshapesidecorner');
    } else if (drawmode == 5) {
        let lnindex = this.getAttribute("lnindex");
        if (lnindex != undefined) { setsidecorneredge(lnindex, index, sideindex, edgetype, edgetypeid, 0, 'onshapesidecorner'); }        
    }
}
function onshapesidecornercontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode == 'shape') {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        initshapegroups(sindex, mode, 'onshapesidecornercontextmenu');
        drawshapesidecornercontrols(index, sideindex, m[0], m[1]);
    }
}
function onresizesidecorner(obj, type, index, sideindex) {
    drawlogservice.beforeupdate(shape, 'onresizesidecorner', 2);
    let side = shape.sides[sideindex];
    let corner = side.corners[index];
    let objVal = obj.value.split(" ");
    let whr = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    if (whr != 0) {
        if (type == 1) { corner.w = whr * scale; } else if (type == 2) { corner.h = whr * scale; } else if (type == 3) { corner.r = whr * scale; }
        setsidecorner(index, sideindex, corner.type);
    }
    ActionAddSplashSide();
    drawlogservice.update(shape, 'onresizesidecorner', 2);
    onsetslabpart(0, 0, 'onresizesidecorner');
}
function ondeleteshapesidecorner(index, sideindex) {
    onsetsidecorner(index, sideindex, 0);
    removeshapecontrols();
}
function drawshapecorners(index, source) {  
    if (shape != undefined && shape.sides!=null) {
        for (let j = 0; j < shape.sides.length; j++) {
            drawsidecorners(j);
        }
        drawendsidecorners();
    }
}
function drawsidecorners(index) {    
    setsidecorner1(0, index, 1);
    setsidecorner2(1, index, 2);
    drawsidecorner(0, index);
    drawsidecorner(1, index);
}
function drawendsidecorners() {
    if (shape.sides.length > 0) {
        let index = shape.sides.length - 1;
        initendsidecorners(index);
        drawsidecorner(2, index);
        drawsidecorner(3, index);
    }
}
function drawsidecorner(index, sideindex) {
    var side = shape.sides[sideindex];
    if (side != undefined && side.corners != undefined) {
        var corner = side.corners[index];
        var x1 = corner.x1, y1 = corner.y1, x2 = corner.x2, y2 = corner.y2, x3 = corner.x3, y3 = corner.y3, type = corner.type, sidecode = corner.sidecode, edgetype = corner.edgetype, w = corner.w, h = corner.h, r = corner.r;
        if (corner.edges == undefined) { initcorneredges(corner); }
        let edgetype1 = corner.edges[0].type, edgetype2 = corner.edges[1].type, edgetype3 = corner.edges[2].type, edgetype4 = corner.edges[3].type, edgetype5 = corner.edges[3].type;
        if (type == 0) {//No corner
            if (shape.mode == 'shape') { drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type); }
        } else {
            drawshapecornerline(0, index, sideindex, sidecode, x1, y1, x2, y2, edgetype1, 0);
            drawshapecornerline(1, index, sideindex, sidecode, x1, y1, x3, y3, edgetype2, 0);
        }
        if (type == 1) {  //Clip corner        
            drawshapecornerline(2, index, sideindex, sidecode, x2, y2, x3, y3, edgetype3, type);
        } else if (type == 2) {//Curve corner
            drawshapecornerarcpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, w, edgetype3, type);
        }
        else if (type == 3) {//Notch corner
            drawshapecornerclippath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, w, h, edgetype3, type);
        }
        else if (type == 4) {//Bumpout corner      
            let dh = 30, angle = side.angle, asign = side.asign, dsign = 1;
            let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = side.w1 * scale, w2 = side.w2 * scale;
            dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x2, y2, x3, y3, w);
            let dh1 = dsign * r;
            let npt1 = calcTranslationExact1(dh1, x2, y2, x3, y3);
            let dx1 = npt1.dx, dy1 = npt1.dy;
            x11 = x2, y11 = y2, x12 = x3, y12 = y3;
            x21 = x2 + dx1, y21 = y2 + dy1, x22 = x3 + dx1, y22 = y3 + dy1;
            drawshapecornerline(2, index, sideindex, sidecode, x21, y21, x22, y22, edgetype3, type);
            drawshapecornerline(3, index, sideindex, sidecode, x11, y11, x21, y21, edgetype4, type);
            drawshapecornerline(4, index, sideindex, sidecode, x12, y12, x22, y22, edgetype5, type);
            drawshapecornerbumpoutpath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, edgetype3, type);
        }
    } else {
        //console.log(shape.index, index, sideindex, shape.sides.length, shapes.length);
    }
}
function drawshapecornerpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, type) {
    if (drawmode == 2) {
        var eclass = 'shapecornerblue';
        var cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;       
        var cpath = "M" + x1 + "," + y1 + "l" + (x2 - x1) + "," + (y2 - y1);
        cpath += "l" + (x3 - x2) + "," + (y3 - y2) + "z";
        //console.log(lnindex,index, sideindex, sidecode, x1, y1, x2, y2, cornerindex);
        var cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
        if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", shape.mode + "cornerg" + cornerindex); }
        var cornerpath = cornerg.select("#corner" + index);
        if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + index); }
        cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", shape.index).attr("smode", shape.mode);
        if (shape.mode == 'shape') { cornerpath.on("click", onshapesidecorner); }
    }
}
function drawshapecornerline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype, type) {
    var eclass = type == 0 ? 'shapesidewhite' : sideedgeclass(edgetype);
    var cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    //console.log(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, cornerindex, eclass ,edgetype);
    var cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", shape.mode + "cornerg" + cornerindex); }
    var clineindex = shape.index + "" + sideindex + "" + sidecode + "" + index + "" + lnindex;
    var cornerline = cornerg.select("#corner" + clineindex);
    if (cornerline.empty()) { cornerline = cornerg.append("line").attr("id", "corner" + clineindex); }
    cornerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("lnindex", lnindex)
        .attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("edgetype", edgetype)
        .attr("sindex", shape.index).attr("smode", shape.mode);
    if (type != 0) {
        cornerline.attr("type", type);
        if (shape.mode == 'shape') { cornerline.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
    }

}
function drawshapecornerclippath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, w, h, edgetype, type) {
    var eclass = sideedgeclass(edgetype);
    var cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    var x4 = x2 + x3 - x1, y4 = y2 + y3 - y1;//midpoint formala for polygon to find fourth corner
    var cpath = "M" + x2 + "," + y2 + "l" + (x4 - x2) + "," + (y4 - y2);
    cpath += "l" + (x3 - x4) + "," + (y3 - y4);
    //  console.log(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, edgetype, type);
    var cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", shape.mode + "cornerg" + cornerindex); }
    var cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", shape.index).attr("smode", shape.mode);
    if (shape.mode == 'shape') { cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
}
function drawshapecornerbumpoutpath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, type) {
    var eclass = 'sideshape';
    var cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    var cpath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    cpath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    var cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", shape.mode + "cornerg" + cornerindex); }
    var cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("sindex", shape.index).attr("smode", shape.mode);
    cornerpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    if (shape.mode == 'shape') { cornerpath.on("click", onshapesidecorner).on("contextmenu", onshapesidecornercontextmenu);}
}
function drawshapecornerarcpath(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype, type) {
    let eclass = sideedgeclass(edgetype);
    let cornerindex = shape.index + "" + sideindex + "" + sidecode + "" + index;
    let cpath = "";
    if (shape.sides.length == 1) {
        let swflag = 1; if (sidecode == 1 || sidecode == 4) { swflag = 0; }
        cpath = quadraticcurvepath1(x2, y2, x3, y3, r, 0, 0, swflag);
    } else { cpath = quadraticcurvepath(x2, y2, x1, y1, x3, y3); }
    //console.log(index, sideindex, sidecode, x1, y1, x2, y2, x3, y3, r, edgetype)
    let cornerg = cornersg.select("#" + shape.mode + "cornerg" + cornerindex);
    if (cornerg.empty()) { cornerg = cornersg.append("g").attr("id", shape.mode + "cornerg" + cornerindex); }
    let cornerpath = cornerg.select("#corner" + cornerindex);
    if (cornerpath.empty()) { cornerpath = cornerg.append("path").attr("id", "corner" + cornerindex); }
    cornerpath.attr("d", cpath).attr("class", eclass).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("type", type).attr("edgetype", edgetype).attr("sindex", shape.index).attr("smode", shape.mode);
    if (shape.mode == 'shape') { cornerpath.on("click", onshapesidecorner).on("mouseover", showshapecorner).on("mouseout", hideshapecorner).on("contextmenu", onshapesidecornercontextmenu); }
}
function showshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    if (type == 0) { d3.select(this).attr("class", "shapecornerblue"); }
    else { d3.select(this).attr("class", "shapesideblue"); }
}
function hideshapecorner() {
    let type = parseInt(this.getAttribute("type"));
    let edgetype = this.getAttribute("edgetype");   
    if (type == 0) { d3.select(this).attr("class", "shapecorner"); }
    else { d3.select(this).attr("class", sideedgeclass(edgetype)); }
}
function removeshapecorners(type, source) {  
    for (let i = 0; i < shapes.length; i++) {
        if (shapes[i].sides != undefined) {
            for (let j = 0; j < shapes[i].sides.length; j++) {
                removeshapesidecorners(j, type, i);
            }
        }
    }
}
function removeshapesidecorners(sideindex, type, sindex) {
    let side = shapes[sindex].sides[sideindex];
    for (let j = 0; j < side.corners.length; j++) {
        if (side.corners[j].type == type) {
            removeshapesidecorner(j, sideindex, sindex);
        }
    }
}
function removeshapesidecorner(index, sideindex, sindex) {
    let side = shapes[sindex].sides[sideindex];
    let corner = side.corners[index];
    let cornerindex = "#shapecornerg" + sindex + "" + sideindex + "" + corner.sidecode + "" + index;  
    $(cornerindex).remove();
}
