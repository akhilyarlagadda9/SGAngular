function initsideedge(index, sideindex, code, type, typeid, text) {   
    let edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function initsplashedge(index, sideindex, code, type, typeid, text) {
    let edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function sideedgeindex1(side, code) {
    var edgeindex = -1;// rect shape 1 side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    if (side != undefined) {
        for (var i = 0; i < side.edges.length; i++) { if (side.edges[i].code == code) { edgeindex = i; break; } }
    }
    return edgeindex;
}
function sideedgeindex(sideindex, code) {
    var edgeindex = -1;// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { edgeindex = i; break; } }
    return edgeindex;
}
function sideedgetype(sideindex, code) {
    var etype = 'F';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (var i = 0; i < shape.sides[sideindex].edges.length; i++) { if (shape.sides[sideindex].edges[i].code == code) { etype = shape.sides[sideindex].edges[i].type; break; } }
    return etype;
}
function sideedgetext(sideindex, code) {
    let etype = '';// rect shape i side - 4 edges, l-shape - 2 sides - 3 edges, u shape - 2 edges for middle sides
    for (let i = 0; i < shape.sides[sideindex].edges.length; i++) {
        if (shape.sides[sideindex].edges[i].code == code) {
            if (shape.sides[sideindex].edges[i].typeid != 0) {
                etype = shape.sides[sideindex].edges[i].type;
                if (etype != '' && etype != null) { let types = etype.split(':'); etype = types[0]; }
            }
            break;
        }
    }
    return etype;
}
function setsideedges(index, edgetype) {
    if (index == 0) { setsideedge(index, 0, edgetype, 0); }
    setsideedge(index, 1, edgetype, 0);
    setsideedge(index, 2, edgetype, 0);
}
function setsideedge(sideindex, code, type, typeid) {
    //console.log(sideindex, code, type, typeid);
    let side = shape.sides[sideindex], w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
    if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }    
    let edgeindex = sideedgeindex(sideindex, code);  
    if (edgeindex == -1) { side.edges.push(initsideedge(code, sideindex, code, type, typeid, type)); edgeindex = side.edges.length - 1; }  
    let edge = side.edges[edgeindex];    
    edge.type = type, edge.typeid = typeid, edge.code = code, edge.text = type, edge.sideindex = side.index, edge.width = sidesegswidth(sideindex, code);
    //console.log(sideindex, code, type, typeid, side.sidesegs.length, edge.width);
}
function setsideedge1(index, code, type, typeid, source) {
    source = source + ':setsideedge1';
    setsideedge(index, code, type, typeid);
   // console.log(index, code, type, typeid);
    drawshapeside32(index, source);
}
function onsetsideedge(index, code, type, typeid) {
    let source = 'onsetsideedge';
    drawlogservice.beforeupdate(shape, source, 5);
    setsideedge1(index, code, type, typeid, source);    
    setsideshapesedges(index, code, type, typeid);
    //ondeleteshapesidesplash1(-1, index, code);
    ActionEdge(index);
    drawlogservice.update(shape, source, 5);    
}
function onsetsideedge2(side, code, type, typeid) {
    if (side != undefined) {
        w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
        let edgeindex = sideedgeindex1(side, code);
        if (edgeindex == -1) { side.edges.push(initsideedge(code, sideindex, code, type, typeid, type)); edgeindex = side.edges.length - 1; }
        let edge = side.edges[edgeindex];
        if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }
        edge.type = type, edge.typeid = typeid, edge.code = code, edge.text = type, edge.sideindex = side.index, edge.width = sidesegswidth(sideindex, code);
    }
}
function setsideedgeswidth(index) {
    let side = shape.sides[index];
    if (side.index == 0) { setsideedgewidth(side, 0); }
    setsideedgewidth(side, 1);
    setsideedgewidth(side, 2);
    if (side.index == shape.sides.length -1) { setsideedgewidth(side, 3); }
}
function setsideedgewidth(side, code) {
    let w1 = side.w1, w2 = side.w2, h = side.h / 4, w = 0;
    let edgeindex = sideedgeindex1(side, code);
    let edge = side.edges[edgeindex];
    if (edge != undefined) {
        if (code == 0 || code == 3) { w = h; } else if (code == 1) { w = w1; } else if (code == 2) { w = w2; }
      //  console.log(w, code, w1, w2, h, edgeindex);
        edge.width = sidesegswidth(side.index, code);
    }
}
function sidesplashedges(splash, sidecode) {
    let edge1type = 'F', edge2type = 'U', edge3type = 'F', edge4type = 'F';
    if (sidecode == 0 || sidecode == 2) { edge2type = 'F', edge3type = 'U'; }
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 0, edge1type, 0, edge1type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 1, edge2type, 0, edge2type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 2, edge3type, 0, edge3type));
    splash.edges.push(initsplashedge(splash.edges.length, splash.index, 3, edge4type, 0, edge4type));
}
function onsetsplashsideedge(index, splashindex, sideindex, sidecode) {
   // console.log(index, splashindex, sideindex, sidecode);
    drawlogservice.beforeupdate(shape, 'onsetsplashsideedge', 6);
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let spledge = splash.edges[index];
    spledge.type = edgetype, spledge.typeid = edgetypeid, spledge.text = edgetype;
    setsidesplashedgeswidth(splash);
    drawsidesplash(splashindex, sideindex);
    ActionSplash('onsetsplashsideedge');
    drawlogservice.update(shape, 'onsetsplashsideedge', 6);
}
function setsidesplashedgeswidth(splash) {
    setsidesplashedgewidth(splash, 0);
    setsidesplashedgewidth(splash, 1);
    setsidesplashedgewidth(splash, 2);
    setsidesplashedgewidth(splash, 3);
}
function setsidesplashedgewidth(splash, code) {
    let w = splash.width, h= splash.height;    
    let edge = splash.edges[code];  
    if (edge != undefined) {
        if (code == 0 || code == 3) { w = h; }
        edge.width = w;
    }   
}
function sideedgeclass(type) {
    let eclass = 'shapeside';
    if (type == 'A') {
        eclass = 'shapesidepurple';
    } else if (type == 'U') {
        eclass = 'shapesidered';
    } else if (type == 'S') {
        eclass = 'shapesidered';
    } else if (type == 'E' || type == 'M') {
        eclass = 'shapesideorange';
    } else if (type == 'C') {
        eclass = 'shapeseam';
    } else if (type == 'F') {
        eclass = 'shapeside';
    } else if (type == 'W') {
        eclass = 'shapesidewhite';
    } else {
        eclass = 'shapesideblack';
    }
    return eclass;
}
