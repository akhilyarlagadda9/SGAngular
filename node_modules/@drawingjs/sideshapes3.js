function initshapesideshape(sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = {};
    sideshape.index = side.sideshapes.length, sideshape.sideindex = sideindex, sideshape.sidecode = sidecode, sideshape.type = sideshapetype, sideshape.typeid = sideshapetypeid, sideshape.angle = 45;
    sideshape.w = 84, sideshape.h = 42, sideshape.r = 42, sideshape.isactive = 1, sideshape.dw = 0, sideshape.edges = [];
    sideshape.x = side.x11, sideshape.y = side.y11;
    if (sideshapetype == 3) {
        if (sidecode == 0) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
        else if (sidecode == 1) { sideshape.w = side.w1 * scale, sideshape.h = sideshape.r = (side.w1 * scale) / 4; }
        else if (sidecode == 2) { sideshape.w = side.w2 * scale, sideshape.h = sideshape.r = (side.w2 * scale) / 4; }
        else if (sidecode == 3) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 4; }
    }
    side.sideshapes.push(sideshape);
    initsideshapeedges(sideshape.index, sideindex, sidecode);
}
function initsideshapeedges(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sedgeindex = sideedgeindex(side, sidecode);
    let edgetype = side.edges[sedgeindex].type, edgetypeid = side.edges[sedgeindex].type;
    let sideshape = side.sideshapes[index];
    sideshape.edges = [];
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, 'W', -1, edgetype));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype));
    sideshape.edges.push(initsideshapeedge(sideshape.edges.length, edgetype, edgetypeid, edgetype));
}
function initsideshapeedge(index, type, typeid, text) {
    let edge = { index: index, type: type, typeid: typeid, text: text };
    return edge;
}
function setsideshape(x, y, index, sideindex, sidecode) {   
    let side = shape.sides[sideindex];
    if (index == -1) { index = side.sideshapes.length, initshapesideshape(sideindex, sidecode); }
    let sideshape = side.sideshapes[index];
    if (sideshape != undefined) {
        if (sideshape.index != index) { sideshape.index = index; } //reindex 
        if (x != 0 && y != 0) { setsideshapecoords(x, y, index, sideindex, sidecode); }
    }
    return index;
}
function setsideshapecoords(x, y, index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, x, y);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let angle1 = calclineangle2(sx1, sy1, sx11, sy11);
        if (Math.abs(angle - angle1) > 10) { sx11 = sx1, sy11 = sy1; }
        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let angle2 = calclineangle2(sx12, sy12, sx2, sy2);
        if (Math.abs(angle - angle2) > 10) {
            sx12 = sx2, sy12 = sy2;
            let npt3 = rotate_point1(sx12, sy12, -1, angle + 180, sw); //second point on side
            sx11 = npt3.dx, sy11 = npt3.dy;
        }
        dw = calchyplen(sx11, sy11, sx12, sy12);
        sideshape.x = sx11, sideshape.y = sy11, sideshape.dw = dw;
    }
}
function setsideshapeedge(lnindex, index, sideindex, edgetype, edgetypeid) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    if (sideshape != undefined) {
        let sideshapeedge = sideshape.edges[lnindex];
        sideshapeedge.type = edgetype, sideshapeedge.typeid = edgetypeid;
        let sideshapeindex = shape.index + "" + sideindex + "" + index;
        let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
        if (!sideshapeg.empty()) {
            let sslineindex = index + "" + lnindex;
            let sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
            let eclass = sideedgeclass(edgetype);
            if (!sideshapeline.empty()) {
                sideshapeline.attr("edgetype", edgetype); sideshapeline.attr("class", eclass);
            }//mouseout hideshapecorner will set class based on edgetype
        }
        ActionAddEdge();
    }
}
function onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid) {
    //console.log(lnindex, index, sideindex, edgetype, edgetypeid);
    drawlogservice.beforeupdate(shape, 'onsideshapeside', 5);
    setsideshapeedge(lnindex, index, sideindex, edgetype, edgetypeid);
    drawlogservice.update(shape, 'onsideshapeside', 5);
    onsetslabpart(0, 0, 'onsideshapeside');
}
function setsideshapeedges(index, sideindex, type, typeid) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    for (let i = 1; i < sideshape.edges.length; i++) {
        setsideshapeedge(i, index, sideindex, edgetype, edgetypeid);
    }
}
function onsetsideshapeedges1(sideindex, sidecode, type, typeid) {
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.sideshapes.length; i++) {
        if (side.sideshapes[i].sidecode == sidecode) {
            setsideshapeedges(i, sideindex, type, typeid);
        }
    }
}
function onsetsideshape(x, y, index, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'onsetsideshape', 5);
    index = setsideshape(x, y, index, sideindex, sidecode);
    drawsideshape(index, sideindex);
    ActionShapeReSize();
    drawlogservice.update(shape, 'onsetsideshape', 5);
    if (layoutmode == 1) { onsetslabpart(0, 0, 'onsetsideshape'); }
}
function onsetsideshape1(x, y, index, sideindex, sidecode) {
    setsideshape(x, y, index, sideindex, sidecode);
    onsetslabpart(0, 0, 'sideshapedragged');
    drawsideshape(index, sideindex);
}
function onsideshapecontextmenu() {
    let m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode != 'print') {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        if (shape.index != index) { initshapegroups(sindex, mode, 'onshapesidecornercontextmenu'); }
        drawsideshapecontrols(index, sideindex, sidecode, m[0], m[1]);
    }
}
function onresizesideshape(obj, type, index, sideindex) {
    drawlogservice.beforeupdate(shape, 'onresizesideshape', 5);
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index];
    let objVal = obj.value.split(" ");
    let val = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    if (type == 0) { sideshape.w = val * scale; }
    else if (type == 1) { sideshape.h = val * scale; }
    else if (type == 2) { sideshape.angle = val; }
    setsideshape(0, 0, index, sideindex, sideshape.sidecode);
    drawsideshape(index, sideindex);
    ActionShapeReSize();
    drawlogservice.update(shape, 'onresizesideshape', 5);
    onsetslabpart(0, 0, 'onresizesideshape');
}
function ondeleteshapesideshape(index, sideindex, sidecode) {
    if (sideshapesg != undefined) {
        drawlogservice.beforeupdate(shape, 'ondeleteshapesideshape', 5);
        let side = shape.sides[sideindex];
        let sideshape = side.sideshapes[index];
        sideshape.isactive = 0;
        let sideshapeindex = shape.index + "" + sideindex + "" + index;
        $("#" + shape.mode + "sideshapeg" + sideshapeindex).remove();
        ActionShapeReSize();
        drawlogservice.update(shape, 'ondeleteshapesideshape', 5);
        onsetslabpart(0, 0, 'ondeleteshapesideshape');
    }
    removeshapetools();
}
function onsideshapeside() {
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        if (drawmode == 5) {
            let lnindex = parseInt(this.getAttribute("lnindex"));
            let index = parseInt(this.getAttribute("index"));
            let sideindex = parseInt(this.getAttribute("sideindex"));
            let sindex = parseInt(this.getAttribute("sindex"));
            let sidecode = parseInt(this.getAttribute("sidecode"));
            if (shape.index != index) { initshapegroups(sindex, mode, 'onsideshapeside'); }
            onsetsideshapeedge1(lnindex, index, sideindex, edgetype, edgetypeid);
        }
    }
}
function drawsideshapes(index) {
    let side = shape.sides[index];
    if (side.sideshapes != undefined && side.sideshapes != null) {
        for (let j = 0; j < side.sideshapes.length; j++) {
            if (side.sideshapes[j].isactive == 1) {
                drawsideshape(j, index);
            }
        }
    }
}
function drawsideshape(index, sideindex) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], type = sideshape.type, sidecode = sideshape.sidecode, sx = sideshape.x, sy = sideshape.y;
    if (sideshape.dw == undefined) { setsideshapecoords(0, 0, index, sideindex, sidecode); }
    if (sideshape.edges == undefined) {
        //3- Full arc, 4- Bump out arc, 7-Bump in Arc, 6- Bumpout, 5-Bump in,1-Bumpout Angle, 2- Bumpin Angle        
        initsideshapeedges(index, sideindex, sidecode);
    }
    if (type == 3 || type == 4 || type == 7) {
        drawarcsideshape(index, sideindex, sidecode);
    } else if (type == 5 || type == 6) { drawbumpinoutsideshape(index, sideindex, sidecode); }
    else if (type == 1) { drawbumpoutanglesideshape(index, sideindex, sidecode); }
    else if (type == 2) { drawbumpinanglesideshape(index, sideindex, sidecode); }
}
function drawbumpinoutsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (type == 5) { sh = -sh; }
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;
        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;

        drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, sx12, sy12, sideedges[0].type);
        drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, sideedges[1].type);
        drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, sideedges[2].type);
        drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, sideedges[3].type);
        drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
        if (dw > 0 && shape.mode == 'shape') { drawsideshapemarker(0, index, sideindex, sidecode, sx1, sy1, sx11, sy11); }
    }
}
function drawbumpoutanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;
        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        if (sidecode == 0) { angle1 = angle - 90 + sideangle, angle2 = angle - 90 - sideangle; }
        else if (sidecode == 1) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 270 + sideangle, angle2 = angle + 180 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;

        drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, sx12, sy12, sideedges[0].type);
        drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, sideedges[1].type);
        drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, sideedges[2].type);
        drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, sideedges[3].type);
        drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
        if (dw > 0 && shape.mode == 'shape') { drawsideshapemarker(0, index, sideindex, sidecode, sx1, sy1, sx11, sy11); }
    }
}
function drawbumpinanglesideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw, sideangle = sideshape.angle;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; sh = -sh; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; sh = -sh; }

        let angle = calclineangle2(sx1, sy1, sx2, sy2);

        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        if (sidecode == 0) { angle1 = angle + sideangle, angle2 = angle + 90 + sideangle; }
        else if (sidecode == 1) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }
        else if (sidecode == 2) { angle1 = angle + 180 + sideangle, angle2 = angle + 270 + sideangle; sh = -sh; }
        else if (sidecode == 3) { angle1 = angle + 90 + sideangle, angle2 = angle + sideangle; }

        let npt3 = rotate_point1(sx11, sy11, -1, angle1, sh); //first point on second side
        sx21 = npt3.dx, sy21 = npt3.dy;

        let npt4 = rotate_point1(sx12, sy12, -1, angle2, sh); //second point on second side
        sx22 = npt4.dx, sy22 = npt4.dy;

        drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, sx12, sy12, sideedges[0].type);
        drawsideshapeline(1, index, sideindex, sidecode, sx11, sy11, sx21, sy21, sideedges[1].type);
        drawsideshapeline(2, index, sideindex, sidecode, sx21, sy21, sx22, sy22, sideedges[2].type);
        drawsideshapeline(3, index, sideindex, sidecode, sx12, sy12, sx22, sy22, sideedges[3].type);
        drawsideshapepath(index, sideindex, sidecode, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
        if (dw > 0 && shape.mode == 'shape') { drawsideshapemarker(0, index, sideindex, sidecode, sx1, sy1, sx11, sy11); }
    }
}
function drawarcsideshape(index, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let sideshape = side.sideshapes[index], sideedges = sideshape.edges;
    if (sideshape != undefined) {
        let sw = sideshape.w, sh = sideshape.h, type = sideshape.type, sx = sideshape.x, sy = sideshape.y, dw = sideshape.dw;
        let sx1 = 0, sy1 = 0, sx2 = 0, sy2 = 0, sx11 = 0, sy11 = 0, sx12 = 0, sy12 = 0, sx21 = 0, sy21 = 0, sx22 = 0, sy22 = 0;

        if (sidecode == 0) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x21, sy2 = side.y21; sh = -sh; }
        else if (sidecode == 1) { sx1 = side.x11, sy1 = side.y11, sx2 = side.x12, sy2 = side.y12; }
        else if (sidecode == 2) { sx1 = side.x21, sy1 = side.y21, sx2 = side.x22, sy2 = side.y22, sh = -sh; }
        else if (sidecode == 3) { sx1 = side.x12, sy1 = side.y12, sx2 = side.x22, sy2 = side.y22; }
        if (type == 7) { sh = -sh; }
        let angle = calclineangle2(sx1, sy1, sx2, sy2);
        let npt1 = calcverticalvectorpoint(sx1, sy1, sx2, sy2, sx, sy);
        sx11 = npt1.dx, sy11 = npt1.dy; //first point on side

        let npt2 = rotate_point1(sx11, sy11, -1, angle, sw); //second point on side
        sx12 = npt2.dx, sy12 = npt2.dy;

        let npt3 = offsetline(sx11, sy11, sx12, sy12, sh * 2);
        sx21 = npt3.dx1, sy21 = npt3.dy1, sx22 = npt3.dx2, sy22 = npt3.dy2;

        let rx = (sx21 + sx22) / 2, ry = (sy21 + sy22) / 2;
        drawsideshapeline(0, index, sideindex, sidecode, sx11, sy11, sx12, sy12, sideedges[0].type);
        drawsideshapearcline(1, index, type, sideindex, sidecode, sx11, sy11, rx, ry, sx12, sy12, sideedges[1].type);
        if (dw > 0 && shape.mode == 'shape') { drawsideshapemarker(0, index, sideindex, sidecode, sx1, sy1, sx11, sy11); }
    }
}
function drawsideshapeline(lnindex, index, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    let sslineindex = index + "" + lnindex;
    let sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "sideshape" + sslineindex); }
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
    .attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).attr("edgetype", edgetype);
    if (lnindex != 0) { sideshapeline.on("click", onsideshapeside).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside); }
    if (shape.mode == 'shape') {
        let sideshapebandline = sideshapeg.select("#sideshapeband" + sslineindex);
        if (sideshapebandline.empty()) { sideshapebandline = sideshapeg.append("line").attr("id", "sideshapeband" + sslineindex); }
        sideshapebandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).attr("edgetype", edgetype);
        if (lnindex != 0) {
            sideshapebandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", "15");
            sideshapebandline.on("click", onsideshapeside).on("mouseover", showsideshapeside).on("mouseout", hidesideshapeside);
        }
    }
}
function drawsideshapearcline(lnindex, index, type, sideindex, sidecode, x1, y1, x2, y2, x3, y3, edgetype) {
    let sideeclass = sideedgeclass(edgetype);
    let sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sspath = quadraticcurvepath(x1, y1, x2, y2, x3, y3);
    let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    let sslineindex = index + "" + lnindex;
    let sideshapepath = sideshapeg.select("#" + "sideshape" + sslineindex);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshape" + sslineindex); }
    sideshapepath.attr("d", sspath).attr("class", sideeclass).attr("index", index).attr("lnindex", lnindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
    .attr("smode", shape.mode).attr("edgetype", edgetype).attr("sindex", shape.index).on("contextmenu", onsideshapecontextmenu);
    sideshapepath.on("click", onsideshapeside).on("mouseover", showarcsideshapeside).on("mouseout", hidearcsideshapeside);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu);
        if (type != 3) { sideshapepath.call(sideshapedrag); }
    }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
}
function drawsideshapepath(index, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22, type) {
    let eclass = 'sideshape', sideshapeindex = shape.index + "" + sideindex + "" + index;
    let sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";

    let sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    let sideshapepath = sideshapeg.select("#" + "sideshapepath" + index);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + index); }
    sideshapepath.attr("d", sspath).attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).attr("class", eclass);
    if (shape.mode == 'shape') {
        sideshapepath.on("contextmenu", onsideshapecontextmenu);
        if (type != 3) { sideshapepath.call(sideshapedrag); }
    }
    sideshapepath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2").style("display", "block").style("display", "block");
}
function drawsideshapemarker(lnindex, index, sideindex, code, x1, y1, x2, y2) {
    var h = 5; if (code == 2) { h = -h; }
    var npt = calcTranslationExact1(h, x1, y1, x2, y2);
    let dx = npt.dx, dy = npt.dy;
    x1 = x1 + dx, y1 = y1 + dy, x2 = x2 + dx, y2 = y2 + dy;
    var mtx = (x1 + x2) / 2, mty = (y1 + y2) / 2, mtext = (x1 - x2) / scale;
    var mtext = Math.round(calchyplen(x1, y1, x2, y2) / scale);

    var sideshapeindex = shape.index + "" + sideindex + "" + index;
    var sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sslineindex = index + "" + lnindex;
    var sideshapeline = sideshapeg.select("#mssline" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "mssline" + sslineindex); }
    var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "cutoutarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
    var markertext = sideshapeg.select("#msstext" + sslineindex);
    if (markertext.empty()) { markertext = sideshapeg.append("text").attr("id", "msstext" + sslineindex).attr("class", "shapemarker"); }
    markertext.attr("x", mtx).attr("y", mty).text(mtext)
}
function drawsideshapemarkertext(index, sideindex, sidecode, x, y, mtext) {
    var sideshapeindex = shape.index + "" + sideindex + "" + index;
    var sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sslineindex = index + "" + lnindex;
    var sideshapeline = sideshapeg.select("#mssline" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "mssline" + sslineindex); }
    var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "cutoutarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
    var markertext = sideshapeg.select("#msstext" + sslineindex);
    if (markertext.empty()) { markertext = sideshapeg.append("text").attr("id", "msstext" + sslineindex).attr("class", "shapemarker"); }
    markertext.attr("x", mtx).attr("y", mty).text(mtext)
}
function drawsideshapepointcircle(lineindex, index, sideindex, sidecode, cx, cy, cr, edgetype) {
    var eclass = sideedgeclass(edgetype);
    var spgindex = sideindex + "" + index + "" + sidecode;
    var sideshapeg = sideshapesg.select("#sideshapeg" + spgindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", "sideshapeg" + spgindex); }
    var splindex = spgindex + "" + lineindex;
    var canglecircle = sideshapeg.select("#canglecircle" + splindex);
    if (canglecircle.empty()) { canglecircle = sideshapeg.append("circle").attr("id", "canglecircle" + splindex); }
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr)
    .attr("class", 'sideshape').attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).call(sideshapedrag);
}
function sideshapedragstarted() {
    let sindex = parseInt(this.getAttribute("sindex"));
    let mode = this.getAttribute("smode");
    if (mode == 'shape') {
        if (shape.index != sindex) { initshapegroups(sindex, mode, 'sideshapedragstarted'); }
        bdrag = true;
        drawlogservice.beforeupdate(shape, 'sideshapedragstarted', 5);
    }
}
function sideshapedragged() {
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let sideshape = shape.sides[sideindex].sideshapes[index];
        this.x = this.x || sideshape.x;
        this.y = this.y || sideshape.y;
        this.x += d3.event.dx;
        this.y += d3.event.dy;
        onsetsideshape1(this.x, this.y, index, sideindex, sidecode);
    }
}
function sideshapedragended() {
    if (bdrag) {
        bdrag = false;
        ActionShapeReSize();
        drawlogservice.update(shape, 'sideshapedragended', 5);
    }
}
function showsideshapeside() {
    if (drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
    }
}
function hidesideshapeside() {
    //var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    //d3.select(this).attr("class", sideedgeclass(edgetype));
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", "15");
}
function showarcsideshapeside() {
    if (drawmode == 5) {//splash/edge mode       
        d3.select(this).attr("class", "shapesideblue");
    }
}
function hidearcsideshapeside() {
    var edgetype = this.getAttribute("edgetype");
    //var lnindex = this.getAttribute("lnindex");
    d3.select(this).attr("class", sideedgeclass(edgetype));
}