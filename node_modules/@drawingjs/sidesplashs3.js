function initsidesplash(index, sideindex, cornerindex, sidecode, type, height) {
    let side = shape.sides[sideindex];
    let splash = {
        index: index, sideindex: sideindex, cornerindex: cornerindex, angle: 0, sidecode: sidecode, width: 0, height: height, isactive: 1, type: type, split: 0,
        x: 0, y: 0, tx: 0, ty: 0, x11: 0, y11: 0, x12: 0, y12: 0, x21: 0, y21: 0, x22: 0, y22: 0, edges: [], sideshapes: [], seams: []
    };
    splash.edges.push(initsplashedge(splash.edges.length, index, 0, 'F', 0, 'F'));
    splash.edges.push(initsplashedge(splash.edges.length, index, 0, 'U', 0, 'U'));
    splash.edges.push(initsplashedge(splash.edges.length, index, 0, 'F', 0, 'F'));
    splash.edges.push(initsplashedge(splash.edges.length, index, 0, 'F', 0, 'F'));
    side.splashs.push(splash);
}
function initsplashedge(index, sideindex, code, type, typeid, text) {
    var edge = { index: index, code: code, type: type, typeid: typeid, text: text, width: 0, height: 0, sideindex: sideindex };
    return edge;
}
function sidesplashindex(side, sidecode, type) {
    var splashindex = -1;
    for (var i = 0; i < side.splashs.length; i++) {
        if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type) { splashindex = i, side.splashs[i].isactive = 1; break; }
    }
    return splashindex;
}
function sidesplashactiveindex(side, sidecode, type) {
    var splashindex = -1;
    for (var i = 0; i < side.splashs.length; i++) { if (side.splashs[i].sidecode == sidecode && side.splashs[i].type == type && side.splashs[i].isactive == 1) { splashindex = i; break; } }
    return splashindex;
}
function onsetsidesplash(sideindex, sidecode, edgetype, edgetypeid, type) {
    drawlogservice.beforeupdate(shape, 'onsetsidesplash', 6);
    let side = shape.sides[sideindex];
    let index = sidesplashindex(side, sidecode, type);
    if (index == -1) { index = side.splashs.length; initsidesplash(index, sideindex, 0, sidecode, type, splheight); }
    let splash = side.splashs[index]; splash.height = splheight;
    setsideedge(sideindex, sidecode, edgetype, edgetypeid, 0);
    setsidesplash(index, sideindex, sidecode, 0);
    drawlogservice.update(shape, 'onsetsidesplash', 6);
    onsetslabpart(0, 0, 'onsetsidesplash');
}
function onsetsplashsideedge(index, splashindex, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'onsetsplashsideedge', 6);
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let spledge = splash.edges[index];
    spledge.type = edgetype, spledge.typeid = edgetypeid, spledge.text = edgetype;
    drawsidesplash(splashindex, sideindex);
    if (shape.mode == 'shape' && drawmode != 0) { ActionAddEdge(splashindex); }
    drawlogservice.update(shape, 'onsetsplashsideedge', 6);
    onsetslabpart(0, 0, 'onsetsplashsideedge');
}
function setsidesplash(index, sideindex, sidecode, width) {
    let side = shape.sides[sideindex];
    if (sidecode == 0) { setstartsidesplash(index, sideindex, width); } else if (sidecode == 1) { setsidesplash1(index, sideindex, width); }
    else if (sidecode == 2) { setsidesplash2(index, sideindex, width); } else if (sidecode == 3) { setendsidesplash(index, sideindex, width); }
    drawsidesplash(index, sideindex);
    setsplashseams(index, sideindex, sidecode);
    setsplashsideshapes(index, sideindex, sidecode);
    if (shape.mode == 'shape' && drawmode != 0) { ActionAddEdge(index); }
}
function sidecornerindex(sideindex, x1, y1) {
    let cindex = -1;
    let side = shape.sides[sideindex];
    for (let i = 0; i < side.corners.length; i++) {        
        if (side.corners[i].x1 == x1 && side.corners[i].y1 == y1) { cindex = i; break; }
    }
    return cindex;
}

function setsidesplash1(index, sideindex, width) { 
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let dh = 30, asign = side.asign, dsign = 1, sidecode = splash.sidecode;
    let height = splash.height * scale, w = splash.width * scale;
    let x1 = side.x11, y1 = side.y11, x2 = side.x12, y2 = side.y12;
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0, w1 = side.w1, w2 = side.w2;

    let cindex = sidecornerindex(sideindex, x1, y1);
    if (cindex != -1) {
        let corner = side.corners[cindex];          
        if (corner.type != 0) {
            //let  cw = calcsidelen(corner.w);           
            //let cnpt1 = calclinepoint(x1, y1, x2, y2, cw);
            //x1 = cnpt1.dx, y1 = cnpt1.dy;
            //console.log(JSON.stringify(corner), x1, y1);
            x1 = corner.x2, y1 = corner.y2;
        }
    }
    if (sideindex == shape.sides.length - 1) {
        let cindex2 = sidecornerindex(sideindex, x2, y2);
        if (cindex2 != -1) {
            let corner1 = side.corners[cindex2];           
            if (corner1.type != 0) {
                //let cw1 = calcsidelen(corner1.w);              
                //let cnpt2 = calclinepoint(x2, y2, x1, y1, cw1);
                //x2 = cnpt2.dx, y2 = cnpt2.dy;
                x2 = corner1.x2, y2 = corner1.y2;
                //console.log(JSON.stringify(corner1));
            }
        }
    } else if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];
        let cindex1 = sidecornerindex(sideindex + 1, side1.x11, side1.y11);       
        if (cindex1 != -1) {
            let corner1 = side1.corners[cindex1];          
            if (corner1.type != 0) {
                //let cw2 = calcsidelen(corner1.h);                      
                //let cnpt2 = calclinepoint(x2, y2, x1, y1, cw2);
                //x2 = cnpt2.dx, y2 = cnpt2.dy;
               // console.log(JSON.stringify(corner1));
                x2 = corner1.x3, y2 = corner1.y3;
            }
        }
    }
    w = Math.round(calchyplen(x1, y1, x2, y2));
    if (width != 0) { w = width * scale; }

    dsign = islineinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, side.h);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.width = Math.abs(w) / scale;

}
function setsidesplash2(index, sideindex, width) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let dh = 30, asign = side.asign, dsign = 1;
    let height = splash.height * scale, w = splash.width * scale, x = splash.x, y = splash.y;
    let x1 = side.x21, y1 = side.y21, x2 = side.x22, y2 = side.y22;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0, w1 = side.w1, w2 = side.w2;

    let cindex = sidecornerindex(sideindex, x1, y1);
    if (cindex != -1) {
        let corner = side.corners[cindex];
        if (corner.type != 0) {
            //let cw = h = calcsidelen(corner.w);
            //let npt1 = calclinepoint(x1, y1, x2, y2, cw);
            //x1 = npt1.dx, y1 = npt1.dy;
            x1 = corner.x2, y1 = corner.y2;
        }
    }
    if (sideindex == shape.sides.length - 1) {
        let cindex2 = sidecornerindex(sideindex, x2, y2);
        if (cindex2 != -1) {
            let corner1 = side.corners[cindex2];
            if (corner1.type != 0) {
                //let cw1 = calcsidelen(corner1.w);
                //let npt2 = calclinepoint(x2, y2, x1, y1, cw1);
                //x2 = npt2.dx, y2 = npt2.dy;
                x2 = corner1.x2, y2 = corner1.y2;
            }
        }
    } else if (sideindex < shape.sides.length - 1) {
        let side1 = shape.sides[sideindex + 1];
        let cindex1 = sidecornerindex(sideindex + 1, side1.x21, side1.y21);
        if (cindex1 != -1) {
            let corner1 = side1.corners[cindex1];
            if (corner1.type != 0) {
                //let cw2 = calcsidelen(corner1.h);
                //let npt2 = calclinepoint(x2, y2, x1, y1, cw2);
                //x2 = npt2.dx, y2 = npt2.dy;
                x2 = corner1.x3, y2 = corner1.y3;
            }
        }
    }
    w = Math.round(calchyplen(x1, y1, x2, y2));
    if (width != 0) { w = width * scale; }

    dsign = islineinpoly2(x11, y11, x12, y12, x21, y21, x22, y22, side.h);

    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    // console.log(index, sideindex, dsign, dh1, dh2, w1, w2);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.width = Math.abs(w) / scale;
}
function setstartsidesplash(index, sideindex, width) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let dh = 30, asign = 1, dsign = 1;
    let height = splash.height * scale, w = splash.width * scale, x = splash.x, y = splash.y;
    let x1 = side.x11, y1 = side.y11, x2 = side.x21, y2 = side.y21;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0;

    let corner = side.corners[0];
    if (corner.type != 0) {        
        //let cw = calcsidelen(corner.h);
        //let npt1 = calclinepoint(x1, y1, x2, y2, cw);
        //x1 = npt1.dx, y1 = npt1.dy;
        x1 = corner.x3, y1 = corner.y3;
    }
    let corner1 = side.corners[1];
    if (corner1.type != 0) {       
        //let cw1 = calcsidelen(corner.h);        
        //let npt2 = calclinepoint(x2, y2, x1, y1, cw1);
        //x2 = npt2.dx, y2 = npt2.dy;
        x2 = corner1.x3, y2 = corner1.y3;
    }
    w = Math.round(calchyplen(x1, y1, x2, y2));
    if (width != 0) { w = width * scale; }

    dsign = islineinpoly3(x11, y11, x12, y12, x21, y21, x22, y22, side.w2 * scale);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    // console.log(index, sideindex, dsign, dh1, dh2);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x1 = x1, splash.y1 = y1, splash.x2 = x2, splash.y2 = y2;
    splash.x = x11, splash.y = y11, splash.width = Math.abs(w) / scale;
}
function setendsidesplash(index, sideindex, width) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[index];
    let dh = 30, asign = 1, dsign = 1;
    let height = splash.height * scale, w = splash.width * scale, x = splash.x, y = splash.y;
    let x1 = side.x12, y1 = side.y12, x2 = side.x22, y2 = side.y22;
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, cw1 = 0, cw2 = 0;

    let corner = side.corners[2];
    if (corner.type != 0) {
        //let cw = h = calcsidelen(corner.h);
        //let npt1 = calclinepoint(x1, y1, x2, y2, cw);
        //x1 = npt1.dx, y1 = npt1.dy;
        x1 = corner.x3, y1 = corner.y3;
    }
    let corner1 = side.corners[3];
    if (corner1.type != 0) {
        //let cw1 = h = calcsidelen(corner1.h);
        //let npt2 = calclinepoint(x2, y2, x1, y1, cw1);
        //x2 = npt2.dx, y2 = npt2.dy;
        x2 = corner1.x3, y2 = corner1.y3;
    }
    w = Math.round(calchyplen(x1, y1, x2, y2));
    if (width != 0) { w = width * scale; }
    dsign = islineinpoly4(x11, y11, x12, y12, x21, y21, x22, y22, side.w2 * scale);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);
    // console.log(index, sideindex, dsign, dh1, dh2);
    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;

    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x1 = x1, splash.y1 = y1, splash.x2 = x2, splash.y2 = y2;
    splash.x = x11, splash.y = y11, splash.width = Math.abs(w) / scale;
}
function onsetcornersplash(cornerindex, sideindex, sidecode, edgetype, edgetypeid, type) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    if (corner.type != 0) {
        drawlogservice.beforeupdate(shape, 'onsetcornersplash', 6);
        let index = sidesplashindex(side, sidecode, type);
        if (index == -1) { index = side.splashs.length; initsidesplash(index, sideindex, cornerindex, sidecode, type, splheight); }
        let splash = side.splashs[index]; splash.height = splheight;
        setsidecorneredge(0, cornerindex, sideindex, edgetype, edgetypeid, 0, 'onsetcornersplash');
        setcornersplash(index, cornerindex, sideindex, 0);
        drawlogservice.beforeupdate(shape, 'onsetcornersplash', 6);
        onsetslabpart(0, 0, 'onsetcornersplash');
    }
}
function setcornersplash(index, cornerindex, sideindex, width) {
    setcornersplash1(index, cornerindex, sideindex, width);
    drawcornersplash(index, cornerindex, sideindex, width);
    ActionAddEdge(index);
}
function setcornersplash1(index, cornerindex, sideindex, width) {
    let side = shape.sides[sideindex];
    let corner = side.corners[cornerindex];
    let splash = side.splashs[index];
    let x1 = corner.x2, y1 = corner.y2, x2 = corner.x3, y2 = corner.y3, x3 = corner.x1, y3 = corner.y1, sidecode = corner.sidecode, cw = corner.w;
    let dh = 30, asign = side.asign, dsign = 1;
    let height = splash.height * scale, w = splash.width * scale;
    let x = splash.x, y = splash.y, dx = Math.abs(x1 - x2), dy = Math.abs(y1 - y2);
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22, w1 = side.w1 * scale, w2 = side.w2 * scale;

    if (width == 0) { w = cw; } else { w = width * scale; }
    dsign = ispointinpoly1(x11, y11, x12, y12, x21, y21, x22, y22, x1, y1, x2, y2, cw);
    let dh1 = dsign * dh, dh2 = dsign * (dh + height);

    let npt1 = calcTranslationExact1(dh1, x1, y1, x2, y2);
    let npt2 = calcTranslationExact1(dh2, x1, y1, x2, y2);
    dx1 = npt1.dx, dy1 = npt1.dy, dx2 = npt2.dx, dy2 = npt2.dy;
    x11 = x1 + dx1, y11 = y1 + dy1, x12 = x2 + dx1, y12 = y2 + dy1;
    x21 = x1 + dx2, y21 = y1 + dy2, x22 = x2 + dx2, y22 = y2 + dy2;
    w = Math.round(calchyplen(x1, y1, x2, y2));
    splash.x11 = x11, splash.y11 = y11, splash.x12 = x12, splash.y12 = y12;
    splash.x21 = x21, splash.y21 = y21, splash.x22 = x22, splash.y22 = y22;
    splash.x = x11, splash.y = y11, splash.x2 = x2, splash.y2 = y2, splash.width = Math.abs(w) / scale;   
}

function onshapesplashside() {
    var splashsidecode = parseInt(this.getAttribute("index"));
    var splashindex = parseInt(this.getAttribute("splashindex"));
    var sideindex = parseInt(this.getAttribute("sideindex"));
    var sidecode = parseInt(this.getAttribute("sidecode"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    var m = d3.mouse(this);
    initshapegroups(sindex, mode, 'onsplashside');
    if (drawmode == 3) {
        onsetsplashsideshape(m[0], m[1], -1, splashindex, sideindex, splashsidecode);
    } else if (drawmode == 5) {
        onsetsplashsideedge(splashsidecode, splashindex, sideindex, sidecode);
    }
}

function onshapesidesplash() {
    removeshapetools();
    d3.event.stopPropagation();
    var index = parseInt(this.getAttribute("index"));
    var sideindex = parseInt(this.getAttribute("sideindex"));
    var sidecode = parseInt(this.getAttribute("sidecode"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    var m = d3.mouse(this);
    initshapegroups(sindex, mode, 'onshapesidesplash');
    if (mode == 'shape' && drawmode == 7) {
        if (seamtype != 2) { onsetsidesplashseam(m[0], m[1], -1, index, sideindex, sidecode, sindex); }
        setdrawmode(0);
    }
}
function onshapesplashcontextmenu() {
    var m = d3.mouse(this);
    d3.event.preventDefault();
    var index = parseInt(this.getAttribute("index"));
    var sideindex = parseInt(this.getAttribute("sideindex"));
    var sidecode = parseInt(this.getAttribute("sidecode"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    initshapegroups(sindex, mode, 'onsplashcontextmenu');
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], w = splash.width, h = splash.height;
    drawshapesidesplashcontrols(index, sideindex, sidecode, w, h, m[0], m[1]);
}
function onresizesidesplash(obj, type, index, sideindex, sidecode) {
    var w = 0;
    let side = shape.sides[sideindex];
    let splash = side.splashs[index], spltype = splash.type;
    var objVal = obj.value.split(" ");
    var parseVal = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    drawlogservice.beforeupdate(shape, 'onresizesidesplash', 4);
    if (type == 0) { splash.width = parseVal; } else { splash.height = parseVal; }
    if (spltype == 1) { setsidesplash(index, sideindex, sidecode, w); ActionAddSplash(); }
    else if (spltype == 2) { setcornersplash(index, splash.cornerindex, sideindex, w); }
    drawlogservice.update(shape, 'onresizesidesplash', 4);
   // console.log('onresizesidesplash');
    onsetslabpart(0, 0, 'onresizesidesplash');    
}
function ondeleteshapesidesplash(index, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'ondeleteshapesidesplash', 4);
    setsideedge(sideindex, sidecode, "U", 0, 0);
    deletesidesplash(index, sideindex, sidecode);
    deletesplashseams(index, sideindex, sidecode);
    deletesplashsideshapes(index, sideindex, sidecode);
    deleteslabsplashs(index, sideindex, shape.index);
    ActionAddEdge(index);
    removeshapetools();
    drawlogservice.update(shape, 'ondeleteshapesidesplash', 4);
    onsetslabpart(0, 0, 'ondeleteshapesidesplash');
}
function ondeleteshapesidesplash1(index, sideindex, sidecode) {
    drawlogservice.beforeupdate(shape, 'ondeleteshapesidesplash1', 4);
    var side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    deletesidesplash(index, sideindex, sidecode);
    deletesplashseams(index, sideindex, sidecode);
    deletesplashsideshapes(index, sideindex, sidecode);
    deleteslabsplashs(index, sideindex, shape.index);
    drawlogservice.update(shape, 'ondeleteshapesidesplash1', 4);
    onsetslabpart(0, 0, 'ondeleteshapesidesplash1');
}
function deletesidesplash(index, sideindex, sidecode) {
    var side = shape.sides[sideindex];
    if (index == -1) { index = sidesplashactiveindex(side, sidecode, 1); }
    if (index != -1) {
        side.splashs[index].isactive = 0;
        var spgindex = sideindex + "" + index + "" + sidecode;
        var splashg = splashsg.select("#splashg" + spgindex);
        if (!splashg.empty()) { splashg.remove(); }
    }
}
function oncornerchangedrawsidesplashs(sideindex) {
    drawsidesplashs(sideindex);
    if (sideindex > 0) { drawsidesplashs(sideindex - 1); }
}
function drawsidesplashs(sideindex) {
    if (shape.mode != 'slabpart') {
        var side = shape.sides[sideindex];
        if (side.splashs == undefined) { side.splashs = []; }
        for (var i = 0; i < side.splashs.length; i++) {
            if (side.splashs[i].isactive == 1) {
                if (side.splashs[i].type == 1) {
                    setsidesplash(i, sideindex, side.splashs[i].sidecode, 0);
                } else if (side.splashs[i].type == 2) { setcornersplash(i, side.splashs[i].cornerindex, sideindex, 0); }
            }
        }
    }
}
function drawsidesplash(index, sideindex) {
    var side = shape.sides[sideindex];
    var splash = side.splashs[index];
    let sidecode = splash.sidecode, width = splash.width, splheight = splash.height, type = splash.type, mtext = width + " x " + splheight;    
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, splheight);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, splheight);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, splheight);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, splheight);
    //console.log(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F')
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawcornersplash(index, cornerindex, sideindex) {
    var side = shape.sides[sideindex];
    var corner = side.corners[cornerindex];
    var splash = side.splashs[index];
    let sidecode = splash.sidecode, width = splash.width, splheight = splash.height, type = splash.type, mtext = width + " x " + splheight;    
    let x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12;
    let x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
    let edge1type = splash.edges[0].type, edge2type = splash.edges[1].type, edge3type = splash.edges[2].type, edge4type = splash.edges[3].type;
    drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext);
    drawsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type, splheight);
    drawsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type, splheight);
    drawsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type, splheight);
    drawsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type, splheight);
    //drawsplashline(4, index, sideindex, sidecode, x1, y1, x2, y2, 'F');
}
function drawsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype, splheight) {
    let eclass = sideedgeclass(edgetype);
    let spgindex = sideindex + "" + splashindex + "" + sidecode;
    let splashg = splashsg.select("#splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", "splashg" + spgindex); }
    let splindex = sideindex + "" + splashindex + "" + sidecode + "" + lineindex;
    let splline = splashg.select("#splash" + splindex);
    if (splline.empty()) { splline = splashg.append("line").attr("id", "splash" + splindex); }
    splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("sideindex", sideindex)
        .attr("sidecode", sidecode).attr("edgetype", edgetype).attr("sindex", shape.index).attr("smode", shape.mode);
    if (shape.mode == 'shape') {
        let stwidth = 10;
        if (splheight < 4) { stwidth = 5; }
        let splbandline = splashg.select("#splashband" + splindex);
        if (splbandline.empty()) { splbandline = splashg.append("line").attr("id", "splashband" + splindex); }
        splbandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", lineindex).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("stwidth", stwidth)
            .attr("edgetype", edgetype).attr("sindex", shape.index).attr("smode", shape.mode).on("click", onshapesplashside).on("mouseover", showshapesplashside).on("mouseout", hideshapesplashside);
        splbandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
    }
}
function drawpointcircle(lineindex, splashindex, sideindex, sidecode, cx, cy, cr, edgetype) {
    var eclass = sideedgeclass(edgetype);
    var spgindex = sideindex + "" + splashindex + "" + sidecode;
    var splashg = splashsg.select("#splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", "splashg" + spgindex); }
    var splindex = sideindex + "" + splashindex + "" + sidecode + "" + lineindex;
    var canglecircle = splashg.select("#canglecircle" + splindex);
    if (canglecircle.empty()) {canglecircle = splashg.append("circle").attr("id", "canglecircle" + splindex);}
    canglecircle.attr("cx", cx).attr("cy", cy).attr("r", cr).attr("class", eclass);
}
function drawsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext) {
    var spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    var sclass = 'shapesplash', sindex = shape.index, smode = shape.mode;
    var spgindex = sideindex + "" + index + "" + sidecode;
    var splashg = splashsg.select("#splashg" + spgindex);
    if (splashg.empty()) { splashg = splashsg.append("g").attr("id", "splashg" + spgindex); }
    var splindex = sideindex + "" + index + "" + sidecode + "" + type;
    var splashpath = splashg.select("#splashpath" + splindex);
    if (splashpath.empty()) { splashpath = splashg.append("path").attr("id", "splashpath" + splindex); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", sindex).attr("smode", smode).attr("d", spath)
        .on("click", onshapesidesplash).on("contextmenu", onshapesplashcontextmenu);
    var npt = calcontrolcenterpoint(splashg);
    var mtx = npt.ctx, mty = npt.cty + 3;
    var splashtext = splashg.select("#splashtext" + splindex);
    if (splashtext.empty()) { splashtext = splashg.append("text").attr("id", "splashtext" + splindex); }
    splashtext.attr("x", mtx).attr("y", mty).text(mtext + '"');
    splashpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
}
function splashdragstarted() {
    if (shape.mode != 'print') {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sidecode = parseInt(this.getAttribute("sidecode"));
        var sindex = parseInt(this.getAttribute("sindex"));
        var mode = this.getAttribute("smode");
        initshapegroups(sindex, mode, 'splashdragstarted');
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        dragdx = d3.event.x - splash.x, dragdy = d3.event.y - splash.y;
        bdrag = true;
        drawlogservice.beforeupdate(shape, 'splashdragstarted', 4);
    }
}
function splashdragged() {
    if (bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sidecode = parseInt(this.getAttribute("sidecode"));
        var sindex = parseInt(this.getAttribute("sindex"));
        var mode = this.getAttribute("smode");
        initshapegroups(sindex, mode, 'splashdragstarted');
        let side = shape.sides[sideindex];
        let splash = side.splashs[index];
        var cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        splash.x = cx, splash.y = cy;
        setsidesplash(index, sideindex, sidecode, 0);
    }
}
function splashdragended() {
    resetdragvars('splashdragended');
    drawlogservice.update(shape, 'splashdragended', 4);
}

function showshapesplashside() {
    if (drawmode == 3 || drawmode == 5) {//splash/edge mode
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "10");
        //d3.select(this).attr("class", "shapesideblue");
    }
}
function hideshapesplashside() {
    let stwidth = parseInt(this.getAttribute("stwidth"));
    // var edgetype = this.getAttribute("edgetype");
    let scolor = d3.select(this).attr('scolor');
    d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", stwidth);
    //d3.select(this).attr("class", sideedgeclass(edgetype));
}
