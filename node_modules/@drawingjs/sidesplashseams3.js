function initsplashseam(x, y, splashindex, sideindex) {
    let side = shape.sides[sideindex];   
    let splash = side.splashs[splashindex];
    let seam = {}; index = splash.seams.length;
    seam.index = index, seam.type = 1, seam.sindex = shape.index, seam.sideindex = sideindex,
    seam.x = x, seam.y = y, seam.w = 0, seam.h = 0, seam.x1 = 0, seam.y1 = 0, seam.x2 = 0, seam.y2 = 0, seam.sx = 0, seam.sy = 0, seam.sw = 0, seam.split = 0, seam.isactive = 1;
    splash.seams.push(seam);
}
function setsidesplashseam(x, y, index, splashindex, sideindex, seamtype) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];    
    if (splash !== undefined) {
        if (index == -1) {
            index = splash.seams.length, initsplashseam(x, y,splashindex, sideindex, seamtype);
        }
        let splashseam = splash.seams[index];
        if (splashseam != undefined) {            
            if (splashseam.index != index) { splashseam.index = index; } //reindex 
            if (x > 0 && y > 0) { splashseam.x = x, splashseam.y = y; }
        }
    }
    return index;   
}
function onsetsidesplashseam(x, y, index, splashindex, sideindex, sidecode, sindex) {
    let slabsplashccount = shapeslabsplashcount(splashindex, sideindex, sindex);    
    if (slabsplashccount <=1) {
        index = setsidesplashseam(x, y, index, splashindex, sideindex, 1);
        let sw = drawshapesidesplashseam(index, splashindex, sideindex, sidecode);
        onsetslabsplashseam2(index, splashindex, sideindex, shape.index, sw);
    }
}
function onsetsidesplashseam1(index, splashindex, sideindex, sindex, sw) {    
    initshapegroups(sindex, 'shape', 'onsetsidesplashseam1');   
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    if (splash != undefined) {
        let splashseam = splash.seams[index];
        if (splashseam == undefined) { index = setsidesplashseam(0, 0, -1, splashindex, sideindex, 1); splashseam = splash.seams[index]; }       
        splashseam.x = splash.x + (sw * scale);
        splashseam.y = splash.y21;
        drawshapesidesplashseam(index, splashindex, sideindex, splash.sidecode);
    }
    return index;
}
function onsplashseamcontextmenu() {
    removeshapetools();
    var m = d3.mouse(this);
    d3.event.preventDefault();
    var index = parseInt(this.getAttribute("index"));
    var splashindex = parseInt(this.getAttribute("splashindex"));
    var sideindex = parseInt(this.getAttribute("sideindex"));
    var sindex = parseInt(this.getAttribute("sindex"));
    var mode = this.getAttribute("smode");
    if (mode == 'shape') {        
        initshapegroups(sindex, mode, 'onsplashseamcontextmenu');
        let side = shape.sides[sideindex];       
        let splash = side.splashs[splashindex];
        let splashseam = splash.seams[index];        
        if (shapeslabsplashcount(splashindex, sideindex, sindex) < 2) {
            drawsplashseamcontrols(index, splashindex, sideindex, m[0], m[1]);
        }       
    }
}
function onsplitsplashseam(seamindex, splashindex, sideindex, sindex) {
    let shapesplash = shapes[sindex].sides[sideindex].splashs[splashindex];
    //console.log(seamindex, splashindex, sideindex, sindex);
    shapesplash.split = 1;
    shapesplash.seams[seamindex].split = 1;
}
function deletesplashseams(index, sideindex, sidecode) {
    var side = shape.sides[sideindex];
    let splash = side.splashs[index];
    if (splash != undefined) {
        for (let i = 0; i < splash.seams.length; i++) {
            deletesplashseam(i, index, sideindex);
            removesplashseam(i, index, sideindex);
        }
    }
}
function ondeletesplashseam(index, splashindex, sideindex, sindex) {
    removeshapetools();   
    deletesplashseam(index, splashindex, sideindex);
    removesplashseam(index, splashindex, sideindex);
    ActionUpdateShape();
    ondeleteslabsplashseam1(index, splashindex, sideindex, sindex);
}
function ondeletesplashseam1(index, splashindex, sideindex, sindex) {
    initshapegroups(sindex, 'shape', 'ondeletesplashseam1');
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    if (splash != undefined) {
        let splashseam = splash.seams[index];
        deletesplashseam(index, splashindex, sideindex);
        removesplashseam(index, splashindex, sideindex);
        ActionUpdateShape();
    }
    
}
function deletesplashseam(index, splashindex, sideindex) {   
    let side = shape.sides[sideindex];
    if (side != undefined) {
        let splash = side.splashs[splashindex];
        let splashseam = splash.seams[index];
        if (splashseam != undefined) { splashseam.isactive = 0; } 
    }
}
function removesplashseam(index, splashindex,  sideindex) {
    let seamindex = shape.index + "" + sideindex + "" + splashindex + "" + index;   
    if (seamsg != undefined) {        
        let splashseamg = seamsg.select("#" + shape.mode + "splashseamg" + seamindex);
        if (!splashseamg.empty()) { splashseamg.remove(); }
        let splashseammarkerg = seamsg.select("#smarkerg" + seamindex);
        if (splashseammarkerg.empty()) { splashseammarkerg.remove(); }
    }
}
function setsplashseams(index, sideindex, sidecode) {
    var side = shape.sides[sideindex];
    let splash = side.splashs[index];
    for (let i = 0; i < splash.seams.length; i++) {
        if (splash.seams[i].isactive == 1) { drawshapesidesplashseam(i, index, sideindex, sidecode); }
    }
}
function drawshapesidesplashseam(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let splashseam = splash.seams[index];
    let sw = 0;
    if (splashseam != undefined) {
        let smtype = splashseam.type, x = splashseam.x, y = splashseam.y, h = splashseam.h, x1 = 0, y1 = 0, x2 = 0, y2 = 0;        
        var x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12, x21 = splash.x21, y21 = splash.y21, x22 = splash.x22, y22 = splash.y22;
        let mx1 = 0, my1 = 0, mx2 = 0, my2 = 0, mtext = '', mtx = 0, mty = 0;
        let npt1 = calcverticalvectorpoint(x11, y11, x12, y12, x, y); //first point on line
        x1 = npt1.dx, y1 = npt1.dy;
        let npt2 = calcverticalvectorpoint(x21, y21, x22, y22, x1, y1);//second point on line
        x2 = npt2.dx, y2 = npt2.dy;        
        mx1 = x11, my1 = y11, mx2 = x1; my2 = y1, mtx = (mx1 + mx2) / 2, mty = (my1 + my2) / 2;
        sw = (calchyplen(mx1, my1, mx2, my2) / scale).toFixed();       
        splashseam.x1 = x1, splashseam.y1 = y1, splashseam.x2 = x2, splashseam.y2 = y2, splashseam.sw = sw;        
        drawsplashseamline(index, splashindex, sideindex, sidecode, x1, y1, x2, y2);
        drawsplashseammarkerline(index, splashindex, sideindex, sidecode, mx1, my1, mx2, my2, mtx, mty, sw);
    }
    return sw;
}
function drawsplashseamline(index, splashindex, sideindex, sidecode, x1, y1, x2, y2) {
    var eclass = "shapeseam";
    var seamindex = shape.index + "" + sideindex + "" + splashindex + "" + index;    
    var splashseamg = seamsg.select("#" + shape.mode + "splashseamg" + seamindex);
    if (splashseamg.empty()) { splashseamg = seamsg.append("g").attr("id", shape.mode + "splashseamg" + seamindex); }
    var seamline = splashseamg.select("#splashseam" + sideindex);
    if (seamline.empty()) { seamline = splashseamg.append("line").attr("id", "splashseam" + sideindex); }
    seamline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", index).attr("splashindex", splashindex)
    .attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode).on('contextmenu', onsplashseamcontextmenu);
    if (shape.mode == 'shape') { seamline.call(splashseamdrag); }
    var seambandline = splashseamg.select("#splashseamband" + sideindex);
    if (seambandline.empty()) { seambandline = splashseamg.append("line").attr("id", "splashseamband" + sideindex); }
    seambandline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("index", index).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode)
    .on('contextmenu', onsplashseamcontextmenu);
    if (shape.mode == 'shape') { seambandline.call(splashseamdrag); }
    seambandline.attr("style", "stroke:" + shape.color).attr("scolor", shape.color).style("stroke-opacity", "0.1").style("stroke-width", "20").on("mouseover", showshapesidesplashseam).on("mouseout", hideshapesidesplashseam);
}
function drawsplashseammarkerline(index, splashindex, sideindex, sidecode, x1, y1, x2, y2, mtx, mty, mtext) {
    var seamindex = shape.index + "" + sideindex + "" + splashindex + "" + index;
    var splashseamg = seamsg.select("#" + shape.mode + "splashseamg" + seamindex);
    var splashseammarkerg = splashseamg.select("#smarkerg" + seamindex);
    if (splashseammarkerg.empty()) { splashseammarkerg = splashseamg.append("g").attr("id", "smarkerg" + seamindex); }
    if (!splashseammarkerg.empty()) {
        splashseammarkerg.attr("index", index).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode);
        var markerline = splashseammarkerg.select("#msline" + seamindex);
        if (markerline.empty()) { markerline = splashseammarkerg.append("line").attr("id", "msline" + seamindex); }
        var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
        var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
        markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "cutoutarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
        var smarkertext = splashseammarkerg.select("#mstext" + seamindex);
        if (smarkertext.empty()) { smarkertext = splashseammarkerg.append("text").attr("id", "mstext" + seamindex); }
        smarkertext.attr("x", mtx).attr("y", mty).text(mtext + '"');
        splashseammarkerg.style("opacity", "1");
    }
}
function splashseamdragstarted() {
    let index = parseInt(this.getAttribute("index"));
    let splashindex = parseInt(this.getAttribute("splashindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let mode = this.getAttribute("smode");   
    if (mode == 'shape') {
        initshapegroups(sindex, mode, 'splashseamdragstarted');
        let side = shape.sides[sideindex];
        let splash = side.splashs[splashindex];
        let splashseam = splash.seams[index];
        if (shapeslabsplashcount(splashindex, sideindex, sindex) < 2) {
            dragdx = d3.event.x - splashseam.x; dragdy = d3.event.y - splashseam.y;           
            bdrag = true;
            drawlogservice.beforeupdate(shape, 'splashseamdragstarted', 8);
        }
        removeshapetools();
    }   
}
function splashseamdragged() {   
    if (bdrag) {
        let index = parseInt(this.getAttribute("index"));
        let splashindex = parseInt(this.getAttribute("splashindex"));
        let sideindex = parseInt(this.getAttribute("sideindex"));
        let sidecode = parseInt(this.getAttribute("sidecode"));
        let sindex = parseInt(this.getAttribute("sindex"));
        let mode = this.getAttribute("smode");
        let side = shape.sides[sideindex];
        let splash = side.splashs[splashindex];
        let splashseam = splash.seams[index];
        let cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        splashseam.x = cx; splashseam.y = cy;
        onsetsidesplashseam(cx, cy, index, splashindex, sideindex, sidecode, splashseam.type, sindex);
    }
}
function splashseamdragended() {
    bdrag = false;
    let index = parseInt(this.getAttribute("index"));
    let splashindex = parseInt(this.getAttribute("splashindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    let sidecode = parseInt(this.getAttribute("sidecode"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let mode = this.getAttribute("smode");
    let seamindex = sindex + "" +  sideindex + "" + splashindex + "" + index;    
    let seammarkerg = seamsg.select("#smarkerg" + seamindex);
    if (!seammarkerg.empty()) { seammarkerg.style("opacity", "0"); }
    ActionUpdateShape();
    ActionUpdateSlabParts();
    drawlogservice.update(shape, 'seamdragended', 7);
}
function showshapesidesplashseam() {
    if (!bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sindex = parseInt(this.getAttribute("sideindex"));
        var smode = this.getAttribute("smode");
        var seamindex = sindex + "" + sideindex + "" + index;
        var seammarkerg = seamsg.select("#" + smode + "smarkerg" + seamindex);
        if (!seammarkerg.empty()) { seammarkerg.style("opacity", "1"); }
        //d3.select(this).attr("class", "shapesideblue");
        d3.select(this).attr("style", "stroke:" + 'blue').style("stroke-opacity", "1.0").style("stroke-width", "15");
    }
}
function hideshapesidesplashseam() {
    if (!bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sindex = parseInt(this.getAttribute("sideindex"));
        var smode = this.getAttribute("smode");
        var seamindex = sindex + "" + sideindex + "" + index;
        var seammarkerg = seamsg.select("#" + smode + "smarkerg" + seamindex);
        if (!seammarkerg.empty()) { seammarkerg.style("opacity", "0"); }
        //d3.select(this).attr("class", "shapeseam");
        let scolor = d3.select(this).attr('scolor');
        d3.select(this).attr("style", "stroke:" + scolor).style("stroke-opacity", "0.1").style("stroke-width", "15");
    }
}