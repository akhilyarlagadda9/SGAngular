function drawsplashsideshapes(index) {
    var side = shape.sides[index];
    for (var j = 0; j < side.sideshapes.length; j++) {
        if (side.sideshapes[j].isactive == 1) {
            setsplashsideshape(0, 0, j, side.sideshapes[j].sideindex, side.sideshapes[j].sidecode);
        }
    }
}
function initsplashsideshape(x, y, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    var sideshape = {};
    sideshape.index = side.sideshapes.length, sideshape.sideindex = sideindex, sideshape.sidecode = sidecode, sideshape.type = sideshapetype,
    sideshape.x = Math.round(x), sideshape.y = Math.round(y), sideshape.w = 84, sideshape.h = 42, sideshape.r = 42, sideshape.isactive = 1;
    if (sideshape.type == 3) {
        if (sidecode == 0) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 2; }
        else if (sidecode == 1) { sideshape.w = side.w1 * scale, sideshape.h = sideshape.r = side.w1 * scale / 2; }
        else if (sidecode == 2) { sideshape.w = side.w2 * scale, sideshape.h = sideshape.r = side.w2 * scale / 2; }
        else if (sidecode == 3) { sideshape.w = side.h, sideshape.h = sideshape.r = side.h / 2; }
    }
    splash.sideshapes.push(sideshape);
}
function onsetsplashsideshape(x, y, index, splashindex, sideindex, sidecode) {
    setsplashsideshape(x, y, index, splashindex, sideindex, sidecode);
}
function setsplashsideshape(x, y, index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    if (index == -1) { index = splash.sideshapes.length, initsplashsideshape(x, y, splashindex, sideindex, sidecode); }
    let sideshape = splash.sideshapes[index], type = sideshape.type;
    if (type == 3 || type == 4) {
        //if (sidecode == 0) { drawarcsplashstartsideshape(index, splashindex, sideindex, sidecode); }
        if (sidecode == 1) { drawarcsplashsideshape1(index, splashindex, sideindex, sidecode); }
        else if (sidecode == 2) { drawarcsplashsideshape2(index, splashindex, sideindex, sidecode); }
        // else if (sidecode == 3) { drawarcsplashendsideshape(index, splashindex, sideindex, sidecode); }
    } else {
        // if (sidecode == 0) { drawbumpinoutsplashstartsideshape(index, splashindex, sideindex, sidecode); }
        if (sidecode == 1) { drawbumpinoutsplashsideshape1(index, splashindex, sideindex, sidecode); }
        else if (sidecode == 2) { drawbumpinoutsplashsideshape2(index, splashindex, sideindex, sidecode); }
        //else if (sidecode == 3) { drawbumpinoutsplashendsideshape(index, splashindex, sideindex, sidecode); }
    }
    ActionShapeReSize();
}
function setsplashsideshapes(splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    for (var i = 0; i < splash.sideshapes.length; i++) {
        if (splash.sideshapes[i].isactive == 1) {
            setsplashsideshape(splash.sideshapes[i].x, splash.sideshapes[i].y, i, splashindex, sideindex, splash.sideshapes[i].sidecode);
        }
    }
}
function onsplashsideshapecontextmenu(index) {
    var m = d3.mouse(this);
    d3.event.preventDefault();
    if (shape.mode == 'shape') {
        var index = parseInt(this.getAttribute("index"));
        var splashindex = parseInt(this.getAttribute("splashindex"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sidecode = parseInt(this.getAttribute("sidecode"));
        var sindex = parseInt(this.getAttribute("sindex"));
        var mode = this.getAttribute("smode");
        initshapegroups(sindex, mode, 'onsplashsideshapecontextmenu');
        //console.log(index, sideindex, sidecode, m[0], m[1]);
        drawsplashsideshapecontrols(index, splashindex, sideindex, sidecode, m[0], m[1]);
    }
}
function onresizesplashsideshape(obj, type, index, splashindex, sideindex) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    var objVal = obj.value.split(" ");
    var val = parseFloat(fractionToDecimal(objVal[0])) + parseFloat(fractionToDecimal(objVal[1]));
    if (type == 0) { sideshape.w = val * scale; }
    else if (type == 1) { sideshape.h = val * scale; }
    else if (type == 2) { sideshape.r = val * scale; }
    setsplashsideshape(0, 0, index, splashindex, sideindex, sideshape.sidecode);
}
function ondeletesplashsideshape(index, splashindex, sideindex) {
    deletesplashsideshape(index, splashindex, sideindex);
    removeshapetools();
}
function deletesplashsideshape(index, splashindex, sideindex) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    sideshape.isactive = 0;
    var sideshapeindex = sideindex + "" + splashindex + "" + index;
    var sideshapeg = splashsg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (!sideshapeg.empty()) { sideshapeg.remove(); }
    ActionShapeReSize();
}
function deletesplashsideshapes(splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    if (splash != undefined) {
        for (var i = 0; i < splash.sideshapes.length; i++) {
            if (splash.sideshapes[i].isactive == 1) {
                deletesplashsideshape(i, splashindex, sideindex);
            }
        }
    }
}
function drawarcsplashstartsideshape(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x11, y11 = splash.y11, x12 = splash.x21, y12 = splash.y21, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);
    if (type == 3) {
        if (lndir == 'we') { h = h; } else if (lndir == 'ns') { h = -h; } else if (lndir == 'ew') { }
        else if (lndir == 'sw') { h = -h; } else if (lndir == 'nw') { asign = 1; } else if (lndir == 'se') { asign = 1; h = -h; }
    } else if (type == 4) {
        if (lndir == 'se' || lndir == 'nw') { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); } }
        else if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }
        if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { dw = -dw, h = -h; } else if (lndir == 'ew') { dw = -dw; }
        else if (lndir == 'sw') { dw = -dw, h = -h; } else if (lndir == 'nw') { asign = 1; dw = -dw; } else if (lndir == 'se') { asign = 1; h = -h; }
        let npt1 = calchyppoint3(dw, angle, asign);
        let dx1 = npt1.dx, dy1 = npt1.dy;
        x11 = x11 + dx1, y11 = y11 + dy1;
        let npt2 = calchyppoint3(w, angle, asign);
        let dx2 = npt2.dx, dy2 = npt2.dy;
        x12 = x11 + dx2, y12 = y11 + dy2;
    }
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    rx = (x21 + x22) / 2; ry = (y21 + y22) / 2;
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapearcline(0, index, type, splashindex, sideindex, sidecode, x11, y11, rx, ry, x12, y12);
    //sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawarcsplashsideshape1(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);
    if (type == 3) {
        if (sidecode == 0) { sideshape.w = side.h * scale; } else if (sidecode == 1) { sideshape.w = side.w1 * scale; }
        else if (sidecode == 2) { sideshape.w = side.w2 * scale; } else if (sidecode == 3) { sideshape.w = side.h * scale; }
        if (lndir == 'we') { h = h; } else if (lndir == 'ns') { h = h; } else if (lndir == 'sn') { h = -h; } else if (lndir == 'ew') { h = -h; }
        else if (lndir == 'sw') { h = -h; } else if (lndir == 'nw') { asign = 1; } else if (lndir == 'se') { asign = 1; h = -h; }
    } else if (type == 4) {
        if (lndir == 'se' || lndir == 'nw') { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); } }
        else if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }
        if (lndir == 'we') { h = h; } else if (lndir == 'ns') { dw = -dw, h = -h; } else if (lndir == 'ew') { dw = -dw; }
        else if (lndir == 'sw') { dw = -dw, h = -h; } else if (lndir == 'nw') { asign = 1; dw = -dw; } else if (lndir == 'se') { asign = 1; h = -h; }
        let npt1 = calchyppoint3(dw, angle, asign);
        let dx1 = npt1.dx, dy1 = npt1.dy;
        x11 = x11 + dx1, y11 = y11 + dy1;
        let npt2 = calchyppoint3(w, angle, asign);
        let dx2 = npt2.dx, dy2 = npt2.dy;
        x12 = x11 + dx2, y12 = y11 + dy2;
    }
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    rx = (x21 + x22) / 2; ry = (y21 + y22) / 2;

    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapearcline(0, index, type, splashindex, sideindex, sidecode, x11, y11, rx, ry, x12, y12);

    //sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
    // console.log(index, lndir, angle, asign, dx, dy, type, x, y);
}
function drawarcsplashsideshape2(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x21, y11 = splash.y21, x12 = splash.x22, y12 = splash.y22, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);
    if (type == 3) {
        sideshape.w = side.w1 * scale;
        if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { h = -h; } else if (lndir == 'ew') { }
        else if (lndir == 'sw') { h = -h; } else if (lndir == 'nw') { asign = 1; } else if (lndir == 'se') { asign = 1; h = -h; }
    } else if (type == 4) {
        h = 2 * h;
        if (lndir == 'se' || lndir == 'nw') { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); } }
        else if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }
        if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { dw = -dw, h = -h; } else if (lndir == 'ew') { dw = -dw; }
        else if (lndir == 'sw') { dw = -dw, h = -h; } else if (lndir == 'nw') { asign = 1; dw = -dw; } else if (lndir == 'se') { asign = 1; h = -h; }
        let npt1 = calchyppoint3(dw, angle, asign);
        let dx1 = npt1.dx, dy1 = npt1.dy;
        x11 = x11 + dx1, y11 = y11 + dy1;
        let npt2 = calchyppoint3(w, angle, asign);
        let dx2 = npt2.dx, dy2 = npt2.dy;
        x12 = x11 + dx2, y12 = y11 + dy2;
    }
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    rx = (x21 + x22) / 2; ry = (y21 + y22) / 2;

    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapearcline(0, index, type, splashindex, sideindex, sidecode, x11, y11, rx, ry, x12, y12);

    //sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
    // console.log(index, lndir, angle, asign, dx, dy, type, x, y);
}

function drawarcsplashendsideshape(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x12, y11 = splash.y12, x12 = splash.x22, y12 = splash.y22, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);
    if (type == 3) {
        sideshape.w = side.w1 * scale;
        if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { h = -h; } else if (lndir == 'ew') { }
        else if (lndir == 'sw') { h = -h; } else if (lndir == 'nw') { asign = 1; } else if (lndir == 'se') { asign = 1; h = -h; }
    } else if (type == 4) {
        if (lndir == 'se' || lndir == 'nw') { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); } }
        else if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }
        if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { dw = -dw, h = -h; } else if (lndir == 'ew') { dw = -dw; }
        else if (lndir == 'sw') { dw = -dw, h = -h; } else if (lndir == 'nw') { asign = 1; dw = -dw; } else if (lndir == 'se') { asign = 1; h = -h; }
        let npt1 = calchyppoint3(dw, angle, asign);
        let dx1 = npt1.dx, dy1 = npt1.dy;
        x11 = x11 + dx1, y11 = y11 + dy1;
        let npt2 = calchyppoint3(w, angle, asign);
        let dx2 = npt2.dx, dy2 = npt2.dy;
        x12 = x11 + dx2, y12 = y11 + dy2;
    }
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    rx = (x21 + x22) / 2; ry = (y21 + y22) / 2;
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapearcline(0, index, type, splashindex, sideindex, sidecode, x11, y11, rx, ry, x12, y12);
    // sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawbumpinoutsplashstartsideshape(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir, dh = 30;
    let w = sideshape.w, h = sideshape.h, angle = 90 - side.angle, asign = 1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x11, y11 = splash.y11, x12 = splash.x21, y12 = splash.y21, dx = Math.abs(x11 - x12), dy = Math.abs(y11 - y12);
    lndir = lndirection(x11, y11, x12, y12);
    if (lndir == 'nw') {
        h = -h;
        if (dx > dy) { dw = Math.abs((x - x11) + w / 2); } else { dw = Math.abs((y - y11) - w / 2); dw = -dw; }
    } else {
        if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }
    }
    if (lndir == 'ew') { dw = -dw; h = -h; } else if (lndir == 'sw') { asign = -1; dw = -dw; }
    else if (lndir == 'sn') { h = -h, asign = -1, dw = -dw; } else if (lndir == 'ne') { h = -h, asign = -1; }
    if (type == 5) { h = -h; }
    //console.log(index, sideindex, lndir, angle, asign, dx, dy, x, x11, dw);
    let npt1 = calchyppoint3(dw, angle, asign);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x11 = x11 + dx1, y11 = y11 + dy1;
    let npt2 = calchyppoint3(w, angle, asign);
    let dx2 = npt2.dx, dy2 = npt2.dy;
    x12 = x11 + dx2, y12 = y11 + dy2;
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    drawsplashsideshapeline(0, lndir, index, splashindex, sideindex, sidecode, x11, y11, x21, y21);
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapeline(2, lndir, index, splashindex, sideindex, sidecode, x21, y21, x22, y22);
    drawsplashsideshapeline(3, lndir, index, splashindex, sideindex, sidecode, x12, y12, x22, y22);
    drawsplashsideshapepath(index, splashindex, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22);
    drawsplashsideshapemarker(0, lndir, index, splashindex, sideindex, sidecode, splash.x11, splash.y11, x11, y11);
    sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawbumpinoutsplashsideshape1(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir, dh = 30;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x11, y11 = splash.y11, x12 = splash.x12, y12 = splash.y12, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);

    if (lndir == 'se' || lndir == 'nw') {
        if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); }
    } else { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); } }
    if (lndir == 'sn') { h = -h; } else if (lndir == 'ne') { h = -h; } else if (lndir == 'ns') { dw = -dw; }
    else if (lndir == 'se') { asign = 1; } else if (lndir == 'nw') { asign = 1; h = -h, dw = -dw; }
    else if (lndir == 'ew') { h = -h, dw = -dw; } else if (lndir == 'sw') { dw = -dw; }
    if (type == 5) { h = -h; }
    let npt1 = calchyppoint3(dw, angle, asign);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x11 = x11 + dx1, y11 = y11 + dy1;
    let npt2 = calchyppoint3(w, angle, asign);
    let dx2 = npt2.dx, dy2 = npt2.dy;
    x12 = x11 + dx2, y12 = y11 + dy2;
    // console.log(lndir, angle, asign, dx, dy);
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    drawsplashsideshapeline(0, lndir, index, splashindex, sideindex, sidecode, x11, y11, x21, y21);
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapeline(2, lndir, index, splashindex, sideindex, sidecode, x21, y21, x22, y22);
    drawsplashsideshapeline(3, lndir, index, splashindex, sideindex, sidecode, x12, y12, x22, y22);
    drawsplashsideshapepath(index, splashindex, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22);
    drawsplashsideshapemarker(0, lndir, index, splashindex, sideindex, sidecode, splash.x11, splash.y11, x11, y11);
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawbumpinoutsplashsideshape2(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir, dh = 30;
    let w = sideshape.w, h = sideshape.h, angle = side.angle, asign = -1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x21, y11 = splash.y21, x12 = splash.x22, y12 = splash.y22, dx = Math.abs(x12 - x11), dy = Math.abs(y12 - y11);

    if (lndir == 'se' || lndir == 'nw') { if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); } }
    else if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) + w / 2); }

    if (lndir == 'we') { h = -h; } else if (lndir == 'ns') { dw = -dw, h = -h; } else if (lndir == 'ew') { dw = -dw; }
    else if (lndir == 'sw') { dw = -dw, h = -h; } else if (lndir == 'nw') { asign = 1; dw = -dw; } else if (lndir == 'se') { asign = 1; h = -h; }

    if (type == 5) { h = -h; }
    let npt1 = calchyppoint3(dw, angle, asign);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x11 = x11 + dx1, y11 = y11 + dy1;
    let npt2 = calchyppoint3(w, angle, asign);
    let dx2 = npt2.dx, dy2 = npt2.dy;
    x12 = x11 + dx2, y12 = y11 + dy2;
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;

    drawsplashsideshapeline(0, lndir, index, splashindex, sideindex, sidecode, x11, y11, x21, y21);
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapeline(2, lndir, index, splashindex, sideindex, sidecode, x21, y21, x22, y22);
    drawsplashsideshapeline(3, lndir, index, splashindex, sideindex, sidecode, x12, y12, x22, y22);
    drawsplashsideshapepath(index, splashindex, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22);
    drawsplashsideshapemarker(0, lndir, index, splashindex, sideindex, sidecode, splash.x21, splash.y21, x11, y11);
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawbumpinoutsplashendsideshape(index, splashindex, sideindex, sidecode) {
    let side = shape.sides[sideindex];
    let splash = side.splashs[splashindex];
    let sideshape = splash.sideshapes[index];
    let lndir = side.lndir, dh = 30;
    let w = sideshape.w, h = sideshape.h, angle = 90 - side.angle, asign = 1, dsign = 1, type = sideshape.type, x = sideshape.x, y = sideshape.y;
    var x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0, dx = 0, dy = 0;
    x11 = splash.x12, y11 = splash.y12, x12 = splash.x22, y12 = splash.y22, dx = Math.abs(x11 - x12), dy = Math.abs(y11 - y12);
    if (dx > dy) { dw = Math.abs((x - x11) - w / 2); } else { dw = Math.abs((y - y11) - w / 2); }
    lndir = lndirection(x11, y11, x12, y12);
    if (lndir == 'sw') { asign = -1; dw = -Math.abs((y - y11) + w / 2); } else if (lndir == 'ew') { dw = -dw, h = -h; }
    else if (lndir == 'nw') { dw = -dw, h = -h; } else if (lndir == 'ne') { h = -h, asign = -1; }
    if (type == 5) { h = -h; }
    console.log(index, sideindex, lndir, angle, asign, dx, dy, x, x11, dw);
    let npt1 = calchyppoint3(dw, angle, asign);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x11 = x11 + dx1, y11 = y11 + dy1;
    let npt2 = calchyppoint3(w, angle, asign);
    let dx2 = npt2.dx, dy2 = npt2.dy;
    x12 = x11 + dx2, y12 = y11 + dy2;
    let npt3 = { dx: 0, dy: 0 };
    npt3 = calcTranslationExact1(-h, x11, y11, x12, y12);
    let dx3 = npt3.dx, dy3 = npt3.dy;
    x21 = x11 + dx3, y21 = y11 + dy3, x22 = x12 + dx3, y22 = y12 + dy3;
    drawsplashsideshapeline(0, lndir, index, splashindex, sideindex, sidecode, x11, y11, x21, y21);
    drawsplashsideshapeline(1, lndir, index, splashindex, sideindex, sidecode, x11, y11, x12, y12);
    drawsplashsideshapeline(2, lndir, index, splashindex, sideindex, sidecode, x21, y21, x22, y22);
    drawsplashsideshapeline(3, lndir, index, splashindex, sideindex, sidecode, x12, y12, x22, y22);
    drawsplashsideshapepath(index, splashindex, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22);
    drawsplashsideshapemarker(0, lndir, index, splashindex, sideindex, sidecode, splash.x21, splash.y21, x11, y11);
    drawsplashsideshapemarker(1, lndir, index, splashindex, sideindex, sidecode, x21, y21, x22, y22);
    drawsplashsideshapemarker(2, lndir, index, splashindex, sideindex, sidecode, x11, y11, x21, y21);
    // sideshape.x = x11, sideshape.y = y11;
    sideshape.x11 = x11, sideshape.y11 = y11, sideshape.x12 = x12, sideshape.y12 = y12;
    sideshape.x21 = x21, sideshape.y21 = y21, sideshape.x22 = x22, sideshape.y22 = y22;
}
function drawsplashsideshapeline(lnindex, lndir, index, splashindex, sideindex, sidecode, x1, y1, x2, y2) {
    var eclass = lnindex == 1 ? 'shapesidewhite' : 'shapeside';
    var sideshapeindex = sideindex + "" + splashindex + "" + index;
    //console.log(lnindex, lndir, shapeindex, sideindex, code, x1, y1, x2, y2);
    var sideshapeg = splashsg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = splashsg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sslineindex = sideindex + "" + splashindex + "" + lnindex;
    var sideshapeline = sideshapeg.select("#sideshape" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "sideshape" + sslineindex); }
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode)
        .attr("sindex", shape.index).attr("smode", shape.mode);
}
function drawsplashsideshapearcline(lnindex, index, type, splashindex, sideindex, sidecode, x1, y1, x2, y2, x3, y3) {
    var eclass = 'sideshapearc', sideshapeindex = sideindex + "" + splashindex + "" + index;
    var sspath = quadraticcurvepath(x1, y1, x2, y2, x3, y3);
    var sideshapeg = splashsg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = splashsg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sideshapepath = sideshapeg.select("#" + "sideshapepath" + index);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + index); }
    sideshapepath.attr("d", sspath).attr("class", eclass).attr("index", index).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("smode", shape.mode)
        .attr("sindex", shape.index).on("contextmenu", onsplashsideshapecontextmenu);
    if (shape.mode != 'print') {
        sideshapepath.on("contextmenu", onsplashsideshapecontextmenu);
        if (type == 4) { sideshapepath.call(splashsideshapedrag); }
    }
}
function drawsplashsideshapepath(index, splashindex, sideindex, sidecode, x11, y11, x12, y12, x21, y21, x22, y22) {
    var eclass = 'sideshape', sideshapeindex = sideindex + "" + splashindex + "" + index;
    var sspath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sspath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    var sideshapeg = splashsg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = splashsg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sideshapepath = sideshapeg.select("#" + "sideshapepath" + index);
    if (sideshapepath.empty()) { sideshapepath = sideshapeg.append("path").attr("id", "sideshapepath" + index); }
    sideshapepath.attr("d", sspath).attr("class", eclass).attr("index", index).attr("splashindex", splashindex).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", shape.index).attr("smode", shape.mode);
    if (shape.mode != 'print') { sideshapepath.on("contextmenu", onsplashsideshapecontextmenu).call(splashsideshapedrag); }
}
function drawsplashsideshapemarker(lnindex, lndir, index, splashindex, sideindex, code, x1, y1, x2, y2) {
    var h = 5; if (code == 2) { h = -h; }
    var npt = calcTranslationExact1(h, x1, y1, x2, y2);
    let dx = npt.dx, dy = npt.dy;
    x1 = x1 + dx, y1 = y1 + dy, x2 = x2 + dx, y2 = y2 + dy;
    var mtx = x1 - (x1 - x2) / 2, mty = y1 - (y1 - y2) / 2, mtext = (x1 - x2) / scale;
    var mtext = Math.round(calchyplen(x1, y1, x2, y2) / scale);
    var sideshapeindex = sideindex + "" + splashindex + "" + index;
    var sideshapeg = splashsg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = splashsg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sslineindex = splashindex + "" + splashindex + "" + lnindex;
    var sideshapeline = sideshapeg.select("#mssline" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "mssline" + sslineindex); }
    var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "cutoutarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
    var markertext = sideshapeg.select("#msstext" + sslineindex);
    if (markertext.empty()) { markertext = sideshapeg.append("text").attr("id", "msstext" + sslineindex).attr("class", "shapemarker"); }
    markertext.attr("x", mtx).attr("y", mty).text(mtext)
}
function drawsplashsideshapemarkertext(index, splashindex, sideindex, sidecode, x, y, mtext) {
    var sideshapeindex = sideindex + "" + shapeindex;
    var sideshapeg = sideshapesg.select("#" + shape.mode + "sideshapeg" + sideshapeindex);
    if (sideshapeg.empty()) { sideshapeg = sideshapesg.append("g").attr("id", shape.mode + "sideshapeg" + sideshapeindex); }
    var sslineindex = shapeindex + "" + lnindex;
    var sideshapeline = sideshapeg.select("#mssline" + sslineindex);
    if (sideshapeline.empty()) { sideshapeline = sideshapeg.append("line").attr("id", "mssline" + sslineindex); }
    var arrowstart = shape.mode == 'print' ? "url(#printtriangle-start)" : "url(#triangle-start)";
    var arrowend = shape.mode == 'print' ? "url(#printtriangle-end)" : "url(#triangle-end)";
    sideshapeline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "cutoutarrow").attr("marker-start", arrowstart).attr("marker-end", arrowend);
    var markertext = sideshapeg.select("#msstext" + sslineindex);
    if (markertext.empty()) { markertext = sideshapeg.append("text").attr("id", "msstext" + sslineindex).attr("class", "shapemarker"); }
    markertext.attr("x", mtx).attr("y", mty).text(mtext)
}
function splashsideshapedragstarted() {
    if (shape.mode == 'shape') {
        var index = parseInt(this.getAttribute("index"));
        var splashindex = parseInt(this.getAttribute("splashindex"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sidecode = parseInt(this.getAttribute("sidecode"));
        var sindex = parseInt(this.getAttribute("sindex"));
        if (shape.index != sindex) { initshapegroups(sindex, 'splashsideshapedragstarted'); }
        var sideshape = shape.sides[sideindex].splashs[splashindex].sideshapes[index];
        dragdx = d3.event.x - sideshape.x, dragdy = d3.event.y - sideshape.y;
    }
}
function splashsideshapedragged() {
    if (shape.mode == 'shape') {
        var index = parseInt(this.getAttribute("index"));
        var splashindex = parseInt(this.getAttribute("splashindex"));
        var sideindex = parseInt(this.getAttribute("sideindex"));
        var sidecode = parseInt(this.getAttribute("sidecode"));
        var sindex = parseInt(this.getAttribute("sindex"));
        var sideshape = shape.sides[sideindex].splashs[splashindex].sideshapes[index];
        var cx = d3.event.x - dragdx, cy = d3.event.y - dragdy;
        sideshape.x = cx, sideshape.y = cy;
        setsplashsideshape(cx, cy, index, splashindex, sideindex, sidecode);
    }
}
function splashsideshapedragended() {
    ActionShapeReSize();
}
