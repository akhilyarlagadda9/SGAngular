function initdglayout32(mode) {
    initdgmatareas32(mode);
}
function initdgmatareas32(mode, source) {  
    source += 'initdglayout';   
    if (mode != 'print') { d3.select('.mdgsvg0').selectAll('*').remove(); }
    let matindex = msvg.attr("index");   
    let material = getmaterialbyindex(matindex);    
    if (material == undefined) { return;}
    for (let index = 0; index < material.AreaList.length; index++) {      
        let area = getareabyid(material.AreaList[index].ID);     
        if (area != null && area.PartList != null) {
            let areapartlist = area.PartList; 
            if (areapartlist.length > 0) {
                let areaindex = index + "" + area.VersionID + "" + area.ExNo; let pmdindex = areaindex;
                if (mode != 'print') { pmdindex = 0; }
                let mdgareaheader = d3.select("#mdgareaheader" + areaindex);
                if (mdgareaheader.empty()) { mdgareaheader = d3.select('.mdgsvg' + "" + pmdindex).append("div").attr("id", "mdgareaheader" + areaindex); }
                mdgareaheader.attr("style", "font-weight:bold;color:blue;font-size:18px;").html((index + 1) + "." + area.Name);
                mdgsvg = d3.select("#mdgsvg" + areaindex);
                if (mdgsvg.empty()) { mdgsvg = d3.select('.mdgsvg' + "" + pmdindex).append("svg").attr("id", "mdgsvg" + areaindex).on("wheel", zoommousewheelpart); } else { mdgsvg.selectAll('*').remove(); }
                mdgsvg.attr("width", mdglwidth - 200).attr("height", mdglheight).attr("style", "border:1px solid #ddd").attr("index", index).attr("areaid", area.ID).attr("versionid", area.VersionID)
                mdgslabpartsg = mdgsvg.select("#mdgslabpartsg" + area.ID); if (mdgslabpartsg.empty()) { mdgslabpartsg = mdgsvg.append("g").attr("id", "mdgslabpartsg" + area.ID); }
                arealabelsg = mdgslabpartsg.select("#arealabelsg"); if (arealabelsg.empty()) { arealabelsg = mdgslabpartsg.append("g").attr("id", "arealabelsg"); }
                drawdgslabpartshapes32(areapartlist, 'shapedg', source);
                drawdgslabpartshapes321(areapartlist, 'shapedg', source);
            }
        }
    }
    initshapedgdrawingcontrols();
}
function initprintdgmatareas32(mode, source) {
    source += 'initdglayout';
    let areas = getversionareas();  
    for (let index = 0; index < areas.length; index++) {
        let area = areas[index];
        if (area != null && area.PartList != null) {
            let areapartlist = area.PartList;
            if (areapartlist.length > 0) {
                let areaindex = index + "" + area.VersionID + "" + area.ExNo; let pmdindex = areaindex;
                if (mode != 'print') { pmdindex = 0; }
                if (mode == 'print') { apdefssvg = d3.select("#areadefssvg"); if (apdefssvg.empty()) { apdefssvg = d3.select('.areadefssvg').append("svg").attr("id", "areadefssvg"); } }
                let mdgareaheader = d3.select("#mdgareaheader" + areaindex);
                if (mdgareaheader.empty()) { mdgareaheader = d3.select('.mdgsvg' + "" + pmdindex).append("div").attr("id", "mdgareaheader" + areaindex); }
                mdgareaheader.attr("style", "font-weight:bold;color:blue;font-size:18px;").html((index + 1) + "." + area.Name);
                mdgsvg = d3.select("#mdgsvg" + areaindex);
                if (mdgsvg.empty()) { mdgsvg = d3.select('.mdgsvg' + "" + pmdindex).append("svg").attr("id", "mdgsvg" + areaindex).on("wheel", zoommousewheelpart); } else { mdgsvg.selectAll('*').remove(); }
                mdgsvg.attr("width", mdglwidth).attr("height", mdglheight).attr("style", "border:1px solid #ddd").attr("index", index).attr("areaid", area.ID).attr("versionid", area.VersionID)
                mdgslabpartsg = mdgsvg.select("#mdgslabpartsg" + area.ID); if (mdgslabpartsg.empty()) { mdgslabpartsg = mdgsvg.append("g").attr("id", "mdgslabpartsg" + area.ID); }
                arealabelsg = mdgslabpartsg.select("#arealabelsg"); if (arealabelsg.empty()) { arealabelsg = mdgslabpartsg.append("g").attr("id", "arealabelsg"); }
                drawdgslabpartshapes32(areapartlist, 'shapedg', source);
                drawdgslabpartshapes321(areapartlist, 'shapedg', source);
            }
        }
    }
    initshapedgdrawingcontrols();
}

function getslabpartdgshapesidepath32(sideindex, source) {
    let sidepoints = getshapesidepoints(sideindex);
    let spath = shapesidepath32(sidepoints);
    return spath;
}
function setslabpartclipbounds32(spindex, partsrno, areaid) {
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    let slabpartdgclippath = slabpartdgouterg.select("#slabpartdgclippath" + areashapeslabpartindex);
    let spclipnode = slabpartdgclippath.node();
    let clipx = spclipnode.getBBox().x + spclipnode.getBBox().width / 2; clipy = spclipnode.getBBox().y + spclipnode.getBBox().height / 2;
    shape.clipx = clipx.toFixed(), shape.clipy = clipy.toFixed();
}
function onsetslabpartclipimage32(source) {
    let smode = 'shapedg';
    source += 'onsetslabpartclipimage32';
    let partsrno = shape.partsrno, index = partsrno - 1, spindex = shape.spindex, areaid = shape.areaid, slabid = shape.slabid, slabsrno = shape.slabsrno, slabindex = shape.slabindex, areashapeindex = areaid + "" + index;
    let mslabindex = slabid + "" + slabsrno;
    let partshapeouterg = d3.select("#" + smode + "outer" + areashapeindex);
    if (partshapeouterg.empty()) { return; }
    let slabptrnimg = d3.select("#" + "slabptrnimg" + mslabindex);
    //console.log(partsrno, spindex, areaid, slabid, slabsrno, mslabindex, "#" + smode + "outer" + areashapeindex, slabptrnimg.empty(), partshapeouterg.empty());
    if (!slabptrnimg.empty()) {
        let mslabx = slabptrnimg.attr("x"), mslaby = slabptrnimg.attr("y");
        shape.slabx = mslabx, shape.slaby = mslaby;
        drawdgshapeslabpart32(spindex, partsrno, areaid, smode, source);
        setslabpartclipbounds32(spindex, partsrno, areaid);
        rotateslabpartshape32(spindex, partsrno, areaid);
    } else {
        removedgshapeslabparts32(partsrno, spindex, areaid, source);
    }
}
function onsetslabpartdgshapeseam32(source) {
    let partsrno = shape.partsrno, spindex = shape.spindex, areaid = shape.areaid, smode = 'shapedg';
    initdgmatareas32('slabpart', source);
   // drawdgshapeslabpart32(spindex, partsrno, areaid, smode, source);
}
function drawdgslabpartshapes32(areapartlist, smode, source) {
    drawarealabels(source);
    if (areapartlist != null && areapartlist.length > 0) {
        for (let i = 0; i < areapartlist.length; i++) {
            if (areapartlist[i].IsActive == 1 && areapartlist[i].Shape != null && areapartlist[i].Shape != 'null' && areapartlist[i].Shape != '') {
                drawdgshape32(areapartlist[i].SrNo, areapartlist[i].AreaID, smode, source);
            }
        }
        resetareamdsvgbounds();
    }
    //resetmdsvgbounds1();
}
function drawdgslabpartshapes321(areapartlist, smode, source) {
    drawarealabels(source);
    if (areapartlist != null && areapartlist.length > 0) {
        for (let i = 0; i < areapartlist.length; i++) {
            if (areapartlist[i].IsActive == 1 && areapartlist[i].Shape != null && areapartlist[i].Shape != 'null' && areapartlist[i].Shape != '') {               
                let tmppartshape = getpartshapebyareapartsrno(areapartlist[i].SrNo, areapartlist[i].AreaID);
                if (layoutmode == 2) {
                    drawdgshapeslabparts32(areapartlist[i].SrNo, areapartlist[i].AreaID, smode, tmppartshape, source);
                    drawdgshapeslabsplashs32(areapartlist[i].SrNo, areapartlist[i].AreaID, smode, tmppartshape, source);
                }
            }
        }
    }
}
function drawdgshape32(partsrno, areaid, smode, source) {
    shape = getpartshapebyareapartsrno(partsrno, areaid);
    if (shape != undefined) {
        let index = partsrno - 1;
        drawshape32(index, smode, 'drawdgshape32');
    }
}
function drawdgshapeslabparts32(partsrno, areaid, smode, tmppartshape, source) {
    for (let i = 0; i < tmppartshape.slabparts.length; i++) {
        let pslabpart = tmppartshape.slabparts[i];
        let index = partsrno + "" + i, spindex = pslabpart.index, startseamindex = pslabpart.startseamindex, startsideindex = pslabpart.startsideindex, endseamindex = pslabpart.endseamindex, endsideindex = pslabpart.endsideindex;
        setpartshapeslabpart32(index, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, smode, source);
        //console.log(i, shape.slabx, shape.tx, shape.slaby, shape.ty, shape.slabindex, shape.slabid, shape.materialid)
        if (shape.slabx != undefined && shape.slaby != undefined) {
            drawdgshapeslabpart32(i, partsrno, areaid, smode, source);
            rotateslabpartshape32(i, partsrno, areaid);
        }
    }
}
function drawdgshapeslabpart32(spindex, partsrno, areaid, smode, source) {
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let partshapeouterg = d3.select("#" + smode + "outer" + areashapeindex);
    let partshapeg = partshapeouterg.select("#" + smode + areashapeindex);
    //console.log(spindex, partsrno, areaid, smode, "#" + smode + "outer" + areashapeindex, "#" + smode + areashapeindex, partshapeg.empty());
    let slabpartdgouterg = partshapeouterg.select("#slabpartdgouter" + areashapeslabpartindex);
    if (slabpartdgouterg.empty()) { slabpartdgouterg = partshapeouterg.append("g").attr("id", "slabpartdgouter" + areashapeslabpartindex); }
    else { slabpartdgouterg.selectAll('*').remove(); }
    if (partshapeg.attr("transform") != null) { slabpartdgouterg.attr("transform", partshapeg.attr("transform")); }
    drawslabpartshapeimage32(spindex, partsrno, areaid);
    drawslabpartshapeclippath32(spindex, partsrno, areaid);
}
function drawslabpartshapeimage32(spindex, partsrno, areaid) {
    let areashapeindex = 0, areashapeslabpartindex = 0, sindex = 0;
    let slabindex = shape.slabindex, slabsrno = shape.slabsrno, slabid = shape.slabid, matid = shape.materialid;
    let mslablist = getmatslablistbymaterialid(matid);
    areashapeindex = areaid + "" + (partsrno - 1);
    areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    //  console.log(areashapeindex, areashapeslabpartindex, slabindex, slabid, matid, spindex, partsrno, areaid, mslablist.length);
    let mslab = mslablist[slabindex];

    let mdgslabx = 0, mdgslaby = 0, mslabw = applymminchfact(mslab.Width, 1, 0), mslabh = applymminchfact(mslab.Length, 1, 0), mslabimgpath = mslab.Path;
    //console.log(slabindex, matindex, spindex, partsrno, areaid, mslabid);
    if (mslabimgpath == null) { return; }

    //if (mslab.ValidPath == -2) { mslabimgpath = contentPath + "Product/" + mslab.Path; } else if (mslabimgpath.indexOf('.jpg') == -1) { mslabimgpath = contentPath + "Inventory/" + mslab.Path + '.jpg'; }
    if (mslabimgpath.indexOf('.jpg') == -1) { mslabimgpath = contentpath1 + mslab.Path + '.jpg'; }
 
    //1. cal slab relative position(topleft) from slabpart position(topleft) and save for slabpart.
    //let slabptrnimg = d3.select("#" + "slabptrnimg" + mslabid);
    //mslabx = slabptrnimg.attr("x"), mslaby = slabptrnimg.attr("y");
    mdgslabx = shape.slabx - shape.tx, mdgslaby = shape.slaby - shape.ty;
    // console.log(areashapeindex, areashapeslabpartindex, slabindex, slabid, matid, spindex, partsrno, areaid, mslablist.length, shape.slabx, shape.tx, shape.slaby, shape.ty, mdgslabx, mdgslaby);

    //1.draw slabpart slab image
    let d = new Date(), extn = d.getMilliseconds();
    let hrefpath = mslabimgpath + "?" + extn;
    let dgprintmode = getprintdigitalmode();
    if (dgprintmode == 1) {
        hrefpath = qsgetbase64code(mslabimgpath);       
    }
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    let slabptrndgimg = slabpartdgouterg.select("#slabptrndgimg" + areashapeslabpartindex);
    if (slabptrndgimg.empty()) { slabptrndgimg = slabpartdgouterg.append("image").attr("id", "slabptrndgimg" + areashapeslabpartindex); }
    slabptrndgimg.attr("slabindex", slabindex).attr("slabsrno", slabsrno).attr("x", mdgslabx).attr("y", mdgslaby).attr("width", mslabw).attr("height", mslabh)
        .attr("preserveAspectRatio", "xMinYMin slice").attr("href", hrefpath);
    //2. apply clip path to slabimage using slabpart measurements.
    slabptrndgimg.attr("clip-path", "url(#slabpartdgclippath" + areashapeslabpartindex + ")");
}
function drawslabpartshapeclippath32(spindex, partsrno, areaid) {
    let source = 'drawslabpartshapeclippath32';
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    let slabpartdgclippath = slabpartdgouterg.select("#slabpartdgclippath" + areashapeslabpartindex);
    if (slabpartdgclippath.empty()) { slabpartdgclippath = slabpartdgouterg.append("clipPath").attr("id", "slabpartdgclippath" + areashapeslabpartindex).attr("clipPathUnits", "userSpaceOnUse"); }
    let spath = getslabpartdgshapesidepath33(source);
    let spsideclippath = slabpartdgclippath.select("#spsideclippath" + areashapeslabpartindex);
    if (spsideclippath.empty()) { spsideclippath = slabpartdgclippath.append("path").attr("id", "spsideclippath" + areashapeslabpartindex); }
    spsideclippath.attr("d", spath);  
}
function rotateslabpartshape32(spindex, partsrno, areaid) {
    //1.rotate slabpartclippath  
    if (shape.angle == 0) { return; }
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);

    let slabpartdgclippath = slabpartdgouterg.select("#slabpartdgclippath" + areashapeslabpartindex);
    if (shape.clipx == undefined || shape.clipy == undefined) { setslabpartclipbounds32(spindex, partsrno, areaid); }
    //console.log(spindex, partsrno, areaid, shape.clipx, shape.clipy);
    let spangle = shape.angle, clipx = shape.clipx, clipy = shape.clipy;
    let npt = [clipx, clipy];
    slabpartdgclippath.attr("transform", "rotate(" + spangle + "," + npt + ")");
    //2.rotate slabpartdgimage
    let slabptrndgimg = slabpartdgouterg.select("#slabptrndgimg" + areashapeslabpartindex);
    slabptrndgimg.attr("transform", "rotate(" + -spangle + "," + npt + ")");
}
function removedgshapeslabparts32(partsrno, spindex, areaid, source) {
    let smode = 'shapedg';
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabpartindex = areaid + "" + partsrno + "" + spindex;
    let partshapeouterg = d3.select("#" + smode + areashapeindex);
    let slabpartdgouterg = d3.select("#slabpartdgouter" + areashapeslabpartindex);
    slabpartdgouterg.selectAll('*').remove();
}

function zoommousewheelpart() {
    let dgprintmode = getprintdigitalmode();
    if (dgprintmode != 1) {
        //prevent browser zooming
        d3.event.preventDefault();
        //d3.event.stopImmediatePropagation();
        let direction = d3.event.deltaY < 0 ? 'down' : 'up';
        if (direction == 'up') {
            mldgzoomclick(1);
        } else {
            mldgzoomclick(0);
        }
    }
}
function mldgzoomclick(ztype) {
    mdglzscale = roundToOne(mdglzscale);
    let scaleto = ztype == 0 ? roundToOne(mdglzscale - 0.1) : roundToOne(mdglzscale + 0.1);
    if (scaleto <= 0.1) { scaleto = 0.1; }
    mdglzscale = roundToOne(scaleto);
    let matindex = msvg.attr("index");
    let material = getmaterialbyindex(matindex);
    for (let index = 0; index < material.AreaList.length; index++) {
        let area = getareabyid(material.AreaList[index].ID);
        if (area != null && area.PartList != null) {
            let areapartlist = area.PartList;
            if (areapartlist.length > 0) {
                let areaindex = index + "" + area.VersionID + "" + area.ExNo; let pmdindex = areaindex;
                mdgsvg = d3.select("#mdgsvg" + areaindex);
                mdgslabpartsg = mdgsvg.select("#mdgslabpartsg" + area.ID);
                resetmdsvgbounds1();
            }
        }
    }
    $('#txtmldgzoom').html((Math.round(roundToOne(mdglzscale) * 100)) + "%");
}
function resetmdsvgbounds1() {
    let gnode = mdgslabpartsg.node().getBBox(), w = Math.round(gnode.width), h = Math.round(gnode.height), sx = Math.round(gnode.x + w / 2), sy = Math.round(gnode.y + h / 2);
    //mdgsvg.style("height", h + 30);
    if (h > mdglheight) { mdgsvg.style("height", (h / 2) + mdglheight); }
    if (w != 0 && h != 0) {
        let mdgsvgnode = mdgsvg.node(), mdgsvgw = mdgsvgnode.clientWidth, mdgsvgh = mdgsvgnode.clientHeight;
        let mdgtx = Math.round((mdgsvgw / 2) - (mdglzscale * sx)), mdgty = Math.round((mdgsvgh / 2) - (mdglzscale * sy));
        let translate = [mdgtx, mdgty];
        //console.log(mdglheight, w, h, sx, sy, mdgsvgw, mdgsvgh, mdgsvgnode.clientTop, mdgsvgnode.clientLeft, gnode.x, gnode.y);
        mdgslabpartsg.attr('transform', 'translate(' + translate + ') scale(' + mdglzscale + ')');
    }
}
function resetareamdsvgbounds() {
    let gnode = mdgslabpartsg.node().getBBox(), w = Math.round(gnode.width), h = Math.round(gnode.height), sx = Math.round(gnode.x + w / 2), sy = Math.round(gnode.y + h / 2);
    //mdgsvg.style("height", h + 30);
    if (h > mdglheight) { mdgsvg.style("height", (h / 2) + mdglheight); }
    if (w != 0 && h != 0) {
        let mdgsvgnode = mdgsvg.node(), mdgsvgw = mdgsvgnode.clientWidth, mdgsvgh = mdgsvgnode.clientHeight;
        let mdgscale = roundToPlaces((0.9) / Math.max(w / mdgsvgw, h / mdgsvgh), 2);
        let mdgtx = Math.round((mdgsvgw / 2) - (mdgscale * sx)), mdgty = Math.round((mdgsvgh / 2) - (mdgscale * sy));
        let translate = [mdgtx, mdgty];
        //console.log(w, h, sx, sy, mdglheight, mdgsvgw, mdgsvgh, mdgscale, mdgsvgnode.clientTop, mdgsvgnode.clientLeft, gnode.x, gnode.y);
        mdgslabpartsg.attr('transform', 'translate(' + translate + ') scale(' + mdgscale + ')');
        if (mdgscale < mdglzscale) { mdglzscale = mdgscale; }
    }
}

//slab splashes
function getslabsplashdgshapepath32(source) {
    let x11 = shapeslabsplash.x11, y11 = shapeslabsplash.y11, x12 = shapeslabsplash.x12, y12 = shapeslabsplash.y12;
    let x21 = shapeslabsplash.x21, y21 = shapeslabsplash.y21, x22 = shapeslabsplash.x22, y22 = shapeslabsplash.y22;
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    return spath;
}
function setslabsplashclipbounds32(splindex, spsplashindex, spsideindex, partsrno, areaid) {
    let areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let slabsplashdgouterg = d3.select("#slabsplashdgouter" + areashapeslabsplashindex);
    let slabsplashdgclippath = slabsplashdgouterg.select("#slabsplashdgclippath" + areashapeslabsplashindex);
    let splclipnode = slabsplashdgclippath.node();
    let clipx = splclipnode.getBBox().x + splclipnode.getBBox().width / 2; clipy = splclipnode.getBBox().y + splclipnode.getBBox().height / 2;
    shapeslabsplash.clipx = clipx.toFixed(), shapeslabsplash.clipy = clipy.toFixed();
}
function onsetslabsplashclipimage32() {
    let source = 'onsetslabsplashclipimage32', smode = 'shapedg';
    let splindex = shapeslabsplash.splindex, spsplashindex = shapeslabsplash.spsplashindex, spsideindex = shapeslabsplash.spsideindex,
        partsrno = shapeslabsplash.partsrno, index = partsrno - 1, areaid = shapeslabsplash.areaid, slabid = shapeslabsplash.slabid, slabsrno = shapeslabsplash.slabsrno,
        slabindex = shapeslabsplash.slabindex, areashapeindex = areaid + "" + index;
    let mslabindex = slabid + "" + slabindex;
    let partshapeouterg = d3.select("#" + smode + "outer" + areashapeindex);    
    if (partshapeouterg.empty()) { return; }
    let slabptrnimg = d3.select("#" + "slabptrnimg" + mslabindex);
    //console.log(splindex, spsplashindex, spsideindex, partsrno, index, areaid, smode, areashapeindex, partshapeouterg.empty(),slabptrnimg.empty(),mslabindex,  source);
    if (!slabptrnimg.empty()) {
        let mslabx = slabptrnimg.attr("x"), mslaby = slabptrnimg.attr("y");
        shapeslabsplash.slabx = mslabx, shapeslabsplash.slaby = mslaby;
        drawdgshapeslabsplash32(splindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
        setslabsplashclipbounds32(splindex, spsplashindex, spsideindex, partsrno, areaid);
        rotateslabsplashshape32(splindex, spsplashindex, spsideindex, partsrno, areaid);
    } else {
        removedgshapeslabsplashs32(splindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
    }
}
function drawdgshapeslabsplashs32(partsrno, areaid, smode, tmppartshape, source) {
    if (tmppartshape.sides != null && tmppartshape.sides != undefined) {
        for (let i = 0; i < tmppartshape.sides.length; i++) {
            for (let j = 0; j < tmppartshape.sides[i].splashs.length; j++) {
                if (tmppartshape.sides[i].splashs[j].isactive == 1) {
                    for (let k = 0; k < tmppartshape.sides[i].splashs[j].slabsplashs.length; k++) {
                        let slabsplash = tmppartshape.sides[i].splashs[j].slabsplashs[k];
                        let splindex = slabsplash.splindex, startseamindex = slabsplash.startseamindex, endseamindex = slabsplash.endseamindex, spsplashindex = j, spsideindex = i;
                        let index = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;    
                        onsetslabsplash32(index, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
                        //console.log(index, splindex, startseamindex, spsplashindex, spsideindex, partsrno, areaid, shapeslabsplash.slabx, shapeslabsplash.slaby, source);
                        if (shapeslabsplash.slabx != undefined && shapeslabsplash.slaby != undefined) {
                            drawdgshapeslabsplash32(splindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
                            setslabsplashclipbounds32(splindex, spsplashindex, spsideindex, partsrno, areaid);
                            rotateslabsplashshape32(splindex, spsplashindex, spsideindex, partsrno, areaid);
                        }
                    }
                }
            }
        }
    }
}
function drawdgshapeslabsplash32(splindex, spsplashindex, spsideindex, partsrno, areaid, smode, source) {
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let partshapeouterg = d3.select("#" + smode + "outer" + areashapeindex);
    let partshapeg = d3.select("#" + smode + areashapeindex);
    //console.log(splindex, spsplashindex, spsideindex, partsrno, areaid, smode, source, partshapeg);
    let slabsplashdgouterg = partshapeouterg.select("#slabsplashdgouter" + areashapeslabsplashindex);
    if (slabsplashdgouterg.empty()) { slabsplashdgouterg = partshapeouterg.append("g").attr("id", "slabsplashdgouter" + areashapeslabsplashindex); }
    else { slabsplashdgouterg.selectAll('*').remove(); }
    if (partshapeg.attr("transform") != null) { slabsplashdgouterg.attr("transform", partshapeg.attr("transform")); }
    drawslabsplashimage32(splindex, spsplashindex, spsideindex, partsrno, areaid);
    drawslabsplashclippath32(splindex, spsplashindex, spsideindex, partsrno, areaid);
}
function drawslabsplashimage32(splindex, spsplashindex, spsideindex, partsrno, areaid) {
    let areashapeindex = 0, areashapeslabsplashindex = 0, sindex = 0;
    let slabindex = shapeslabsplash.slabindex, slabid = shapeslabsplash.slabid, matid = shapeslabsplash.materialid;
    //console.log(slabindex, slabid, matid, splindex, spsplashindex, spsideindex, partsrno, areaid);
    if (matid == undefined || matid == 0) { return;}
    let mslablist = getmatslablistbymaterialid(matid);
    if (mslablist == undefined || mslablist.length == 0) { return;}
    let mslab = mslablist[slabindex];
    if (mslab == undefined) { return; }
    let mdgslabx = 0, mdgslaby = 0, mslabw = applymminchfact(mslab.Width, 1, 0), mslabh = applymminchfact(mslab.Length, 1, 0), mslabimgpath = mslab.Path;
    
    if (mslabimgpath == null) { return; }
    areashapeindex = areaid + "" + (partsrno - 1);
    areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    //if (mslab.ValidPath == -2) { mslabimgpath = contentPath + "Product/" + mslab.Path; } else if (mslabimgpath.indexOf('.jpg') == -1) { mslabimgpath = contentPath + "Inventory/" + mslab.Path + '.jpg'; }
    if (mslabimgpath.indexOf('.jpg') == -1) { mslabimgpath = contentpath1 + mslab.Path + '.jpg'; }

    //1. cal slab relative position(topleft) from slabpart position(topleft) and save for slabpart.
    //let slabptrnimg = d3.select("#" + "slabptrnimg" + mslabid);
    //mslabx = slabptrnimg.attr("x"), mslaby = slabptrnimg.attr("y");
    mdgslabx = shapeslabsplash.slabx - shapeslabsplash.tx, mdgslaby = shapeslabsplash.slaby - shapeslabsplash.ty;
    // console.log(shapeslabsplash.slabx, shapeslabsplash.tx, shapeslabsplash.slaby, shapeslabsplash.ty, mdgslabx, mdgslaby);

    //1.draw slabpart slab image 
    let d = new Date(), extn = d.getMilliseconds();
    let hrefpath = mslabimgpath + "?" + extn;
    let dgprintmode = getprintdigitalmode();
    if (dgprintmode == 1 && mslab.Path != null && mslab.Path != '') {
        hrefpath = qsgetbase64code(mslabimgpath);
    }
    let slabsplashdgouterg = d3.select("#slabsplashdgouter" + areashapeslabsplashindex);
    let slabsplashptrndgimg = slabsplashdgouterg.select("#slabsplashptrndgimg" + areashapeslabsplashindex);
    if (slabsplashptrndgimg.empty()) { slabsplashptrndgimg = slabsplashdgouterg.append("image").attr("id", "slabsplashptrndgimg" + areashapeslabsplashindex); }
    slabsplashptrndgimg.attr("slabindex", slabindex).attr("x", mdgslabx).attr("y", mdgslaby).attr("width", mslabw).attr("height", mslabh).attr("preserveAspectRatio", "xMinYMin slice")
    .attr("href", hrefpath);
    //2. apply clip path to slabimage using slabpart measurements.
    slabsplashptrndgimg.attr("clip-path", "url(#slabsplashdgclippath" + areashapeslabsplashindex + ")");
}
function drawslabsplashclippath32(splindex, spsplashindex, spsideindex, partsrno, areaid) {
    let source = 'drawslabsplashclippath32';
    let areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let slabsplashdgouterg = d3.select("#slabsplashdgouter" + areashapeslabsplashindex);
    let slabsplashdgclippath = slabsplashdgouterg.select("#slabsplashdgclippath" + areashapeslabsplashindex);
    if (slabsplashdgclippath.empty()) { slabsplashdgclippath = slabsplashdgouterg.append("clipPath").attr("id", "slabsplashdgclippath" + areashapeslabsplashindex).attr("clipPathUnits", "userSpaceOnUse"); }
    let spath = getslabsplashdgshapepath32(source);
    let splclippath = slabsplashdgclippath.select("#splclippath" + areashapeslabsplashindex);
    if (splclippath.empty()) { splclippath = slabsplashdgclippath.append("path").attr("id", "splclippath" + areashapeslabsplashindex); }
    // console.log(i, spath);
    splclippath.attr("d", spath);
}
function rotateslabsplashshape32(splindex, spsplashindex, spsideindex, partsrno, areaid) {
    //console.log(splindex, spsplashindex, spsideindex, partsrno, areaid, shapeslabsplash.angle);
    //1.rotate slabpartclippath
    if (shapeslabsplash.angle == 0) { return; }
    let areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let slabsplashdgouterg = d3.select("#slabsplashdgouter" + areashapeslabsplashindex);
    let slabsplashdgclippath = slabsplashdgouterg.select("#slabsplashdgclippath" + areashapeslabsplashindex);
    if (shapeslabsplash.clipx == undefined || shapeslabsplash.clipy == undefined) { setslabsplashclipbounds32(splindex, spsplashindex, spsideindex, partsrno, areaid); }
    // console.log(splindex, spsplashindex, spsideindex, partsrno, areaid, shapeslabsplash.angle, shapeslabsplash.clipx, shapeslabsplash.clipy);
    let spangle = shapeslabsplash.angle, clipx = shapeslabsplash.clipx, clipy = shapeslabsplash.clipy;
    let npt = [clipx, clipy];
    slabsplashdgclippath.attr("transform", "rotate(" + spangle + "," + npt + ")");
    //2.rotate slabpartdgimage
    let slabsplashptrndgimg = slabsplashdgouterg.select("#slabsplashptrndgimg" + areashapeslabsplashindex);
    slabsplashptrndgimg.attr("transform", "rotate(" + -spangle + "," + npt + ")");
}
function removedgshapeslabsplashs32(splindex, spsplashindex, spsideindex, partsrno, areaid, source) {
    let smode = 'shapedg';
    let index = partsrno - 1, areashapeindex = areaid + "" + index;
    let areashapeslabsplashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let partshapeouterg = d3.select("#" + smode + areashapeindex);
    let slabsplashdgouterg = d3.select("#slabsplashdgouter" + areashapeslabsplashindex);
    slabsplashdgouterg.selectAll('*').remove();
}
function showdgslabpartshape34() {
    if (layoutmode == 2) { return; }
    let smode = 'shapedg';    
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let shapesidelen = parseInt(this.getAttribute("sidelen"));
    let areaid = parseInt(this.getAttribute("areaid")); 
    let tmppartshape = getpartshapebyareapartsrno(partsrno, areaid);
    let scolor = "khaki", fillopacity = "1.0";
    for (let i = 0; i < tmppartshape.sides.length; i++) {
        let tmpshapeside = tmppartshape.sides[i];
        showdgslabpartshapeside34(i, areaid, tmppartshape.index, smode, scolor, fillopacity);
        showdgslabpartshapesidecorners34(tmpshapeside, areaid, tmppartshape.partsrno, tmppartshape.index, smode, scolor, fillopacity);
        showdgslabpartshapesideshapes34(tmpshapeside, areaid, tmppartshape.partsrno, tmppartshape.index, smode, scolor, fillopacity);
    }    
}
function showdgslabpartshapeside34(sideindex, areaid, sindex, smode, scolor, fillopacity) {
    let sidepathindex = areaid + "" + sindex + "" + sideindex;
    let dgslabpartshapepath = d3.select("#" + smode + "sidepath" + sidepathindex);    
    dgslabpartshapepath.style("fill", scolor).style("fill-opacity", fillopacity);
}
function showdgslabpartshapesidecorners34(tmpshapeside, areaid, partsrno, sindex, smode, scolor, fillopacity) {
    for (let i = 0; i < tmpshapeside.corners.length; i++) {
        let sidecorner = tmpshapeside.corners[i];
        if (sidecorner.typeid != 0 && sidecorner.typeid != 1) {
            let cornerindex = sindex + "" + areaid + "" + partsrno + "" + sidecorner.sideindex + "" + sidecorner.sidecode + "" + i;
            let cornerpath = d3.select("#" + smode + "corner" + cornerindex);           
            cornerpath.style("fill", scolor).style("fill-opacity", fillopacity);
        }
    }
}
function showdgslabpartshapesideshapes34(tmpshapeside, areaid, partsrno, sindex, smode, scolor, fillopacity) {
    for (let i = 0; i < tmpshapeside.sideshapes.length; i++) {
        let sideshape = tmpshapeside.sideshapes[i];      
        let typeid = sideshape.typeid, sidecode = sideshape.sidecode, sideindex = sideshape.sideindex;
        if (typeid != 1 && typeid != 2 && typeid != 3) {
            let sideshapeindex = sindex + "" + areaid + "" + partsrno + "" + sideindex + "" + sidecode + "" + i;           
            let sideshapepath = d3.select("#" + smode + "sideshapepath" + sideshapeindex);
            //console.log(areaid, partsrno, sindex, smode, scolor, fillopacity, sideshapeindex, sideshapepath.empty());
            sideshapepath.style("fill", scolor).style("fill-opacity", fillopacity);
        }
    }
}
function hidedgslabpartshape34() {
    if (layoutmode == 2) { return; }
    let smode = 'shapedg';
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let shapesidelen = parseInt(this.getAttribute("sidelen"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let tmppartshape = getpartshapebyareapartsrno(partsrno, areaid);
    let scolor = tmppartshape.color, fillopacity = "0.2";
    for (let i = 0; i < tmppartshape.sides.length; i++) {
        let tmpshapeside = tmppartshape.sides[i];
        showdgslabpartshapeside34(i, areaid, tmppartshape.index, smode, scolor, fillopacity);
        showdgslabpartshapesidecorners34(tmpshapeside, areaid, tmppartshape.partsrno, tmppartshape.index, smode, scolor, fillopacity);
        showdgslabpartshapesideshapes34(tmpshapeside, areaid, tmppartshape.partsrno, tmppartshape.index, smode, scolor, fillopacity);
    }
}
function showdgslabsplashshape34() {
    if (layoutmode == 2) { return; }
    let smode = 'shapedg';  
    let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));   
    let spgindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex;    
    let slabsplashpathg = d3.select("#" + smode + "splashpath" + spgindex);
    //console.log(areaid, partsrno, spsideindex, spsplashindex, spgindex, slabsplashpathg.empty());
    let scolor = "khaki", fillopacity = "1.0";
    if (!slabsplashpathg.empty()) { slabsplashpathg.style("fill", scolor).style("fill-opacity", fillopacity);}
}
function hidedgslabsplashshape34() {
    if (layoutmode == 2) { return; }
    let smode = 'shapedg';
    let spsplashindex = parseInt(this.getAttribute("spsplashindex"));
    let spsideindex = parseInt(this.getAttribute("spsideindex"));
    let partsrno = parseInt(this.getAttribute("partsrno"));
    let areaid = parseInt(this.getAttribute("areaid"));
    let tmppartshape = getpartshapebyareapartsrno(partsrno, areaid);
    let scolor = tmppartshape.color, fillopacity = "0.2";    
    let spgindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex;
    let slabsplashpathg = d3.select("#" + smode + "splashpath" + spgindex);
    //console.log(areaid, partsrno, spsideindex, spsplashindex, spgindex, slabsplashpathg.empty());
    if (!slabsplashpathg.empty()) { slabsplashpathg.style("fill", scolor).style("fill-opacity", fillopacity); }
}