function initmaterial31(index) {
    let source = 'initmaterial31';
    mslaby = 0;
    initmatslabgroups(index);
    drawslabshapes(index, source);
    setmatslabparts31(index, source);
    resetmsvgbounds();
    zoomslabshapes(index);
    //zoommatslabparts(index);
    togglelayoutmode();
    //initdgmatareas32('slabpart');
    resetmatsvg();
}
function initmatslabgroups(index) {
    //lwidth = window.innerWidth - 50;//window width
    let versionid = getversionid();
    msvg = d3.select("#msvg" + versionid); if (msvg.empty()) { msvg = d3.select('.msvg' + versionid).append("svg").attr("id", "msvg" + versionid).on("mousedown", msvgclick).on("wheel", zoommousewheelslab); }
    msvg.attr("index", index).attr("width", lwidth).attr("height", lheight).style("display", "block").on("contextmenu", svgcontextmenu);
    mslabpartsg = msvg.select("#mslabpartsg"); if (mslabpartsg.empty()) { mslabpartsg = msvg.append("g").attr("id", "mslabpartsg"); } else { mslabpartsg.selectAll('*').remove(); }
    let slabpartsrect = mslabpartsg.select("#slabpartsrect"); if (slabpartsrect.empty()) { slabpartsrect = mslabpartsg.append("rect").attr("id", "slabpartsrect"); }
    slabpartsrect.attr("x", lzscalex).attr("y", lzscaley).attr("width", lwidth).attr("height", lheight).style("fill", "lightblue").style("fill-opacity", "0.1");
    mslabsg = mslabpartsg.select("#mslabsg"); if (mslabsg.empty()) { mslabsg = mslabpartsg.append("g").attr("id", "mslabsg"); } else { mslabsg.selectAll('*').remove(); }
    slabpartcontrolsg = mslabpartsg.select("#slabpartcontrolsg"); if (slabpartcontrolsg.empty()) { slabpartcontrolsg = mslabpartsg.append("g").attr("id", "slabpartcontrolsg"); }
     //maskdefs = apdefssvg.select("#maskdefs"); if (maskdefs.empty()) { maskdefs = apdefssvg.append("defs").attr("id", "maskdefs"); }
}
function setmatslabparts31(index, source) {
    //1. get material parts
    //2. loop throup all part shapes  and add to slabaprts.      
    let matpartlist = getpartlistbymatindex(index, source);
    slabparty = 0;
    setmatpartshapes32(matpartlist, source);
}
function setmatpartshapes32(matpartlist, source) {
    if (matpartlist != null && matpartlist != '') {
        for (let i = 0; i < matpartlist.length; i++) {
            if (matpartlist[i].Shape != null && matpartlist[i].Shape != undefined && matpartlist[i].Shape.sides != undefined) {
                if (matpartlist[i].Shape.layout == undefined || matpartlist[i].Shape.layout == null) { matpartlist[i].Shape.layout = 1; }
                if (matpartlist[i].IsActive == 1) { setpartshapeslabpartslayout(matpartlist[i].Shape, source); }
            }
        }
    }
}
function setpartshapeslabpartslayout(partshape, source) {
    setpartshapeslabparts31(partshape, 'slabpart', source);
    setpartshapeslabsplashs31(partshape);
    //if (partshape.layout == 1) {
    //    setpartshapeslabparts31(partshape, 'slabpart', source);
    //    setpartshapeslabsplashs31(partshape);
    //} else {
    //    deleteslabpartshapes1(partshape);//show/hide part shapes in layout
    //    deleteslabpartshapessplash1(partshape);//show/hide part shapes splashs in layout
    //}
}
function onsetlayoutmode(mode) {
    let source = 'onsetlayoutmode';
    layoutmode = mode;
    togglelayoutmode();
    setslabshapepathimages(source);
}
function togglelayoutmode() {
    let layoutclass = layoutmode == 2 ? "fa fa-toggle-on active1" : "fa fa-toggle-on fa-rotate-180 inactive1";
    $('#layoutmode').attr('class', layoutclass);
}
function setslabshapepathimages(source) {
    source += ":" + layoutmode;
    // let index = getmaterialindex();
    let index = msvg.attr("index");
    drawslabshapes(index, source);
    initdgmatareas32('slabpart', source);
}
function msvgclick() {
    //console.log(d3.event.srcElement.tagName);
    d3.event.preventDefault();
    if (d3.event.srcElement.tagName == 'rect') { removeshapetools(); }
}
function zoommousewheelslab() {
    //prevent browser zooming
    // console.log("zoommousewheelslab");
    d3.event.preventDefault();
    if (bdrag == false && d3.event.type == 'wheel') {
        let direction = d3.event.deltaY < 0 ? 'down' : 'up';
        if (direction == 'up') {
            mlzoomclick(0);
        } else {
            mlzoomclick(1);
        }
    }
}
function mlzoomclick(ztype) {
    lzscale = roundToOne(lzscale);
    let scaleto = ztype == 0 ? roundToOne(lzscale - 0.1) : roundToOne(lzscale + 0.1);
    // console.log(lzscale, scaleto);
    if (scaleto <= 0.1) { scaleto = 0.1; }
    lzscale = roundToOne(scaleto);
    let matindex = msvg.attr("index");
    zoomslabshapes(matindex); //get material index
    zoommatslabparts(matindex);
    removeshapetools();
    $('#txtmlzoom').html((Math.round(roundToOne(lzscale) * 100)) + "%");
}
function zoommatslabparts(index) {
    let source = 'zoommatslabparts';
    let matpartlist = getpartlistbymatindex(index, source);
    if (matpartlist != null) {
        for (let i = 0; i < matpartlist.length; i++) {
            let partshape = parsepartshape(matpartlist[i].Shape);
            zoompartshapeslabparts31(partshape, 'slabpart', source);
            zoompartshapeslabsplashs31(partshape, source);
        }
    }
}
function zoompartshapeslabparts31(partshape, mode, source) {
    if (partshape.slabparts != null) {
        for (let i = 0; i < partshape.slabparts.length; i++) {
            transformslabpartshape(i, partshape, mode);
        }
    }
}
function zoompartshapeslabsplashs31(partshape, source) {
    if (partshape.sides != null) {
        for (let i = 0; i < partshape.sides.length; i++) {
            if (partshape.sides[i].splashs != null) {
                for (let j = 0; j < partshape.sides[i].splashs.length; j++) {
                    for (let k = 0; k < partshape.sides[i].splashs[j].slabsplashs.length; k++) {
                        transformpartslabsplash(k, j, i, partshape, 'slabsplash');
                    }
                }
            }
        }
    }
}
function transformslabpartshape30(source) {
    if (shape.tx == undefined || shape.ty == undefined) { return; }
    let ztx = shape.tx, zty = shape.ty, stscale = lzscale;
    let gnode = shapeouterg.node().getBBox(), sw = gnode.width, sh = gnode.height, sx = gnode.x, sy = gnode.y;
    //console.log("sindex:" + shape.index, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "stscale:" + shape.tscale, "sx:" + sx, "sy:" + sy, "sw:" + sw, "sh:" + sh, "ztx + sx + sw:" + (ztx + sx + sw));
    let spx = 500, spy = 30;
    if (sx < 0) { ztx = -sx; }
    if (sy < 0) { zty = spy - sy; }
    if ((ztx + sx + sw) > lwidth) { ztx = spx - sx; }
    if (ztx == 0 && zty == 0) {
        zty = spy - sy;
        ztx = spx - sx;
    }
    shape.tx = ztx, shape.ty = zty;
    let index1 = getslabpartindex32(shape.spindex, source);
    let pslabpart = pshapeslabparts[index1];
    if (pslabpart != undefined) {
        pslabpart.tx = shape.tx;
        pslabpart.ty = shape.ty;
    }
    ztx = Math.round(ztx * stscale), zty = Math.round(zty * stscale);
    // console.log("sindex:" + shape.index, "index1:" + index1, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "stscale:" + shape.tscale, "sx:" + sx, "sy:" + sy, "sw:" + sw, "sh:" + sh);
    let npt = [ztx, zty];
    shapeouterg.attr('transform', 'translate(' + npt + ') scale(' + stscale + ')');
}
function transformslabpartshape32() {
    if (shape.tx == undefined || shape.ty == undefined) { return; }
    let ztx = shape.tx, zty = shape.ty, stscale = lzscale;
    let gnode = shapeouterg.node().getBBox(), sw = gnode.width, sh = gnode.height, sx = gnode.x, sy = gnode.y;
    ztx = Math.round(ztx * stscale), zty = Math.round(zty * stscale);
    // console.log("sindex:" + shape.index, "ztx:" + ztx, "zty:" + zty, "stx:" + shape.tx, "sty:" + shape.ty, "stscale:" + shape.tscale, "sx:" + sx, "sy:" + sy, "sw:" + sw, "sh:" + sh, "ztx + sx + sw:" + (ztx + sx + sw));
    let npt = [ztx, zty];
    shapeouterg.attr('transform', 'translate(' + npt + ') scale(' + stscale + ')');
}
function transformslabpartshape(spindex, partshape, mode) {
    let areashapeindex = partshape.areaid + "" + partshape.partsrno + "" + spindex;
    let partshapeouterg = mslabpartsg.select("#" + mode + "outer" + areashapeindex);
    let ztx = partshape.slabparts[spindex].tx, zty = partshape.slabparts[spindex].ty;
    //console.log(areashapeindex, ztx, zty, lzscale, partshapeouterg.empty());    
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    partshapeouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function transformpartslabsplash(splindex, spsplashindex, spsideindex, partshape, mode) {
    let partshapeslabsplash = partshape.sides[spsideindex].splashs[spsplashindex].slabsplashs[splindex];
    let shapeslabsplashindex = partshape.areaid + "" + partshapeslabsplash.partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let partslabsplashouterg = mslabpartsg.select("#slabsplashouterg" + shapeslabsplashindex);
    let ztx = partshapeslabsplash.tx, zty = partshapeslabsplash.ty;
    //console.log(splindex, spsplashindex, spsideindex, shapeslabsplashindex);
    ztx = Math.round(ztx * lzscale), zty = Math.round(zty * lzscale);
    let npt = [ztx, zty];
    partslabsplashouterg.attr('transform', 'translate(' + npt + ') scale(' + lzscale + ')');
}
function getslabpartshapesgscale() {
    let sgscale = 0;
    if (mslabpartsg.node() != null) {
        let mslabpartsgnode = mslabpartsg.node().getBBox(), msgw = Math.round(mslabpartsgnode.width), msgh = Math.round(mslabpartsgnode.height);
        if (msgw != 0 && msgh != 0) {
            let msvgnode = msvg.node(), msvgclientw = Math.round(msvgnode.clientWidth), msvgclienth = Math.round(msvgnode.clientHeight);
            sgscale = roundToPlaces(Math.min(msvgclientw / msgw, msvgclienth / msgh) * lzscale, 2);
        }
    }
    return sgscale;
}
function isslabpartinbounds32(sgscale, source) {
    let shapesidesegs = getshapesidesegs32(source);
    let ztx = shape.tx, zty = shape.ty, rtx = shape.rtx, rty = shape.rty, angle = shape.angle;
    let isinbox = true;
    let nsgscale = getslabpartshapesgscale();
    nsgscale += (lzscale - sgscale);
    let angdec = (angle / 90) - Math.floor(angle / 90);
    //console.log(shape.index, ztx, zty, rtx, rty,dragdx, dragdy, ztx+ dragdx, zty+dragdy,
    // sx * lzscale, sy * lzscale, ztx + Math.round(sx * lzscale), zty + Math.round(sy * lzscale), angle, Math.floor(shape.angle / 90), angdec);
    if (angdec == 0) {
        if (nsgscale < lzscale) { isinbox = false; }
    } else { if ((ztx + dragdx < 0) || (zty + dragdy < 0)) { isinbox = false; } }
    return isinbox;
}
function isslabpartinbounds(sgscale) {
    let isinbox = true;
    let nsgscale = getslabpartshapesgscale();
    nsgscale += (lzscale - sgscale);
    if (nsgscale < lzscale) { isinbox = false; }
    //console.log(nsgscale, sgscale, zscale);
    return isinbox;
}
function resetmsvgbounds() {
    //let sgscale = getslabpartshapesgscale();
    //console.log(sgscale, lzscale);
    //if (sgscale < lzscale) { lzscale = sgscale; }
    $('#txtmlzoom').html((Math.round(roundToOne(lzscale) * 100)) + "%");
}
function resetmatsvg() {
    if (mslaby > lheight) {
        lheight = mslaby + spdy; msvg.style("height", lheight);
        let slabpartsrect = mslabpartsg.select("#slabpartsrect");
        if (!slabpartsrect.empty()) {
            slabpartsrect.attr("height", lheight);
        }
    }
}
function checkimage(url) {
    var img = new Image();
    img.src = url;
    if (img.height > 0) {
        return true;
    } else {
        return false;
    }
}
function initslabdefs() {
    //<defs><pattern id="img1" patternUnits="userSpaceOnUse" width="100" height="100"><image xlink:href="wall.jpg" x="0" y="0" width="100" height="100" /></pattern></defs>
    slabdefs = defssvg.select("#slabdefs");
    if (slabdefs.empty()) { slabdefs = defssvg.append("defs").attr("id", "slabdefs"); }
    var slabdef = slabdefs.select("#slabptrn" + slab.index);
    if (slabdef.empty()) {
        slabdef = slabdefs.append("pattern").attr("id", "slabptrn" + slab.index).attr("patternContentUnits", "objectBoundingBox")
            .attr("width", "100%").attr("height", "100%").attr("viewBox", "0 0 1 1").attr("preserveAspectRatio", "xMidYMid slice");
    }
    var slabptrnimmage = slabdef.select("#slabptrnimg" + slab.index);
    if (slabptrnimmage.empty()) {
        slabptrnimmage = slabdef.append("image").attr("id", "slabptrnimg" + slab.index).attr("width", "1").attr("height", "1").attr("preserveAspectRatio", "xMidYMid slice")
            .attr("xlink:href", slab.path);
    }
}
function convertbase64image(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function () {
        var reader = new FileReader();
        reader.onloadend = function () { callback(reader.result); }
        reader.readAsDataURL(xhr.response);
    };
    xhr.open('GET', url);
    xhr.responseType = 'blob';
    xhr.send();
}
//code to check slabpart and splash slab bounds ans collission detection
function getslabpartshapepoints34(source) {
    setshapecentercords32(source);
    let stx = shape.tx, sty = shape.ty, rtx = shape.rtx, rty = shape.rty, sangle = shape.angle;
    let shapesidesegs = getshapesidesegs32(source);
    let shapepoints = [];
    for (let j = 0; j < shapesidesegs.length; j++) {
        let shapesideseg = shapesidesegs[j];
        let x1 = shapesideseg.x1, y1 = shapesideseg.y1, x2 = shapesideseg.x2, y2 = shapesideseg.y2, x3 = shapesideseg.x3, y3 = shapesideseg.y3, lntype = shapesideseg.lntype;
        if (sangle != 0) {
            let npt = rotateline34(x1, y1, rtx, rty, sangle);
            x1 = Math.round(npt.dx), y1 = Math.round(npt.dy);
        }
        x1 += stx, y1 += sty;
        shapepoints.push({ x: x1, y: y1 });
        //if (lntype != 1) {
        //    if (sangle != 0) {
        //        let npt1 = rotateline34(x2, y2, rtx, rty, sangle);
        //        x2 = Math.round(npt1.dx), y2 = Math.round(npt1.dy);
        //        npt1 = rotateline34(x3, y3, rtx, rty, sangle);
        //        x3 = Math.round(npt1.dx), y3 = Math.round(npt1.dy);
        //    }
        //    x2 += stx, y2 += sty, x3 += stx, y3 += sty;
        //    let npt = quadraticcurveseampath32(x1, y1, x3, y3, x2, y2, 0, 0.5, 'getslabpartshapepoints34');
        //    x3 = Math.round(npt.x3), y3 = Math.round(npt.y3);
        //    shapepoints.push({ x: x3, y: y3 });
        //}
        //console.log("sindex:" + shape.index, "spindex:" + shape.spindex, "stx:" + stx, "sty:" + sty, "rtx:" + rtx, "rty:" + rty, "x1:" + x1, "y1:" + y1, "x2:" + x2, "y2:" + y2, "x3:" + x3, "y3:" + y3,
        //    "sangle:" + sangle);       
    }
    // console.log(JSON.stringify(shapepoints));
    return shapepoints;
}
function getslabsplashpoints34(source) {
    setslabsplashcentercords32(source);
    let stx = shapeslabsplash.tx, sty = shapeslabsplash.ty, rtx = shapeslabsplash.rtx, rty = shapeslabsplash.rty, sangle = shapeslabsplash.angle,
    areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno, spsideindex = shapeslabsplash.spsideindex, spsplashindex = shapeslabsplash.spsplashindex, splindex = shapeslabsplash.splindex;
    let sx11 = shapeslabsplash.x11, sy11 = shapeslabsplash.y11, sx12 = shapeslabsplash.x12, sy12 = shapeslabsplash.y12;
    let sx21 = shapeslabsplash.x21, sy21 = shapeslabsplash.y21, sx22 = shapeslabsplash.x22, sy22 = shapeslabsplash.y22;
    let slabsplashpoints = [];
    //if (sangle != 0) {
    //    let npt = rotateline34(sx11, sy11, rtx, rty, sangle);
    //    sx11 = Math.round(npt.dx), sy11 = Math.round(npt.dy);
    //    //npt = rotateline34(sx12, sy12, rtx, rty, sangle);
    //    //sx12 = Math.round(npt.dx), sy12 = Math.round(npt.dy);
    //    //npt = rotateline34(sx21, sy21, rtx, rty, sangle);
    //    //sx21 = Math.round(npt.dx), sy21 = Math.round(npt.dy);
    //    //npt = rotateline34(sx22, sy22, rtx, rty, sangle);
    //    //sx22 = Math.round(npt.dx), sy22 = Math.round(npt.dy);
    //    //console.log(shapeslabsplash.index, stx, sty, rtx, rty, npt.dx, npt.dy, sx12, sy12, sx21, sy21, sx22, sy22, sangle);
    //}
    //sx11 += stx, sy11 += sty, sx12 += stx, sy12 += sty, sx21 += stx, sy21 += sty, sx22 += stx, sy22 += sty;
    //slabsplashpoints.push({ x: sx11, y: sy11 });
    //slabsplashpoints.push({ x: sx12, y: sy12 });
    //slabsplashpoints.push({ x: sx21, y: sy21 });
    //slabsplashpoints.push({ x: sx22, y: sy22 });    
    //console.log(shapeslabsplash.index, stx, sty, rtx, rty, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22);
    let slabsplashindex =  areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let slabsplashsidepathgEle = document.querySelector("#" + "slabsplashpath" + slabsplashindex);
    if (slabsplashsidepathgEle != null) {
        let slabsplashRect = slabsplashsidepathgEle.getBoundingClientRect();
        let x1 = slabsplashRect.left, y1 = slabsplashRect.top, x2 = slabsplashRect.right, y2 = slabsplashRect.bottom;
        slabsplashpoints.push({ x: x1, y: y1 });
        slabsplashpoints.push({ x: x2, y: y1 });
        slabsplashpoints.push({ x: x2, y: y2 });
        slabsplashpoints.push({ x: x1, y: y2 });
    }   
    return slabsplashpoints;
}
function oncheckslabpartslabbounds34(source) {
    let mslablist = getmatslablistbymaterialid(materialid);
    let matpartlist = getpartlistbymaterialId31(materialid, source);
    let shapepoints = getslabpartshapepoints34(source);
    let tmpshape = JSON.parse(JSON.stringify(shape));
    let tmpshapeslabparts = JSON.parse(JSON.stringify(shape.slabparts));
    let sindex = tmpshape.index, spindex = tmpshape.spindex, partsrno = tmpshape.partsrno, areaid = tmpshape.areaid, startseamindex = tmpshape.startseamindex,
        startsideindex = tmpshape.startsideindex, endseamindex = tmpshape.startseamindex, endsideindex = tmpshape.endsideindex, smode = tmpshape.mode, stx = tmpshape.tx, sty = tmpshape.ty, rtx = tmpshape.rtx, rty = tmpshape.rty, sangle = tmpshape.angle;
    let slabpartslabmode=0, isslabpartcollide=false;
    slabpartslabmode = checkslabpartslabbounds34(tmpshape, shapepoints, mslablist);
    isslabpartcollide = detectslabpartscollision34(sindex, areaid, tmpshape.slabid, shapepoints, matpartlist);
    //console.log("sindex:" + sindex, "slabid:" + tmpshape.slabid, "spindex:" + spindex, "stx:" + stx, "sty:" + sty, "rtx:" + rtx, "rty:" + rty, "sangle:" + sangle, "shapepoints:" + shapepoints.length, isslabpartcollide, slabpartslabmode);
    if (isslabpartcollide && slabpartslabmode == 0) { slabpartslabmode = 1; } else if (isslabpartcollide && slabpartslabmode == 3) { slabpartslabmode = 2; }
    shape = JSON.parse(JSON.stringify(tmpshape));   
    shape.color = slabpartsplashfillcolor(slabpartslabmode);
    for (let i = 0; i < shape.sides.length; i++) {
        let sidepathindex = areaid + "" + sindex + "" + i;
        let slabpartsidepathg = d3.select("#" + "slabpartsidepath" + sidepathindex);
        slabpartsidepathg.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    }    
    pshapeslabparts = JSON.parse(JSON.stringify(tmpshapeslabparts));
}
function checkslabpartslabbounds34(tmpshape, shapepoints, mslablist) {
    let slabpartslabmode = 0, areaid = tmpshape.areaid, sindex = tmpshape.index, stx = tmpshape.tx, sty = tmpshape.ty, rtx = tmpshape.rtx, rty = tmpshape.rty, sangle = tmpshape.angle;
    for (let i = 0; i < mslablist.length; i++) {
        let slabid = mslablist[i].ID, slabqty = mslablist[i].NoOfSlabs, isslabpartcollide = 0;
        for (let j = 0; j < slabqty; j++) {
            let mslabindex = slabid + "" + j;
            let mslabrectg = d3.select("#" + "mslabpathg" + mslabindex);
            //console.log(i, slabid, mslabrectg.empty())
            if (mslabrectg != null && !mslabrectg.empty()) {
                let mx1 = parseInt(mslabrectg.attr("x")), my1 = parseInt(mslabrectg.attr("y")), mslabw = parseInt(mslabrectg.attr("width")), mslabh = parseInt(mslabrectg.attr("height"));
                let mx2 = mx1 + mslabw, my2 = my1 + mslabh;
                for (let k = 0; k < shapepoints.length; k++) {
                    let shapepoint = shapepoints[k];
                    let x = shapepoint.x, y = shapepoint.y;
                    if (mx1 < x && mx2 > x && my1 < y && my2 > y) { tmpshape.slabid = slabid, tmpshape.slabsrno = j, tmpshape.slabindex = i; slabpartslabmode = 3; } else { slabpartslabmode = 0; }
                    //if (slabpartslabmode == 0) {
                    //    console.log("index:" + j, "sindex:" + sindex, "x:" + x, "y:" + y, "mx1:" + mx1, "my1:" + my1, "mx2:" + mx2, "my2:" + my2, slabpartslabmode);
                    //    let mslabg = d3.select("#" + "mslabg" + slabid);
                    //    let cpointcircle6 = mslabg.select("#slabpartcircle1");
                    //    if (cpointcircle6.empty()) { cpointcircle6 = mslabg.append("circle").attr("id", "slabpartcircle1"); }
                    //    cpointcircle6.attr("cx", x).attr("cy", y).attr("r", 10).attr("style", "fill:red;");
                    //}
                    //console.log("index:" + j, "sindex:" + sindex, "slabid:" + slabid, "x:" + x, "y:" + y, "mx1:" + mx1, "my1:" + my1, "mx2:" + mx2, "my2:" + my2, slabpartslabmode);
                    if (slabpartslabmode == 0) { break; }
                }
                if (slabpartslabmode == 3) { break; }
            }
        }
    }
    return slabpartslabmode;
}
function detectslabpartscollision34(sindex, areaid, slabid, shapepoints, matpartlist) {
    let isslabpartcollide = false, source = 'detectslabpartcollision34';
    let areashapeindex = areaid + "" + sindex;
    if (matpartlist != null) {
        for (let i = 0; i < matpartlist.length; i++) {
            let tmppartshape = parsepartshape(matpartlist[i].Shape);
            if (tmppartshape != null && tmppartshape.areaid != undefined) {
                for (let j = 0; j < tmppartshape.slabparts.length; j++) {
                    let partsrno = tmppartshape.partsrno, areaid = tmppartshape.areaid, tmpslabid = tmppartshape.slabid, smode = 'slabpart';
                    let tmpareashapeindex = tmppartshape.areaid + "" + tmppartshape.partsrno + "" + j;
                    //console.log(sindex, areaid, areashapeindex, tmpareashapeindex, tmppartshape.slabid, slabid);
                    if (areashapeindex != tmpareashapeindex) {
                        let pslabpart = tmppartshape.slabparts[j];
                        let index = partsrno + "" + j, spindex = pslabpart.index, startseamindex = pslabpart.startseamindex, startsideindex = pslabpart.startsideindex,
                        endseamindex = pslabpart.endseamindex, endsideindex = pslabpart.endsideindex;
                        // console.log(index, spindex, startseamindex, startsideindex, partsrno, areaid, smode, source);
                        onsetslabpartshape31(index, spindex, startseamindex, startsideindex, endseamindex, endsideindex, partsrno, areaid, smode, source);
                        let partshapepoints = getslabpartshapepoints34(sindex, spindex, source);
                        isslabpartcollide = detectslabpartcollision34(index, spindex, shapepoints, partshapepoints, source);
                        if (isslabpartcollide) { break; }
                    }                   
                }
                //if (!isslabpartcollide) { if (detectslabpartsplashscollision34(-1, -1, shapepoints, tmppartshape, source)) { isslabpartcollide = true; } }
            }
            if (isslabpartcollide) { break; }
        }
    }
    return isslabpartcollide;
}
function detectslabpartcollision34(index, spindex, shapepoints, partshapepoints, source) {
    let isslabpartcollide = false; isslabpartcollide1 = false, isslabpartcollide2 = false;
    //console.log(index, spindex, "shapepoints:" + JSON.stringify(shapepoints), "partshapepoints:" + JSON.stringify(partshapepoints));
    for (let j = 0; j < shapepoints.length; j++) {
        isslabpartcollide1 = insidePoly1(partshapepoints, shapepoints[j].x, shapepoints[j].y);
        // console.log(j, isslabpartcollide1, shapepoints[j].x, shapepoints[j].y, JSON.stringify(partshapepoints));
        if (isslabpartcollide1) { break; }
    }
    if (isslabpartcollide1 == false) {
        for (let j = 0; j < partshapepoints.length; j++) {
            isslabpartcollide2 = insidePoly1(shapepoints, partshapepoints[j].x, partshapepoints[j].y);
            //console.log(j, isslabpartcollide1, isslabpartcollide2, partshapepoints[j].x, partshapepoints[j].y, JSON.stringify(shapepoints));
            if (isslabpartcollide2) { break; }
        }
    }
    if (isslabpartcollide1 == true || isslabpartcollide2 == true) { isslabpartcollide = true; }
    return isslabpartcollide;
}
function detectslabsplashcollision34(index, spindex, shapepoints, partsplashpoints, source) {
    let isinpoly = false;
    let stx = shapeslabsplash.tx, sty = shapeslabsplash.ty, rtx = shapeslabsplash.rtx, rty = shapeslabsplash.rty, sangle = shapeslabsplash.angle,
        areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno, spsideindex = shapeslabsplash.spsideindex, spsplashindex = shapeslabsplash.spsplashindex, splindex = shapeslabsplash.splindex;
    let slabsplashindex =  areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex;
    let slabsplashsidepathgEle = document.querySelector("#" + "slabsplashpath" + slabsplashindex);
    if (slabsplashsidepathgEle != null) {
        let slabsplashRect = slabsplashsidepathgEle.getBoundingClientRect();
        let mx1 = Math.round(slabsplashRect.left), my1 = Math.round(slabsplashRect.top), mx2 = Math.round(slabsplashRect.right), my2 = Math.round(slabsplashRect.bottom);
        //for (let j = 0; j < shapepoints.length; j++) {
        //    let shapepoint = shapepoints[j];
        //    let x = Math.round(shapepoint.x), y = Math.round(shapepoint.y);
        //    if (mx1 < x && mx2 > x && my1 < y && my2 > y) { isinpoly = true; }           
        //    console.log(mx1, mx2, x, my1, my2, y, mx1 < x, mx2 > x, my1 < y, my2 > y, isinpoly);
        //   // if (isinpoly) { break;}
        //}
        //let slabid = 2675;
        //let mslabg = d3.select("#" + "mslabg" + slabid);
        //let cpointcircle6 = mslabg.select("#slabpartcircle1");
        //if (cpointcircle6.empty()) { cpointcircle6 = mslabg.append("circle").attr("id", "slabpartcircle1"); }
        //cpointcircle6.attr("cx", mx1).attr("cy", my1).attr("r", 10).attr("style", "fill:red;");
        //let isinpoly1 = insidePoly1(shapepoints, mx1, my1);
        //let isinpoly2 = insidePoly1(shapepoints, mx2, my2);
        //console.log(mx1, mx2, my1, my2, isinpoly1, isinpoly2);
        
    }
    return isinpoly;
}
function detectslabpartsplashscollision34(index, spindex, shapepoints, tmppartshape, source) {
    let isslabsplashcollide = false;
    for (let i = 0; i < tmppartshape.sides.length; i++) {
        for (let j = 0; j < tmppartshape.sides[i].splashs.length; j++) {            
            for (let k = 0; k < tmppartshape.sides[i].splashs[j].slabsplashs.length; k++) {              
                let slabsplash = tmppartshape.sides[i].splashs[j].slabsplashs[k];
                let areaid = tmppartshape.areaid, partsrno = tmppartshape.partsrno, splindex = slabsplash.splindex, startseamindex = slabsplash.startseamindex, endseamindex = slabsplash.endseamindex, spsplashindex = j, spsideindex = i;
                let splashindex = areaid + "" + partsrno + "" + spsideindex + "" + spsplashindex + "" + splindex, smode = 'slabsplash';                
                if (index != splashindex) {
                    setshapesplashslabsplashs32(splashindex, splindex, startseamindex, endseamindex, spsplashindex, spsideindex, partsrno, areaid, smode, source);
                    let slabsplashpoints = getslabsplashpoints34(splashindex, splindex, source);
                   // console.log(index, spindex, i, j, k, splindex, areaid, splashindex, shapepoints.length, slabsplashpoints.length);
                    isslabsplashcollide = detectslabsplashcollision34(splindex, spindex, shapepoints, slabsplashpoints, source);
                    if (isslabsplashcollide) { break; }
                }
            }
        }
    }
    return isslabsplashcollide;
}

//splash
function oncheckslabsplashslabbounds34(source) {
    source += ':oncheckslabsplashslabbounds34';
    let mslablist = getmatslablistbymaterialid(materialid);
    let matpartlist = getpartlistbymaterialId31(materialid, source);
   // let slabsplashpoints = getslabsplashpoints34(source);    
    let tmpslabsplash = JSON.parse(JSON.stringify(shapeslabsplash));
    let tmpshapeslabsplashs = JSON.parse(JSON.stringify(pshapeslabsplashs));
    let slabsplashindex = tmpslabsplash.index;
    let slabsplashslabmode = checkslabsplashslabbounds34(tmpslabsplash, mslablist);
    //let isslabsplashcollide = detectslabpartscollision34(shapeslabsplash.index, spindex, shapepoints, slabsplashpoints, source);
    //console.log(JSON.stringify(slabsplashpoints), slabsplashslabmode);
    //if (isslabsplashcollide && slabsplashslabmode == 0) { slabsplashslabmode = 1; } else if (isslabsplashcollide && slabsplashslabmode == 3) { slabsplashslabmode = 2; }
    let scolor = slabpartsplashfillcolor(slabsplashslabmode);
    let slabsplashpathg = d3.select("#" + "slabsplashpath" + slabsplashindex);
    slabsplashpathg.attr("style", "fill:" + scolor).style("fill-opacity", "0.2");
    shapeslabsplash = JSON.parse(JSON.stringify(tmpslabsplash));
    shapeslabsplash.color = scolor;
    pshapeslabsplashs = JSON.parse(JSON.stringify(tmpshapeslabsplashs));
   
}
function checkslabsplashslabbounds34(tmpslabsplash, mslablist) {
    let slabsplashslabmode = 0;
    let areaid = shapeslabsplash.areaid, partsrno = shapeslabsplash.partsrno, spsideindex = shapeslabsplash.spsideindex, spsplashindex = shapeslabsplash.spsplashindex, splindex = shapeslabsplash.splindex;    
    let slabsplashindex = areaid + "" + partsrno + "" + splindex;
    let slabsplashsidepathgEle = document.querySelector("#" + "slabsplashpath" + slabsplashindex);   
    //console.log(areaid, partsrno, splindex, slabsplashindex);
    for (let i = 0; i < mslablist.length; i++) {
        let slabid = mslablist[i].ID, slabqty = mslablist[i].NoOfSlabs, isslabpartcollide = 0;
        for (let j = 0; j < slabqty; j++) {
            let mslabindex = slabid + "" + j;
            let mslabrectg = d3.select("#" + "mslabpathg" + mslabindex);
            if (mslabrectg != null && !mslabrectg.empty()) {
                let mx1 = parseInt(mslabrectg.attr("x")), my1 = parseInt(mslabrectg.attr("y")), mslabw = parseInt(mslabrectg.attr("width")), mslabh = parseInt(mslabrectg.attr("height"));
                let mx2 = mx1 + mslabw, my2 = my1 + mslabh;
                let mslabgEle = document.querySelector("#" + "mslabpathg" + mslabindex);
                if (isshapeinbox(mslabgEle, slabsplashsidepathgEle)) { tmpslabsplash.slabid = slabid, tmpslabsplash.slabsrno = j, tmpslabsplash.slabindex = i; slabsplashslabmode = 3; } else { slabsplashslabmode = 0; }
                if (isshapesideintersect(mslabgEle, slabsplashsidepathgEle, 'checkslabsplashslabbounds34')) {
                    tmpslabsplash.slabid = slabid, tmpslabsplash.slabsrno = j, tmpslabsplash.slabindex = i;
                }
                if (slabsplashslabmode == 3) { break; }
            }
        }
    }
    return slabsplashslabmode;
}
function checkslabsplashslabbounds341(tmpslabsplash, slabsplashpoints, mslablist) {
    let slabsplashslabmode = 0;
    for (let i = 0; i < mslablist.length; i++) {
        let slabid = mslablist[i].ID, slabqty = mslablist[i].NoOfSlabs, isslabpartcollide = 0, matid = mslablist[i].materialid;
        for (let j = 0; j < slabqty; j++) {
            let mslabindex = slabid + "" + j;
            let mslabrectg = d3.select("#" + "mslabpathg" + mslabindex);
            if (mslabrectg != null && !mslabrectg.empty()) {
                let mx1 = parseInt(mslabrectg.attr("x")), my1 = parseInt(mslabrectg.attr("y")), mslabw = parseInt(mslabrectg.attr("width")), mslabh = parseInt(mslabrectg.attr("height"));
                let mx2 = mx1 + mslabw, my2 = my1 + mslabh, isshapeinbox = false;
                for (let k = 0; k < slabsplashpoints.length; k++) {
                    let slabsplashpoint = slabsplashpoints[k];
                    let x = slabsplashpoint.x, y = slabsplashpoint.y;
                    if (mx1 < x && mx2 > x && my1 < y && my2 > y) { tmpslabsplash.slabid = slabid, tmpslabsplash.slabindex = i; tmpslabsplash.slabsrno = j; slabsplashslabmode = 3; } else { slabsplashslabmode = 0; }
                    //if (slabsplashslabmode == 0) {
                    //console.log("index:" + j, "slabsplashindex:" + tmpslabsplash.index, "x:" + x, "y:" + y, "mx1:" + mx1, "my1:" + my1, "mx2:" + mx2, "my2:" + my2,
                    //"slabsplashslabmode:" + slabsplashslabmode, "matid:" + matid, "slabid:" + slabid, "materialid:" + tmpslabsplash.materialid);
                    let mslabg = d3.select("#" + "mslabg" + slabid);
                    let cpointcircle6 = mslabg.select("#slabpartcircle" + k);
                    if (cpointcircle6.empty()) { cpointcircle6 = mslabg.append("circle").attr("id", "slabpartcircle" + k); }
                    cpointcircle6.attr("cx", x).attr("cy", y).attr("r", 10).attr("style", "fill:red;");
                    //}               
                    if (slabsplashslabmode == 0) { break; }
                }
                if (slabsplashslabmode == 3) { break; }
            }
        }
    }
    return slabsplashslabmode;
}
function slabpartsplashfillcolor(mode) {
    let scolor = shape.color;
    if (mode == 0) {
        scolor = "orange"; //orange - off the slab &  not colliding with other shape  
    } else if (mode == 1) {
        scolor = "red";  //Red - off the slab & colliding with other shape
    } else if (mode == 2) {
        scolor = "yellow"; // Yellow - On the slab but colliding with other shape
    } else if (mode == 3) {
        scolor = "green"; // Green - on the slab       
    }
    return scolor;
}
function detectslabsplashpointcollision34(x11, y11, x12, y12, x21, y21, x22, y22, source) {
    let sx11 = shapeslabsplash.x11, sy11 = shapeslabsplash.y11, sx12 = shapeslabsplash.x12, sy12 = shapeslabsplash.y12;
    let sx21 = shapeslabsplash.x21, sy21 = shapeslabsplash.y21, sx22 = shapeslabsplash.x22, sy22 = shapeslabsplash.y22;
    let stx = shapeslabsplash.tx, sty = shapeslabsplash.ty, rtx = shapeslabsplash.rtx, rty = shapeslabsplash.rty, sangle = shapeslabsplash.angle, isslabsplashcollide = false;
    if (sangle != 0) {
        let npt = rotateline34(sx11, sy11, rtx, rty, sangle);
        sx11 = Math.round(npt.dx), sy11 = Math.round(npt.dy);
        npt = rotateline34(sx12, sy12, rtx, rty, sangle);
        sx12 = Math.round(npt.dx), sy12 = Math.round(npt.dy);
        npt = rotateline34(sx21, sy21, rtx, rty, sangle);
        sx21 = Math.round(npt.dx), sy21 = Math.round(npt.dy);
        npt = rotateline34(sx22, sy22, rtx, rty, sangle);
        sx22 = Math.round(npt.dx), sy22 = Math.round(npt.dy);
    }
    //let areashapeindex = shape.areaid + "" + shape.index;
    //let slabpartouter1 = d3.select('#slabpartouter' + areashapeindex);
    //let cpointcircle6 = slabpartouter1.select("#cpointcircle6" + areashapeindex);
    //if (cpointcircle6.empty()) { cpointcircle6 = slabpartouter1.append("circle").attr("id", "cpointcircle6" + areashapeindex); }
    //cpointcircle6.attr("cx", sx22).attr("cy", sy22).attr("r", 10).attr("style", "fill:red;");
    //cpointcircle6 = slabpartouter1.select("#cpointcircle7" + areashapeindex);
    //if (cpointcircle6.empty()) { cpointcircle6 = slabpartouter1.append("circle").attr("id", "cpointcircle7" + areashapeindex); }
    //cpointcircle6.attr("cx", sx11).attr("cy", sy11).attr("r", 10).attr("style", "fill:blue;");

    sx11 += stx, sy11 += sty, sx12 += stx, sy12 += sty, sx21 += stx, sy21 += sty, sx22 += stx, sy22 += sty;
    isslabsplashcollide = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, x11, y11);
    if (!isslabsplashcollide) { isslabsplashcollide = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, x12, y12); }
    if (!isslabsplashcollide) { isslabsplashcollide = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, x21, y21); }
    if (!isslabsplashcollide) { isslabsplashcollide = insidePoly(sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, x22, y22); }
    if (!isslabsplashcollide) { isslabsplashcollide = lineSegmentsIntersect(x11, y11, x12, y12, sx11, sy11, sx12, sy12); }
    if (!isslabsplashcollide) { isslabsplashcollide = lineSegmentsIntersect(x11, y11, x12, y12, sx21, sy21, sx22, sy22); }
    if (!isslabsplashcollide) { isslabsplashcollide = lineSegmentsIntersect(x21, y21, x22, y22, sx11, sy11, sx12, sy12); }
    if (!isslabsplashcollide) { isslabsplashcollide = lineSegmentsIntersect(x21, y21, x22, y22, sx21, sy21, sx22, sy22); }
    //console.log(shape.index, stx, sty, rtx, rty, sangle, sx11, sy11, sx12, sy12, sx21, sy21, sx22, sy22, isslabsplashcollide);   
    return isslabsplashcollide;
}
function onsetslabsplashslabinfo32(source) {
    let mslablist = getmatslablistbymaterialid(shape.materialid);
    for (let i = 0; i < shape.sides.length; i++) {
        let sidepathindex = shape.areaid + "" + shape.index + "" + i;
        let slabpartsidepathEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);
        let onslabmode = setslabsplashslabinfo32(shape.materialid, slabpartsidepathEle, mslablist);
        //console.log(onslabmode, shape.color);
        let slabpartsidepathg = d3.select("#" + "slabpartsidepath" + sidepathindex);
        slabpartsidepathg.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
        break;
    }
}
function setslabpartslabinfo32(materialid, slabpartsidepathEle, mslablist) {
    let onslabmode = 0;
    if (mslablist != null) {
        for (let i = 0; i < mslablist.length; i++) {
            onslabmode = 0;
            let mslabgEle = document.querySelector("#" + "mslabpathg" + mslablist[i].ID);
            if (isshapeinbox(mslabgEle, slabpartsidepathEle)) { onslabmode = 3; }
            if (isshapesideintersect(mslabgEle, slabpartsidepathEle, 'setslabpartsplashslabinfo32')) {
                shape.slabid = mslablist[i].ID, shape.slabindex = i;
            }
            if (onslabmode != 0) { break; }
        }
    }
    let iscollision = detectslabpartcollision(materialid);
    if (iscollision && onslabmode == 0) { onslabmode = 1; } else if (iscollision && onslabmode == 3) { onslabmode = 2; }
    return onslabmode;
}
function setslabsplashslabinfo32(materialid, slabpartsidepathEle, mslablist) {
    let onslabmode = 0;
    if (mslablist != null) {
        for (let i = 0; i < mslablist.length; i++) {
            onslabmode = 0;
            let mslabgEle = document.querySelector("#" + "mslabpathg" + mslablist[i].ID);
            if (isshapeinbox(mslabgEle, slabpartsidepathEle)) { onslabmode = 3; }
            if (isshapesideintersect(mslabgEle, slabpartsidepathEle, 'setslabpartsplashslabinfo32')) {
                shapeslabsplash.slabid = mslablist[i].ID, shapeslabsplash.slabindex = i;
            }
            if (onslabmode != 0) { break; }
        }
    }
    let iscollision = detectslabpartcollision(materialid);
    //console.log(onslabmode, iscollision);
    if (iscollision && onslabmode == 0) { onslabmode = 1; } else if (iscollision && onslabmode == 3) { onslabmode = 2; }
    shapeslabsplash.color = slabpartsplashfillcolor(onslabmode);
    return onslabmode;
}
function detectslabpartcollision(materialid) {
    //1. get material parts
    //2. loop throup all part shapes  and add to slabaprts. 
    let areashapeindex = shape.areaid + "" + shape.index;
    for (let i = 0; i < shape.sides.length; i++) {
        let sidepathindex = areashapeindex + "" + i;
        let slabpartsidepathgEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);
        if (detectslabpartcollision1(materialid, areashapeindex, slabpartsidepathgEle)) { return true; }
    }
    return false;
}
function detectslabpartcollision1(materialid, areashapeindex, slabpartsidepathgEle) {
    let source = 'detectslabpartcollision1';
    let matpartlist = getpartlistbymaterialId31(materialid, source);
    if (matpartlist != null) {
        for (let i = 0; i < matpartlist.length; i++) {
            let tmppartshape = parsepartshape(matpartlist[i].Shape);
            if (tmppartshape != null && tmppartshape.areaid != undefined) {
                for (let j = 0; j < tmppartshape.slabparts.length; j++) {
                    let tmpareashapeindex = tmppartshape.areaid + "" + tmppartshape.partsrno + "" + j;
                    if (areashapeindex != tmpareashapeindex) {
                        if (detectslabpartcollision2(tmpareashapeindex, tmppartshape, slabpartsidepathgEle)) { return true; }
                    }
                    if (detectslabpartsplashscollision2(tmppartshape, slabpartsidepathgEle)) { return true; }
                }
            }
        }
    }
    return false;
}
function detectslabpartcollision2(tmpareashapeindex, tmppartshape, slabpartsidepathgEle) {
    for (let k = 0; k < tmppartshape.sides.length; k++) {
        let sidepathindex = tmpareashapeindex + "" + k;
        let tmpslabpartsidepathgEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);
        if (tmpslabpartsidepathgEle != null) {
            if (isshapesideintersect(slabpartsidepathgEle, tmpslabpartsidepathgEle, 'detectslabpartcollision2')) {
                return true;
            }
        }
    }
    return false;
}
function detectslabpartsplashscollision2(tmppartshape, slabpartsidepathgEle) {
    for (let i = 0; i < tmppartshape.sides.length; i++) {
        for (let j = 0; j < tmppartshape.sides[i].splashs.length; j++) {
            for (let k = 0; k < tmppartshape.sides[i].splashs[j].slabsplashs.length; k++) {
                let slabsplashindex = tmppartshape.areaid + "" + tmppartshape.partsrno + "" + i + "" + j + "" + k;
                let tmpslabsplashsidepathgEle = document.querySelector("#" + "slabsplashpath" + slabsplashindex);
                if (tmpslabsplashsidepathgEle != null) {
                    if (isshapesideintersect(slabpartsidepathgEle, tmpslabsplashsidepathgEle, 'detectslabpartsplashscollision2')) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function isshapeinbox(el1, el2) {
    if (el1 == null || el2 == null) { return false; }
    let elb1 = el1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    let elb2 = el2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT
    //console.log(Math.round(elb1.left), Math.round(elb1.right), Math.round(elb1.top), Math.round(elb1.bottom), Math.round(elb2.left), Math.round(elb2.right), Math.round(elb2.top), Math.round(elb2.bottom)
    //    , elb2.left < elb1.left, elb2.top > elb1.top, elb2.right < elb1.right, elb2.bottom < elb1.bottom);
    //CHECK IF THE TWO BOUNDING BOXES OVERLAP

    return ((elb1.left < elb2.left) && (elb1.top < elb2.top) && (elb1.right > elb2.right) && (elb1.bottom > elb2.bottom));
}
function isshapesideintersect(el1, el2, source) {
    if (el1 == null || el2 == null) { return false; }
    let elb1 = el1.getBoundingClientRect();    //BOUNDING BOX OF THE FIRST OBJECT
    let elb2 = el2.getBoundingClientRect();    //BOUNDING BOX OF THE SECOND OBJECT
    //console.log(Math.round(elb1.left), Math.round(elb1.right), Math.round(elb1.top), Math.round(elb1.bottom), Math.round(elb2.left), Math.round(elb2.right), Math.round(elb2.top), Math.round(elb2.bottom)
    //    , elb2.left > elb1.right, elb2.right < elb1.left, elb2.top > elb1.bottom, elb2.bottom < elb1.top, source);
    //CHECK IF THE TWO BOUNDING BOXES OVERLAP
    return !(elb2.left > elb1.right || elb2.right < elb1.left || elb2.top > elb1.bottom || elb2.bottom < elb1.top);
}

