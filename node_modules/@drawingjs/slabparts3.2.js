function initslabpart31(index, partshape) {
    let slabpart = { index: index, x: 0, y: 0, tx: partshape.tx, ty: partshape.ty, angle: 0, seamindex: -1, sideindex: 0, spseamindex: -1, spsideindex: 0 };
    partshape.slabparts.push(slabpart);  
}
function setshapeslabapartinfo(spindex, mode, source) {
    //console.log(shape.slabparts.length, spindex, mode, source);
    let slabpart = shape.slabparts[spindex];
    if (slabpart != undefined) {
        shape.tx = slabpart.tx;
        shape.ty = slabpart.ty;
        shape.angle = slabpart.angle;
        shape.spindex = spindex;
        shape.lindex = shape.index;
        shape.index = shape.partsrno + "" + spindex;
        shape.mode = mode;
        if (slabpart.color != undefined) { shape.color = slabpart.color; }
    }    
}
function setslabpart31(index, seamindex, sideindex, spseamindex, spsideindex, partshape) {
    //console.log(index, seamindex, sideindex, spseamindex, spsideindex);
    if (index == -1) { index = partshape.slabparts.length; initslabpart31(index, partshape); }
    let seamside = partshape.sides[spsideindex];   
    seamside.seams[spseamindex].split = 1;
    let slabpart = partshape.slabparts[index];
    slabpart.tx = shape.tx + 10;
    slabpart.ty = shape.ty;
    slabpart.angle = shape.angle;
    slabpart.seamindex = seamindex;
    slabpart.sideindex = sideindex;
    slabpart.spseamindex = spseamindex;
    slabpart.spsideindex = spsideindex;
    slabpart.color = shape.color;
}
function setslabpart32(index, spindex, partsrno, areaid, mode, source) {
    let partshape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    shape = getpartshapecopybyareaidpartsrno(partsrno, areaid);
    setshapeslabapartinfo(spindex, mode, source);
    //console.log(index, spindex, partsrno, areaid, shape.sides.length, shape.slabparts.length, source);
    let slabpart = shape.slabparts[spindex];
    let startseamindex = slabpart.spseamindex, startsideindex = slabpart.spsideindex, startseamtype = -1, endseamtype = -1;
    if (startseamindex != -1) { startseamtype = shape.sides[startsideindex].seams[startseamindex].type; }
    if (shape.slabparts.length > 1) {
        let endseamindex = -1; endsideindex = shape.sides.length - 1;        
        for (let i = startsideindex; i < shape.sides.length; i++) {
            for (let j = 0; j < shape.sides[i].seams.length; j++) {
                if (!(i == startsideindex && j == startseamindex)) {
                    if (shape.sides[i].seams[j].isactive == 1 && shape.sides[i].seams[j].split == 1) {
                        endseamtype = shape.sides[i].seams[j].type, endseamindex = j; endsideindex = i;
                        //console.log(index, spindex, partsrno, areaid, startsideindex, startseamindex);
                        break;
                    }
                }
            }
        }
        setseamedslabpartshape30(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, mode, source);
    }
}
function setpartshapeslabparts31(partshape, mode, source) {
    //1.sceanrios 1. no slabaprt. 2. non seamed slabaprt 3. seamed slabpart     
    partshape = parsepartshape(partshape);    
    if (partshape.slabparts == undefined || partshape.slabparts == null) { partshape.slabparts = []; }
    if (partshape.slabparts.length == 0) { initslabpart31(0, partshape); }
    let spindex = 0, startseamindex = -1, startsideindex = 0, startseamtype = -1, endseamtype = -1;
    if (partshape.slabparts.length == 1) {
        shape = JSON.parse(JSON.stringify(partshape));       
        setseamedslabpartshape30(spindex, startseamindex, startseamtype, startsideindex, -1, shape.sides.length - 1, endseamtype, partshape, mode, source);
        drawslabpart31(shape.index, mode, source + ':setseamedslabpartshape30');
    } else {        
        for (let i = 0; i < partshape.sides.length; i++) {
            //console.log(i, partshape.sides[i].corners[0].type, partshape.sides[i].corners[1].type, partshape.sides[i].corners[2].type, partshape.sides[i].corners[3].type);
            for (let j = 0; j < partshape.sides[i].seams.length; j++) {
                //console.log(JSON.stringify(partshape.sides[i].seams));
                if (partshape.sides[i].seams[j].isactive == 1 && partshape.sides[i].seams[j].split == 1) {
                    shape = JSON.parse(JSON.stringify(partshape));
                    endseamtype = shape.sides[i].seams[j].type, endseamindex = j; endsideindex = i;                    
                    //console.log("spindex:" + spindex, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + j, "endsideindex:" + i, "endseamtype:" + endseamtype, "source:" + source);
                    setseamedslabpartshape30(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, mode, source);
                    drawslabpart31(shape.index, mode, source + ':setseamedslabpartshape30');
                    startseamindex = j, startsideindex = i, startseamtype = endseamtype;
                    spindex++;
                }
            }
        }
        shape = JSON.parse(JSON.stringify(partshape));
        setseamedslabpartshape30(spindex, startseamindex, startseamtype, startsideindex, -1, shape.sides.length - 1, -1, partshape, mode, source);
        drawslabpart31(shape.index, mode, source + ':setseamedslabpartshape30');
    }
}
function setseamedslabpartshape30(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, mode, source) {
    //console.log("spindex:" + spindex, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    //smtype:1-vertical, 2- angled,3-horizontal   
    setshapeslabapartinfo(spindex, mode, source);
    let seamtype = -1; if (endseamtype == -1) { seamtype = startseamtype; } else { seamtype = endseamtype; }
    if (startseamtype == 3 || endseamtype == 3) { //1. horizontal seam       
        setseamedslabpartshape33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    } else {
        setseamedslabpartshape32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    }    
}
function setseamedslabpartshape32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //1.set shape sides    
    setseamshapesides32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, source);
    resetsidesindex32();
    //2.trim seamed sides 
    trimstartseamside32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    trimendseamside32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    //3.set seamed corners 
    setstartseamsidecorners32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    setendseamsidecorners32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    //4. set seamed side sideshapes
    if (startseamtype == 1) { setseamsideshapes32(spindex, 0, startsideindex, startseamtype, partshape, source); }
    if (endseamtype == 1) { setseamsideshapes32(spindex, shape.sides.length - 1, endsideindex, endseamtype, partshape, source); }
    //5. set seamed side seams
    setseamedsideseams32(0);
    setseamedsideseams32(shape.sides.length - 1);
    //6. set seamed side cutouts
    setseamedsidecutouts32(0);
    setseamedsidecutouts32(shape.sides.length - 1);
    //7.reset seamed side edges index
    resetseamedsideedgesindex32(0);
    resetseamedsideedgesindex32(shape.sides.length - 1);
    //8.reset seamed side widths
    setseamedsidewidth32(0);
    setseamedsidewidth32(shape.sides.length - 1);
   // console.log(spindex, shape.sides[0].w1);
}
function setseamshapesides32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, source) {
    //console.log("spindex:" + spindex, "seamtype:" + seamtype, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    //1. set seamed shape sides
    let nsides = [];
    let startsideindex1 = startsideindex;
    if (startseamtype == 2) { startsideindex1 += 1;}
    let startseamside = shape.sides[startsideindex1];
    nsides.push(startseamside);    
    if ((endsideindex - startsideindex1) > 1) { for (let i = startsideindex + 1; i < endsideindex; i++) { nsides.push(shape.sides[i]);}}
    if (startsideindex1 != endsideindex) { let endseamside = shape.sides[endsideindex]; nsides.push(endseamside); }   
    shape.sides = nsides;    
}
function trimstartseamside32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //console.log("spindex:" + spindex, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    if (startseamindex != -1) {
        let seamside = shape.sides[0];
        let seam = partshape.sides[startsideindex].seams[startseamindex];
        let sx11 = seam.x1, sy11 = seam.y1, sx21 = seam.x2, sy21 = seam.y2, sx1 = (sx11 + sx21) / 2, sy1 = (sy11 + sy21) / 2;
        seamside.x11 = sx11, seamside.y11 = sy11, seamside.x21 = sx21, seamside.y21 = sy21, seamside.x1 = sx1, seamside.y1 = sy1;
    }    
}
function trimendseamside32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    if (endseamindex != -1) {
        let seamside = shape.sides[shape.sides.length - 1];
        let seam = partshape.sides[endsideindex].seams[endseamindex];
        let sx12 = seam.x1, sy12 = seam.y1, sx22 = seam.x2, sy22 = seam.y2, sx2 = (sx12 + sx22) / 2, sy2 = (sy12 + sy22) / 2;
        seamside.x12 = sx12, seamside.y12 = sy12, seamside.x22 = sx22, seamside.y22 = sy22, seamside.x2 = sx2, seamside.y2 = sy2;
    }
}
function setstartseamsidecorners32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape,  source) {
   // console.log("spindex:" + spindex, "seamtype:" + seamtype, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    if (startseamindex != -1) {
        let seamside = shape.sides[0];       
        if (startseamtype == 1) { seamside.corners[0].type = 0, seamside.corners[1].type = 0; }
        else if (startseamtype == 2) {
            let seam = partshape.sides[startsideindex].seams[startseamindex];           
            seamside.corners[0].sx1 = seam.sx1;
            seamside.corners[0].sy1 = seam.sy1;
            seamside.corners[0].split = 1;
            seamside.corners[0].seamindex = startseamindex;           
            seamside.corners[1].sx1 = seam.sx2;
            seamside.corners[1].sy1 = seam.sy2;
            seamside.corners[1].split = 1;
            seamside.corners[1].seamindex = startseamindex;
        }
    }
}
function setendseamsidecorners32(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //console.log("spindex:" + spindex, "seamtype:" + seamtype, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    if (endseamindex != -1) {
        let seamside = shape.sides[shape.sides.length -1];
        if (endseamtype == 1) { seamside.corners[2].type = 0, seamside.corners[3].type = 0; }
        else if (endseamtype == 2) {           
            let seam = partshape.sides[endsideindex].seams[endseamindex];
           // console.log(seam.sx1, seam.sy1, seam.sx2, seam.sy2);
            seamside.corners[2] = JSON.parse(JSON.stringify(partshape.sides[endsideindex + 1].corners[0]));
            seamside.corners[2].index = 2;          
            seamside.corners[2].sx1 = seam.sx1;
            seamside.corners[2].sy1 = seam.sy1;           
            seamside.corners[2].split = 1;
            seamside.corners[2].seamindex = endseamindex;
            seamside.corners[3] = JSON.parse(JSON.stringify(partshape.sides[endsideindex + 1].corners[1]));
            seamside.corners[3].index = 3;          
            seamside.corners[3].sx1 = seam.sx2;
            seamside.corners[3].sy1 = seam.sy2;
            seamside.corners[3].split = 1;
            seamside.corners[3].seamindex = endseamindex;
        }
    }
}
function setseamsideshapes32(spindex, seamedsideindex, partshapesideindex, seamtype, partshape, source) {    
    let seamedside = shape.sides[seamedsideindex];         
    let x11 = seamedside.x11, y11 = seamedside.y11, x12 = seamedside.x12, y12 = seamedside.y12, x21 = seamedside.x21, y21 = seamedside.y21, x22 = seamedside.x22, y22 = seamedside.y22;
    let nsideshapes = [];
    for (let j = 0; j < seamedside.sideshapes.length; j++) {        
        if (seamedside.sideshapes[j].isactive == 1) {
            let sideshape = JSON.parse(JSON.stringify(seamedside.sideshapes[j]));           
            let sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sx21 = sideshape.x21, sy21 = sideshape.y21, sx22 = sideshape.x22, sy22 = sideshape.y22, stypeid = sideshape.typeid;
            let isinline = ispointinline(x11, y11, x12, y12, sx11, sy11);
            let isinline1 = ispointinline(x21, y21, x22, y22, sx12, sy12);
           // console.log(spindex, seamedsideindex, partshapesideindex, seamedside.sideshapes.length, sideshape.type, seamtype, source);
            if (stypeid == 11) { isinline = true; }
            if (isinline || isinline1) {
                sideshape.dw = calchyplen(x11, y11, sx11, sy11);
                sideshape.sideindex = seamedsideindex;
                nsideshapes.push(sideshape);
            }
        }
    }    
    seamedside.sideshapes = nsideshapes;
}
function setseamedsideseams32(seamedsideindex) {
    let seamedside = shape.sides[seamedsideindex];
    let x11 = seamedside.x11, y11 = seamedside.y11, x12 = seamedside.x12, y12 = seamedside.y12;
    let nseams = [];
    for (let j = 0; j < seamedside.seams.length; j++) {
        let sideseam = JSON.parse(JSON.stringify(seamedside.seams[j]));
        //if(sideseam.split==0){
        let sx1 = sideseam.x1, sy1 = sideseam.y1, sx2 = sideseam.x2, sy2 = sideseam.y2;
        let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
        sideseam.sideindex = seamedsideindex;
        if (isinline) { nseams.push(sideseam); }
       //}
    }
    seamedside.seams = nseams;
}
function setseamedsidecutouts32(seamedsideindex) {
    let seamedside = shape.sides[seamedsideindex];
    let x11 = seamedside.x11, y11 = seamedside.y11, x12 = seamedside.x12, y12 = seamedside.y12;
    let ncutouts = [];
    //work on logic later
    //for (let j = 0; j < seamedside.cutouts.length; j++) {
    //    let cutout = JSON.parse(JSON.stringify(seamedside.cutouts[j]));
    //    let sx1 = cutout.x, sy1 = cutout.y, w = cutout.w, h = cutout.h;
    //    let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
    //    if (isinline) { ncutouts.push(cutout); }
    //}
    seamedside.cutouts = ncutouts;
}
function resetsidesindex32() {
    for (let j = 0; j < shape.sides.length; j++) {
        shape.sides[j].index = j;
    }
}
function resetseamedsideedgesindex32(seamedsideindex) {
    let seamedside = shape.sides[seamedsideindex];
    for (let j = 0; j < seamedside.edges.length; j++) {
        seamedside.edges[j].sideindex = seamedside.index;
    }    
}
function setseamedsidewidth32(seamsideindex) {
    let seamside = shape.sides[seamsideindex];
    seamside.w = applymminchfact(calchyplen(seamside.x1, seamside.y1, seamside.x2, seamside.y2), 2, 2);
    seamside.w1 = applymminchfact(calchyplen(seamside.x11, seamside.y11, seamside.x12, seamside.y12), 2, 2);
    seamside.w2 = applymminchfact(calchyplen(seamside.x21, seamside.y21, seamside.x22, seamside.y22), 2, 2);
}
function setseamedslabpartshape33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //1.set shape sides    -- rectangle shape 1 side only   
    //2.trim seamed sides 
    trimstartseamside33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    trimendseamside33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    //3.set seamed corners 
    setstartseamsidecorners33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    setendseamsidecorners33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);
    //4. set seamed side sideshapes
    setseamedsideshapes33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source);   
    ////5. set seamed side seams
    setseamedsideseams33(0);  
    //6. set seamed side cutouts
    setseamedsidecutouts32(0);   
    //7.reset seamed side edges index
    resetseamedsideedgesindex32(0);    
    //8.reset seamed side heights
    setseamedsideheight33(0);
}
function trimstartseamside33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //console.log("spindex:" + spindex, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    if (startseamindex != -1) {
        let seamside = shape.sides[0];
        let seam = partshape.sides[startsideindex].seams[startseamindex];
        let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2;
        seamside.x11 = sx1, seamside.y11 = sy1, seamside.x12 = sx2, seamside.y12 = sy2;
    }
}
function trimendseamside33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //console.log("spindex:" + spindex, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    if (endseamindex != -1) {
        let seamside = shape.sides[0];
        let seam = partshape.sides[startsideindex].seams[endseamindex];
        let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2;
        seamside.x21 = sx1, seamside.y21 = sy1, seamside.x22 = sx2, seamside.y22 = sy2;
    }
}
function setstartseamsidecorners33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    // console.log("spindex:" + spindex, "seamtype:" + seamtype, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    let seamside = shape.sides[0];
    if (startseamindex != -1) { seamside.corners[0].type = 0, seamside.corners[2].type = 0; } else { seamside.corners[1].type = 0, seamside.corners[3].type = 0; }
}
function setendseamsidecorners33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    //console.log("spindex:" + spindex, "seamtype:" + seamtype, "startseamindex:" + startseamindex, "startseamtype:" + startseamtype, "startsideindex:" + startsideindex, "endseamindex:" + endseamindex, "endsideindex:" + endsideindex, "endseamtype:" + endseamtype, "source:" + source);
    let seamside = shape.sides[0];
    if (endseamindex != -1) { seamside.corners[1].type = 0, seamside.corners[3].type = 0; } else { seamside.corners[0].type = 0, seamside.corners[2].type = 0; }
}
function setseamedsideshapes33(spindex, startseamindex, startseamtype, startsideindex, endseamindex, endsideindex, endseamtype, partshape, source) {
    let seamedside = shape.sides[0];   
    let x11 = seamedside.x11, y11 = seamedside.y11, x12 = seamedside.x12, y12 = seamedside.y12, x21 = seamedside.x21, y21 = seamedside.y21, x22 = seamedside.x22, y22 = seamedside.y22;
    let nsideshapes = [];
    for (let j = 0; j < seamedside.sideshapes.length; j++) {
        if (seamedside.sideshapes[j].isactive == 1) {
            let sideshape = JSON.parse(JSON.stringify(seamedside.sideshapes[j]));
            let sx11 = sideshape.x11, sy11 = sideshape.y11, sx12 = sideshape.x12, sy12 = sideshape.y12, sidecode = sideshape.sidecode;
            if (sidecode == 1 || sidecode == 2) {
                let angle = calclineangle2(x11, y11, x12, y12);
                let angle1 = calclineangle2(x11, y11, sx11, sy11);
                let angle2 = calclineangle2(x21, y21, sx11, sy11);
                if ((angle == angle1) || (angle == angle2)) {
                    sideshape.dw = calchyplen(x11, y11, sx11, sy11);
                    nsideshapes.push(sideshape);
                }
            } else {
                let isinline = ispointinline(x11, y11, x21, y21, sx11, sy11);
                let isinline1 = ispointinline(x12, y12, x22, y22, sx12, sy12);
                // console.log(seamedside.index, x11, y11, x12, y12, x21, y21, x22, y22, sx11, sy11, sx12, sy12, sidecode, isinline, isinline1);
                if (isinline || isinline1) {
                    sideshape.dw = calchyplen(x11, y11, sx11, sy11);
                    nsideshapes.push(sideshape);
                }
            }
        }
    }
    seamedside.sideshapes = nsideshapes;
}
function setseamedsideseams33(seamedsideindex) {
    let seamedside = shape.sides[seamedsideindex];
    let x11 = seamedside.x11, y11 = seamedside.y11, x21 = seamedside.x21, y21 = seamedside.y21;
    let nseams = [];
    for (let j = 0; j < seamedside.seams.length; j++) {
        let sideseam = JSON.parse(JSON.stringify(seamedside.seams[j]));
        //if(sideseam.split==0){
        let sx1 = sideseam.x1, sy1 = sideseam.y1, sx2 = sideseam.x2, sy2 = sideseam.y2;
        let isinline = ispointinline(x11, y11, x21, y21, sx1, sy1); // inline test doesn't work for parallel lines with sides. So used vertical sides to test
        let isinline1 = ispointinline(x11, y11, x21, y21, sx2, sy2);        
        if (isinline) { nseams.push(sideseam); }
        //}
    }
    seamedside.seams = nseams;
}
function setseamedsideheight33(seamedsideindex) {
    let seamside = shape.sides[seamedsideindex];
    let x11 = seamside.x11, y11 = seamside.y11, x12 = seamside.x12, y12 = seamside.y12, x21 = seamside.x21, y21 = seamside.y21, x22 = seamside.x22, y22 = seamside.y22;
    let x1 = (x11 + x21) / 2, y1 = (y11 + y21) / 2, x2 = (x12 + x22) / 2, y2 = (y12 + y22) / 2;
    seamside.x1 = x1, seamside.y1 = y1, seamside.x2 = x2, seamside.y2 = y2;
    seamside.h = applymminchfact(calchyplen(x11, y11, x21, y21), 2, 2);
}
function onsetslabpartshape31(index, spindex, partsrno, areaid, source) {
    //console.log(index, spindex, partsrno, areaid, source)
    setslabpart32(index, spindex, partsrno, areaid, shape.mode, source);    
    setshapegroups31(index, shape.mode, source);
}
function onaddslabpartseam32(index, sideindex, source) {
    //called when seam added. When seam is added reorder/reindex seams in partshape. redraw/reset seam indexes 
    let partshape = getpartshapecopybyareaidpartsrno(shape.partsrno, shape.areaid);
    setpartshapeslabparts31(partshape, shape.mode, 'onaddslabpartseam');
}
function onseamslabpart31(index, sideindex, spseamindex, spsideindex, seamtype) {
    //console.log(index, sideindex, spseamindex, spsideindex, seamtype);
    removeshapecontrols();
    //1.get part and set partshape
    let partshape = getpartshapecopybyareaidpartsrno(shape.partsrno, shape.areaid);
    //2.set new slabpart
    setslabpart31(-1, index, sideindex, spseamindex, spsideindex, partshape);
    //3. set part slabparts  
    setpartshapeslabparts31(partshape, shape.mode, 'onseamslabpart31');
    //4.update part shape in scope
    ActionSeamSlabpart(spseamindex, spsideindex, partshape, 'onseamslabpart31');
}
function drawslabpart31(index, mode, source) {
    let areashapeindex = shape.areaid + "" + index;
    let tmpshapeouterg = mslabpartsg.select("#slabpartouter" + areashapeindex);
    if (!tmpshapeouterg.empty()) { tmpshapeouterg.selectAll('*').remove(); }
    if (shape.layout == 1) {
        setshapegroups31(index, mode, 'drawslabpart');       
        shapesides(source + ':drawslabpart31');
        transformshape();
        if (shape.angle != 0) { rotateshape(0, index, shape.angle); }
    }
    //if (layoutmode == 2) {
    //drawslabpartdg32(index, source)
        //onsetslabpartclipimage(index);
   // }
}
function setslabpartcoords() {
    let shapeoutergcoords = bboxcoords(shapeouterg);
    let slabgcoords = bboxcoords(mslabsg);
    let partshapey = 0;
    partshapey = -shape.y + shapeoutergcoords.h + slabparty;
    if (shape.sides.length > 1) { partshapey += shape.h / 2; }
    let partshapex = -shape.x + slabgcoords.w;
    shape.tx = partshapex;
    shape.ty = partshapey;
    slabparty += 20;
}
function ondeleteslabpart31(index) {
    let source = 'ondeleteslabpart31';
    removeshapecontrols();    
    //$("#slabpartouter" + shape.index).remove();
    deleteslabpartshapes();
    removedgshapeslabparts32(shape.partsrno, shape.spindex, shape.areaid, source)
    //1.get part and set partshape
    let partshape = getpartshapecopybyareaidpartsrno(shape.partsrno, shape.areaid);    
    //4. set part slabparts  
    setpartshapeslabparts31(partshape, shape.mode, source);
}
function deleteslabpartshapes() {    
    for (let i = 0; i < shape.slabparts.length; i++) {
        let spindex = shape.areaid + "" +  shape.partsrno + "" + i;
        $("#slabpartouter" + spindex).remove();
    }
}
function deleteslabpartshapes1(partshape) {
    if (partshape.slabparts != null && partshape.slabparts != 'null') {
        for (let i = 0; i < partshape.slabparts.length; i++) {
            let spindex = partshape.areaid + "" + partshape.partsrno + "" + i;
            $("#slabpartouter" + spindex).remove();
        }
    }
}
function ondragslabpart32() {   
    //1. slabpart slab - check boundaries
    setslabpartslabinfo32('slabpart');    
    //2. dig slabpart layout    
    if (layoutmode == 2) {
        onsetslabpartclipimage32();
    }
}
function setslabpartslabinfo32(mode) {   
    let mslablist = getmatslablistbymaterialid(shape.materialid);
    for (let i = 0; i < shape.sides.length; i++) {
        let sidepathindex = shape.areaid + "" + shape.index + "" + i;
        let slabpartsidepathEle = document.querySelector("#" + "slabpartsidepath" + sidepathindex);        
        let onslabmode = setslabpartsplashslabinfo32(shape.materialid, slabpartsidepathEle, mslablist, mode);
      //  console.log(onslabmode, shape.color);
        let slabpartsidepathg = d3.select("#" + "slabpartsidepath" + sidepathindex);
        slabpartsidepathg.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
        break;
    }
}
