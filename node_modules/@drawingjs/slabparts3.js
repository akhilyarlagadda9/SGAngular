function setslabparts(matid) {
    for (var i = 0; i < slabparts.length; i++) {
        //console.log(slabparts[i].materialid, matid);
        if (slabparts[i].materialid == matid) {
            //  if (slabparts[i].spindex != i) { slabparts[i].spindex = i; }
            if (slabparts[i].isactive == 1) { drawslabpart(i,'setslabparts'); }
        }
    }
}
function slabpartindex(spindex) {
    var index = -1;
    for (var i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {
            index = i;
            break;
        }
    }
    return index;
}
function slabpartindex1(spseamindex, spsideindex, spindex, spseamcode) {
    let index = -1;    
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {           
            if (slabparts[i].spseamsideindex == spsideindex && slabparts[i].spseamcode == spseamcode) {
                index = i;
             //   console.log(slabparts[i].spseamindex, slabparts[i].spseamsideindex, spseamindex, spsideindex, spseamcode);
                break;
            }
        }
    }
    return index;
}
function slabpartindex2(spseamindex, spsideindex, spindex) {
    let index = -1, sp1 = -1, sp2 = -1;
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {
            if (slabparts[i].spseamindex == spseamindex && slabparts[i].spseamsideindex == spsideindex) {
                if (sp1 == -1) { sp1 = i; } else { sp2 = i; } //two parts for every seam.    
                //console.log(spseamindex, spsideindex, slabparts[i].spseamcode, sp1, sp2);
            }
        }
    }
    if (sp1 > -1 && sp2 == -1) { sp2 = sp1;}
    return {
        sp1: sp1,
        sp2: sp2
    };
}
function shapeslabparts(index, sideindex, sindex) {
    let isactive = 1;
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == sindex && slabparts[i].isactive == 1) {
            if (slabparts[i].sides[sideindex].seams[index] == undefined) { isactive = 0; break; }
        }
    }
    return isactive;
}
function shapeslabpartcount(sindex) {
    let spcount = 0;
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == sindex && slabparts[i].isactive == 1) {
            spcount++;
        }
    }
    return spcount;
}
function setslabpart(index, spindex, spx, spy) {
    let slabpart = {};
    let spx1 = 0, spy1 = 0, angle = 0, spseamindex = -1, spseamsideindex = -1;
    if (index == -1) {
        index = slabparts.length; slabparts.push(slabpart);
    } else {
        spx1 = slabparts[index].tx, spy1 = slabparts[index].ty, angle = slabparts[index].angle, spseamindex = slabparts[index].spseamindex, spseamsideindex = slabparts[index].spseamsideindex;
    }
    slabpart = JSON.parse(JSON.stringify(shapes[spindex]));
    slabpart.mode = 'slabpart';
    slabpart.index = index; //slabpart index
    slabpart.id = 'slabpart' + index;
    slabpart.spindex = spindex;  //shape reference index 
    slabpart.slabid = slab.id;
    slabpart.materialid = slab.materialid;
    slabpart.slabindex = slab.index;   
    if (spx > 0 && spy > 0) {
        slabpart.x = Math.round(spx), slabpart.y = Math.round(spy); slabpart.tx = Math.round(spx - shape.x), slabpart.ty = Math.round(spy - shape.y);
    } else {
        slabpart.x = spx1, slabpart.y = spy1; slabpart.tx = spx1, slabpart.ty = spy1, slabpart.angle = angle;
    }
    slabpart.spseamindex = spseamindex;
    slabpart.spseamsideindex = spseamsideindex;
    slabpart.spseamcode = spseamindex;
    slabparts[index] = slabpart;     
    setslabpartsplashs(index);
    ActionUpdateSlabParts();   
    return index;
}
function onsetslabpart(spx, spy, source) {
    let spindex = shape.index;
    let spcount = shapeslabpartcount(spindex);
    if (spcount > 1) {       
       //setseamedslabparts(spindex);
       //initshapegroups(spindex, 'shape', 'onsetslabpart');
    } else if (spcount == 1) {
        let index = slabpartindex(spindex);
        $("#slabpartouter" + index).remove();
        unsplitshapeseams(spindex);
        let index1 = setslabpart(index, spindex, 0, 0);
        drawslabpart(index1, 'onsetslabpart:' + spcount);
        initshapegroups(spindex, 'shape', 'onsetslabpart');       
    } else if (spcount == 0) {
        if (spx > 0 && spy > 0) {
            let index = slabpartindex(spindex);
            unsplitshapeseams(spindex);
            let index1 = setslabpart(index, spindex, spx, spy);
            drawslabpart(index1, 'onsetslabpart:' + spcount);
            checklayoutsvgbounds1(index1, spx, spy);
            initshapegroups(spindex, 'shape', 'onsetslabpart');            
        }
    }    
}
function setseamedslabparts(spindex) {//recreate slabparts from shape 
    //1. set main slabpart as if it is not seamed
    //2. loop through seams and create seamed slab parts 
    let index = slabpartindex(spindex);
    let index1 = setslabpart(index, spindex, 0, 0);
    removeslabparts(spindex);   
    for (let i = 0; i < shapes[spindex].sides.length; i++) {
        for (let j = 0; j < shapes[spindex].sides[i].seams.length; j++) {           
            if (shapes[spindex].sides[i].seams[j].split == 1) {
               // let spseamindex = shapes[spindex].sides[i].seams[j].spseamindex;
               // let spseamsideindex = shapes[spindex].sides[i].seams[j].spseamsideindex;               
               // let seamedpartsindex = slabpartindex2(spseamindex, i, spindex);
               // console.log(i, j,index1, seamedpartsindex.sp1, seamedpartsindex.sp2);
               // seamslabpart3(j, i, index1, seamedpartsindex.sp2);
                // index1 = seamedpartsindex.sp2;
               index1 =  seamslabpart3(0, i, index1);
            }
        }
    }
}
function removeslabparts(spindex) {
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {          
            if (slabparts[i] != undefined) {
                $("#slabpartouter" + i).remove();                
            }
        }
    }
}
function onseamslabpart(seamindex, spseamindex, sideindex, seamtype) {  
    removeshapecontrols();
    let sindex = shape.index;  
    if (seamtype == 1) {//vertical
        seamslabpart1(seamindex, sideindex, sindex);
    } else if (seamtype == 2) {//angle       
        seamslabpart2(seamindex, sideindex, sindex);
    }
    else if (seamtype == 3) {//horizontal
        seamslabpart3(seamindex, sideindex, sindex);
    }
}

function seamslabpart1(seamindex, sideindex, sindex) {
    let slabpart = JSON.parse(JSON.stringify(slabparts[sindex]));
    let slabsubpart = JSON.parse(JSON.stringify(slabparts[sindex]));
    let seamside = slabpart.sides[sideindex];
    let seam = seamside.seams[seamindex];
    let spindex = slabpart.spindex;
    let spseamindex = seam.spseamindex;
    let slabpartindex = slabpartindex1(spseamindex, sideindex, spindex, spseamindex);
    let slabsubpartindex = slabpartindex1(spseamindex, sideindex, spindex, spseamindex + 1);
    if (slabpartindex == -1 && slabsubpartindex != -1) { slabsubpartindex = -1;}
    setseamslabpart1(seamindex, sideindex, sindex, slabpart);
    setseamslabpart2(seamindex, sideindex, sindex, slabsubpart, slabsubpartindex);
    onseamshapesideseam(spseamindex, sideindex, spindex);
   // console.log(seamindex, spseamindex, index, slabpartindex, slabsubpartindex);   
}
function seamslabpart2(index, sideindex, sindex) {
    var side = slabparts[shape.index].sides[sideindex];
    var seam = side.seams[index];
    seam.isactive = 0;
    //console.log(shape.index, shape.spindex, sideindex, index);
    //shapes[shape.spindex].sides[sideindex].seams[index].split = 1;
    var slabsubpart = JSON.parse(JSON.stringify(shape));
    var subside = slabsubpart.sides[sideindex];
    slabsubpart.index = slabparts.length;
    slabsubpart.id = 'slabpart' + slabparts.length;
    var nsides = [];
    for (let j = 0; j < sideindex; j++) {
        let nside = JSON.parse(JSON.stringify(shape.sides[j]));
        nsides.push(nside);
    }
    setsideedge1(side, 3, 'C', 0, 0);
    if (sideindex == shape.sides.length - 1) { side.corners[2].type = 0, side.corners[3].type = 0; }
    nsides.push(side);
    var nsubsides = [];
    for (let j = sideindex + 1; j < shape.sides.length; j++) {
        let nsubside = JSON.parse(JSON.stringify(shape.sides[j]));
        nsubside.index = nsubsides.length;
        resetsubpartsideitems(nsubside);
        //console.log(JSON.stringify(nsubside));
        nsubsides.push(nsubside);
    }
    setsideedge1(nsubsides[0], 0, 'C', 0, 0);
    if (nsubsides[0] != undefined) {
        nsubsides[0].corners[0].type = 0;
        nsubsides[0].corners[1].type = 0;
    }

    slabparts[shape.index].sides = nsides;
    slabsubpart.sides = nsubsides;
    slabparts.push(slabsubpart);
    //console.log(nsubsides.length, nsides.length, shape.sides.length, slabsubpart.index, slabparts.length);
    $("#slabpartouter" + shape.index).remove();
    drawslabpart(shape.index, 'splitslabpart3:slabpart');
    drawslabpart(slabsubpart.index, 'splitslabpart3:slabsubpart');
}
function seamslabpart3(seamindex, sideindex, sindex) {
    let slabpart = JSON.parse(JSON.stringify(slabparts[sindex]));
    let slabsubpart = JSON.parse(JSON.stringify(slabparts[sindex]));
    let seamside = slabpart.sides[sideindex];
    let seam = seamside.seams[seamindex];
    let spindex = slabpart.spindex;
    let spseamindex = seam.spseamindex;
    let slabpartindex = slabpartindex1(spseamindex, sideindex, spindex, spseamindex);
    let slabsubpartindex = slabpartindex1(spseamindex, sideindex, spindex, spseamindex + 1);
    if (slabpartindex == -1 && slabsubpartindex != -1) { slabsubpartindex = -1; }
    setseamslabpart3(seamindex, sideindex, sindex, slabpart);
    setseamslabpart4(seamindex, sideindex, sindex, slabsubpart, slabsubpartindex);
    onseamshapesideseam(spseamindex, sideindex, spindex);
    // console.log(seamindex, spseamindex, index, slabpartindex, slabsubpartindex);   
}
function setseamslabpart1(seamindex, sideindex, sindex, slabpart) {   
    let sidelength = slabpart.sides.length;
    let seamside = slabpart.sides[sideindex];
    let seam = seamside.seams[seamindex];
    let spseamindex = seam.spseamindex;
    seam.split = 1;   
    slabpart.spseamindex = spseamindex == 0 ? spseamindex : spseamindex - 1;
    slabpart.spseamsideindex = sideindex;
    slabpart.spseamcode = spseamindex;    
    let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2, x1 = (sx1 + sx2) / 2, y1 = (sy1 + sy2) / 2;
    seamside.x12 = sx1, seamside.y12 = sy1, seamside.x22 = sx2, seamside.y22 = sy2, seamside.x2 = x1, seamside.y2 = y1;
    seamside.w = calchyplen(seamside.x1, seamside.y1, seamside.x2, seamside.y2) / scale;
    seamside.w1 = calchyplen(seamside.x11, seamside.y11, seamside.x12, seamside.y12) / scale;
    seamside.w2 = calchyplen(seamside.x21, seamside.y21, seamside.x22, seamside.y22) / scale;
    //1. set seamside measurements
   // let seamside = setslabpartseamside1(index, sideindex);
    //2. set seamside edges
    setsideedge1(seamside, 3, 'C', 0, 0);
    //3. set previous sides
    let nsides = [];
    setslabpartseamsides1(sideindex, nsides, slabpart);
    //4. set seamside corners
    if (sideindex == sidelength - 1) { seamside.corners[2].type = 0, seamside.corners[3].type = 0; }
    //5. set seamside cutouts
    subpartsidecutouts(seamside);
    //6. set saemside seams
    subpartsideseams(seamside);
    //6. set seamside shapes
    subpartsideshapes(seamside, "side");
    nsides.push(seamside);  
    slabpart.sides = nsides;
    
    slabparts[sindex] = slabpart;   
    $("#slabpartouter" + sindex).remove();
    drawslabpart(sindex, 'setseamslabpart1');
}
function setseamslabpart2(seamindex, sideindex, sindex, slabsubpart, slabsubpartindex) {
    let sidelength = slabsubpart.sides.length;
    let seamside = slabsubpart.sides[sideindex];
    let seam = seamside.seams[seamindex];
    let sx1 = seam.x1, sy1 = seam.y1, sx2 = seam.x2, sy2 = seam.y2, x1 = (sx1 + sx2) / 2, y1 = (sy1 + sy2) / 2;
    let subseamside = slabsubpart.sides[sideindex];
    let spseamindex = seam.spseamindex;
    slabsubpart.spseamindex = seam.spseamindex;
    slabsubpart.spseamsideindex = sideindex;
    slabsubpart.spseamcode = spseamindex + 1;

    subseamside.index = 0, subseamside.x11 = sx1, subseamside.y11 = sy1, subseamside.x21 = sx2, subseamside.y21 = sy2, subseamside.x1 = x1, subseamside.y1 = y1;
    subseamside.w = calchyplen(subseamside.x1, subseamside.y1, subseamside.x2, subseamside.y2) / scale;
    subseamside.w1 = calchyplen(subseamside.x11, subseamside.y11, subseamside.x12, subseamside.y12) / scale;
    subseamside.w2 = calchyplen(subseamside.x21, subseamside.y21, subseamside.x22, subseamside.y22) / scale;
    
    //1. set seamside measurements
    //setslabpartseamside2(index, sideindex, subseamside);
    //2. set seamside edges
    setsideedge1(subseamside, 0, 'C', 0, 0);
    //3. set seamside corners
    subseamside.corners[0].type = 0, subseamside.corners[1].type = 0;   
    //5. set seamside seams
    subpartsideseams(subseamside);
    //4. set seamside cutouts
    subpartsidecutouts(subseamside);
    //6. set saemside shapes
    subpartsideshapes(subseamside, "subside");
    //7. reset seamside shapes
    resetsubpartsideitems(subseamside);
    //8. reset seamside next shapes
    let nsubsides = [];
    nsubsides.push(subseamside);
    setslabpartseamsides2(sideindex, nsubsides, slabsubpart);
    slabsubpart.sides=nsubsides;   
    if (slabsubpartindex == -1) {
        slabsubpartindex = slabparts.length;
        slabparts.push(slabsubpart);
    } else {
        let spx1 = slabparts[slabsubpartindex].tx, spy1 = slabparts[slabsubpartindex].ty, angle = slabparts[slabsubpartindex].angle;
        slabsubpart.x = spx1, slabsubpart.y = spy1; slabsubpart.tx = spx1, slabsubpart.ty = spy1, slabsubpart.angle = angle;
    }
    slabsubpart.index = slabsubpartindex;
    slabsubpart.id = 'slabpart' + slabsubpartindex;
    slabparts[slabsubpartindex] = slabsubpart;   
    $("#slabpartouter" + slabsubpartindex).remove();
    drawslabpart(slabsubpartindex, 'setseamslabpart2');  
    
}
function setseamslabpart3(seamindex, sideindex, sindex, slabpart) {
   // console.log(seamindex, sideindex, sindex, slabpart.sides.length);
    let sidelength = slabpart.sides.length;
    let seamside = slabpart.sides[sideindex];
    let seam = seamside.seams[seamindex];
    let spseamindex = seam.spseamindex;
    seam.split = 1;
    slabpart.spseamindex = spseamindex == 0 ? spseamindex : spseamindex - 1;
    slabpart.spseamsideindex = sideindex;
    slabpart.spseamcode = spseamindex;
    let x21 = seam.x1, y21 = seam.y1, x22 = seam.x2, y22 = seam.y2;    
    let x11 = seamside.x11, y11 = seamside.y21, x12 = seamside.x22, y12 = seamside.y22;   
    let x1 = (x11 + x21) / 2, y1 = (y11 + y21) / 2; x2 = (x11 + x21) / 2, y2 = (y11 + y21) / 2;
    seamside.x21 = x21, seamside.y21 = y21, seamside.x22 = x22, seamside.y22 = y22;
    seamside.x1 = x1, seamside.y1 = y1, seamside.x2 = x2, seamside.y2 = y2;
    seamside.h= calchyplen(seamside.x21, seamside.y21, seamside.x22, seamside.y22) / scale;    
    //1. set seamside measurements
    //let seamside = setslabpartseamside1(index, sideindex);
    //2. set seamside edges
    setsideedge1(seamside, 2, 'C', 0, 0);
    //3. set previous sides
    let nsides = [];
    setslabpartseamsides1(sideindex, nsides, slabpart);
    //4. set seamside corners
    if (sideindex == sidelength - 1) { seamside.corners[2].type = 0, seamside.corners[3].type = 0; }
    //5. set seamside cutouts
    subpartsidecutouts(seamside);
    //6. set saemside seams
    subpartsideseams(seamside);
    //6. set seamside shapes
    subpartsideshapes(seamside, "subside");
    nsides.push(seamside);
    slabpart.sides = nsides;
    
    slabparts[sindex] = slabpart;
    $("#slabpartouter" + sindex).remove();
    drawslabpart(sindex, 'setseamslabpart1');
}
function setseamslabpart4(seamindex, sideindex, sindex, slabsubpart, slabsubpartindex) {
    let sidelength = slabsubpart.sides.length;
    let seamside = slabsubpart.sides[sideindex];
    let seam = seamside.seams[seamindex];    
    let subseamside = slabsubpart.sides[sideindex];
    let spseamindex = seam.spseamindex;
    slabsubpart.spseamindex = seam.spseamindex;
    slabsubpart.spseamsideindex = sideindex;
    slabsubpart.spseamcode = spseamindex + 1;

    let x11 = seam.x1, y11 = seam.y1, x12 = seam.x2, y12 = seam.y2;    
    let x21 = subseamside.x21, y21 = subseamside.y21, x22 = subseamside.x22, y22 = subseamside.y22;
    let x1 = (x11 + x21) / 2, y1 = (y11 + y21) / 2; x1 = (x11 + x21) / 2, y1 = (y11 + y21) / 2;
    subseamside.x11 = x11, subseamside.y11 = y11, subseamside.x12 = x12, subseamside.y12 = y12;
    subseamside.x1 = x1, subseamside.y1 = y1, subseamside.x2 = x2, subseamside.y2 = y2;
    subseamside.h = calchyplen(subseamside.x11, subseamside.y11, subseamside.x12, subseamside.y12) / scale;

    //1. set seamside measurements
    //setslabpartseamside2(index, sideindex, subseamside);
    //2. set seamside edges
    setsideedge1(subseamside, 1, 'C', 0, 0);
    //3. set seamside corners
    subseamside.corners[0].type = 0, subseamside.corners[1].type = 0;
    //5. set seamside seams
    subpartsideseams(subseamside);
    //4. set seamside cutouts
    subpartsidecutouts(subseamside);
    //6. set saemside shapes
    subpartsideshapes(subseamside, "subside");
    //7. reset seamside shapes
    resetsubpartsideitems(subseamside);
    //8. reset seamside next shapes
    let nsubsides = [];
    nsubsides.push(subseamside);
    setslabpartseamsides2(sideindex, nsubsides, slabsubpart);
    slabsubpart.sides = nsubsides;
    if (slabsubpartindex == -1) {
        slabsubpartindex = slabparts.length;
        slabparts.push(slabsubpart);
    } else {
        let spx1 = slabparts[slabsubpartindex].tx, spy1 = slabparts[slabsubpartindex].ty, angle = slabparts[slabsubpartindex].angle;
        slabsubpart.x = spx1, slabsubpart.y = spy1; slabsubpart.tx = spx1, slabsubpart.ty = spy1, slabsubpart.angle = angle;
    }
    slabsubpart.index = slabsubpartindex;
    slabsubpart.id = 'slabpart' + slabsubpartindex;
    slabparts[slabsubpartindex] = slabsubpart;
    $("#slabpartouter" + slabsubpartindex).remove();
    drawslabpart(slabsubpartindex, 'setseamslabpart2');

}
function setslabpartseamsides1(sideindex, nsides, slabpart) {   
    for (let j = 0; j < sideindex; j++) {
        let nside = JSON.parse(JSON.stringify(slabpart.sides[j]));
        nsides.push(nside);
    }
    return nsides;
}
function setslabpartseamsides2(sideindex, nsubsides, slabsubpart) {
    for (let j = sideindex + 1; j < slabsubpart.sides.length; j++) {
        let nsubside = JSON.parse(JSON.stringify(slabsubpart.sides[j]));
        nsubside.index = nsubsides.length;
        resetsubpartsideitems(nsubside);   
        nsubsides.push(nsubside);
    }
}

function subpartsideseams(side) {
    var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    var nseams = [];
    for (let j = 0; j < side.seams.length; j++) {
        let sideseam = JSON.parse(JSON.stringify(side.seams[j]));
        let sx1 = sideseam.x1, sy1 = sideseam.y1, sx2 = sideseam.x2, sy2 = sideseam.y2;
        let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
        if (isinline) { nseams.push(sideseam);}       
    }
    side.seams = nseams;
}
function subpartsidecutouts(side) {   
    var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    var ncutouts = [];
    for (let j = 0; j < side.cutouts.length; j++) {
        let cutout = JSON.parse(JSON.stringify(side.cutouts[j]));
        let sx1 = cutout.x, sy1 = cutout.y, w = cutout.w, h = cutout.h;
        let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
        if (isinline) {ncutouts.push(cutout);}      
    }
    side.cutouts = ncutouts;
}
function subpartsideshapes(side, type) {
    var x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12, x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    var nsideshapes = [];
    for (let j = 0; j < side.sideshapes.length; j++) {
        let shapeside = JSON.parse(JSON.stringify(side.sideshapes[j]));
        let sx1 = shapeside.x, sy1 = shapeside.y, w = shapeside.w, h = shapeside.h;       
        let isinline = ispointinline(x11, y11, x12, y12, sx1, sy1);
        if (isinline) {            
            shapeside.dw = calchyplen(x11, y11, sx1, sy1);
            nsideshapes.push(shapeside);
        }       
    }
    side.sideshapes = nsideshapes;
}
function resetsubpartsideitems(subside) {
    for (var j = 0; j < subside.edges.length; j++) {
        subside.edges[j].sideindex = subside.index;
    }
    for (var j = 0; j < subside.corners.length; j++) {
        subside.corners[j].sideindex = subside.index;
    }
    for (var j = 0; j < subside.cutouts.length; j++) {
        subside.cutouts[j].sideindex = subside.index;
    }
    for (var j = 0; j < subside.sideshapes.length; j++) {
        subside.sideshapes[j].sideindex = subside.index;
    }
    for (var j = 0; j < subside.seams.length; j++) {
        subside.seams[j].sideindex = subside.index;
    }
}
function mergeslabparts(index, spseamindex, spindex, sideindex) {
    $("#slabpartouter" + index).remove();
    slabparts[index].isactive = 0;
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {
            if (slabparts[i] != undefined) {
                $("#slabpartouter" + i).remove();
                slabparts[i].isactive = 0;
            }
        }
    }
}
function resetslabpartseams(index, spindex) {
    let slabpart = slabparts[index];
    for (let i = 0; i < slabpart.sides.length; i++) {
        unsplitshapesideseams(slabpart.sides[i].spsideindex, spindex);
    }
}

function ondeleteslabpart(index, sideindex) {
    removeshapetools();
    let spindex = slabparts[index].spindex;
    let spseamindex = slabparts[index].spseamindex;
    let spcount = shapeslabpartcount(spindex);
    deleteslabparts(spindex);//subparts with shape index
    deleteslabsplashs1(spindex); //slabsplashs with shape index  
    unsplitshapeseams(spindex);    
    ActionRemoveSlabPart();
}
function ondeleteshapeslabparts(spindex) {
    deleteslabparts(spindex);//subparts with shape index
    deleteslabsplashs1(spindex); //subparts with shape index
    ActionRemoveSlabPart();
}
function deleteshapeslabparts(spindex) {
    deleteslabparts(spindex);//subparts with shape index
    deleteslabsplashs1(spindex); //subparts with shape index   
}
function deleteslabparts(spindex) {
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == spindex && slabparts[i].isactive == 1) {
            $("#slabpartouter" + i).remove();
            slabparts[i].isactive = 0;
            removeslabpartclipimage(i, spindex);
        }
    }
}
function drawslabparts(matid) {
    for (var i = 0; i < slabparts.length; i++) {
        //  console.log(JSON.stringify(slabparts[i]));      
        if (slabparts[i].materialid == matid) {
            //  if (slabparts[i].spindex != i) { slabparts[i].spindex = i; }
            if (slabparts[i].isactive == 1) { drawslabpart(i,'drawslabparts'); }
        }
    }
}
function drawslabpart(index, source) {    
    initshapegroups(index, 'slabpart', 'drawslabpart');
    shapesides('drawslabpart');
    transformshape();    
    if (shape.angle != 0) { rotateshape(0, index, shape.angle); }   
    if (layoutmode == 2) { onsetslabpartclipimage(index); }
}

function unhighlightareaslabparts(index) {
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].areaid == area.ID && slabparts[i].isactive == 1) {
            unhighlightslabpart(i, 'blue');
        } else {
            unhighlightslabpart(i, slabparts[i].color);
        }
    }
}
function unhighlightslabparts(sindex, color) {
    for (var i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == sindex && slabparts[i].isactive == 1) {
            unhighlightslabpart(i, color);
        }
    }
}
function unhighlightslabpart(index, color) {
    let slabpart = slabparts[index];
    for (let i = 0; i < slabpart.sides.length; i++) {
        let sidepathindex = i + "" + index;
        $("#slabpartsidepath" + sidepathindex).attr("style", "fill:" + color + ";fill-opacity:0.3;");
    }
}
function setslabpartsclipimages(matid) {   
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].materialid == matid && slabparts[i].isactive == 1) {
            onsetslabpartclipimage(i);
        }
    }
}
function onsetshapeslabpartsclipimage(sindex) {
    for (let i = 0; i < slabparts.length; i++) {
        if (slabparts[i].spindex == sindex && slabparts[i].isactive == 1) {
            onsetslabpartclipimage(i);
        }
    }  
}
function onsetslabpartclipimage(index) {    
    let spindex = slabparts[index].spindex;
    setshapepathopacity(spindex,"0");
    setslabppartpathopacity(index, "0"); 
    //1. Define the SVG clipPath
    setslabpartclippath(index, spindex);
    //2. Render the <rect> in <defs> with a <use> element
    setslabpartclipimage(index, spindex);
    //3. Add the image, which is clipped via the clip-path attribute    
}
function setslabpartclippath(index, spindex) {
    let spclippathindex = index + "" + spindex;
    let spclippath = maskdefs.select("#spclippath" + spclippathindex);
    if (spclippath.empty()) { spclippath = maskdefs.append("clipPath").attr("id", "spclippath" + spclippathindex); } else { spclippath.selectAll('*').remove(); }
    let slabpartshapeg = d3.select("#" + "slabpart" + index);
    let slabpartshapegtransform = slabpartshapeg.attr("transform");
    for (let i = 0; i < slabparts[index].sides.length; i++) {
        setslabpartsideclippath(i, index, spindex, slabpartshapegtransform);
    }
}
function setslabpartsideclippath(sideindex, index, spindex, slabpartshapegtransform) {
    let side = slabparts[index].sides[sideindex];
    let x11 = side.x11, y11 = side.y11, x12 = side.x12, y12 = side.y12;
    let x21 = side.x21, y21 = side.y21, x22 = side.x22, y22 = side.y22;
    let sidepath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    sidepath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let spclippathindex = index + "" + spindex;
    let spclippath = d3.select("#spclippath" + spclippathindex);
    if (!spclippath.empty()) {
        sideclipathindex = sideindex + "" + spclippathindex;
        let spclipsubpath = spclippath.append("path").attr("id", "sidepath" + sideclipathindex).attr("d", sidepath);
        spclipsubpath.attr("transform", slabpartshapegtransform);
    }
}
function setslabpartclipimage(index, spindex) {
    //1. slab bbox
    let slabindex = slabparts[index].slabindex;   
    let mslabpathg = d3.select("#mslabpathg" + slabindex);
    let mslabpathgnode = mslabpathg.node().getBBox(), mslabgx = mslabpathgnode.x, mslabgy = mslabpathgnode.y, mslabgw = mslabpathgnode.width, mslabgh = mslabpathgnode.height;
    //2.calculate clip image x and y from slab top left to slabpart top left.
    let slabclipimgx = -slabparts[index].tx + mslabgx, slabclipimgy = -slabparts[index].ty + mslabgy;
    let shapeslabimagesg = d3.select("#shapeslabimgsg" + spindex);
    if (!shapeslabimagesg.empty()) {
        let slabpartshapeg = d3.select("#" + "slabpart" + index);        
        let shapegnode = slabpartshapeg.node();
        let sx = shapegnode.getBBox().x + shapegnode.getBBox().width / 2; sy = shapegnode.getBBox().y + shapegnode.getBBox().height / 2;
        let npt = [sx.toFixed(), sy.toFixed()];
        let simageangle =  - slabparts[index].angle;
        //shapeslabimagesg.attr("transform", "rotate(" + shape.angle + "," + npt + ")");
        let shapeslabimgindex = index + "" + spindex;
        //let shapeslabimgeg = shapeslabimagesg.select("#shapeslabimgeg" + shapeslabimgindex);
        //if (shapeslabimgeg.empty()) { shapeslabimgeg = shapeslabimagesg.append("g").attr("id", "shapeslabimgeg" + shapeslabimgindex); }
        let shapeslabimg = shapeslabimagesg.select("#shapeslabimg" + shapeslabimgindex);
        if (shapeslabimg.empty()) { shapeslabimg = shapeslabimagesg.append("svg:image").attr("id", "shapeslabimg" + shapeslabimgindex); }
        shapeslabimg.attr("xlink:href", slabs[slabindex].path).attr("x", slabclipimgx).attr("y", slabclipimgy).attr("width", mslabgw).attr("height", mslabgh).attr("preserveAspectRatio", "xMidYMid slice")
        .attr("clip-path", "url(#spclippath" + shapeslabimgindex + ")");        
        shapeslabimg.attr("transform", "rotate(" + simageangle + "," + npt + ")");        
    }
}
function removeslabpartclipimage(index, spindex) {
    let spclippathindex = index + "" + spindex;
    let spclippath = d3.select("#spclippath" + spclippathindex);
    if (!spclippath.empty()) { spclippath.remove(); }
    let shapeslabimgindex = index + "" + spindex;
    let shapeslabimg = d3.select("#shapeslabimg" + shapeslabimgindex);
    if (!shapeslabimg.empty()) { shapeslabimg.remove(); }
}

