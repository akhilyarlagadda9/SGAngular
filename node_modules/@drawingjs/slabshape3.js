/*init reset methods*/
function initMaterial(id, index) {    
    materialid = id;
    initmatslabgroups(id);
    setslabshapes(id);
    drawslabshapes(id);
    setslabparts(id);
    setslabsplashs(id);
    if (slaby > lheight) { lheight = slaby + spdy; msvg.style("height", lheight); }
    slabpartsgrect.attr("x", zscalex).attr("y", zscaley).attr("width", lwidth).attr("height", lheight).style("fill", "lightblue").style("fill-opacity", "0.1");
    //lzoomsvg();
    togglelayoutmode();
    setslabshapepathimages();
}
function setslabshapes(matid) {
    slaby = 0;
    for (let i = 0; i < slabs.length; i++) {        
        if (slabs[i].materialid == matid && slabs[i].isactive == 1) {
            slab = slabs[i]; slab.x = 10; slaby += (slab.h * scale) + (3 * slab.dx);
            let slabxpos = (slab.x + slab.w * scale + 20);
            if (slabpartx < slabxpos) { slabpartx = slabxpos; }
        }
    }
}
function initmatslabs(material) {
    if (material.SlabList.length > 0) {       
        for (let i = 0; i < material.SlabList.length; i++) {
            let matSlab = material.SlabList[i];
            setmatslabs(matSlab, material.Color);
        }
    }
}
function setmatslabs(matSlab, matcolor) {  
    let noofslabs = parseInt(matSlab.NoOfSlabs);    
    for (let i = 0; i <noofslabs; i++) {
        setmatslab(matSlab, matcolor);
    }   
}
function setmatslab(matSlab, matcolor) {   
    slab = { id: 0, index: slabs.length, materialid: 0, extslabno: '', slabid: 0, color: '', blockno: '', seqno: '', path: '', x: 10, y: slaby, w: 0, h: 0, dx: 10, angle: 0, cw: 15, ch: 15, cr: 15, markers: [], isactive: 1 };
    slabs.push(slab);
    slab.id = matSlab.ID;
    slab.extslabno = matSlab.ExtSlabNo != null ? matSlab.ExtSlabNo : '';
    slab.materialid = matSlab.MaterialID;
    slab.color = matcolor != null ? matcolor : '';
    slab.blockno = matSlab.BlockNo != null ? matSlab.BlockNo : '';
    slab.w = matSlab.Width;
    if (slab.extslabno.length > 0) { slab.h = matSlab.Height; } else { slab.h = matSlab.Length; }
    slab.x = (lwidth - slab.w * scale) / 2;
    slaby += (slab.h * scale) + (3 * slab.dx);    
    if (matSlab.Path != null && matSlab.Path.length > 0) {       
        let slabimgpath = contentPath + "Inventory/";       
        if (matSlab.Path.toLowerCase().indexOf(matcolor.toLowerCase()) == -1) { slabimgpath = slabimgpath + matcolor + "/"; }
        slabimgpath = slabimgpath + matSlab.Path;
        if (slabimgpath.indexOf('.jpg') == -1) { slabimgpath = slabimgpath + '.jpg'; }
        if (qsverifyurl(slabimgpath)) {slab.path = slabimgpath;}
    }
}
/*Event functions/delegates*/
function onslabrectshape() {
    removeshapecontrols();
    d3.event.stopPropagation();
    var m = d3.mouse(this);
    var slabindex = parseInt(this.getAttribute("slabindex"));
    slab = slabs[slabindex];
    if (shape.mode == 'shape') {       
        if (shape.materialid == 0) { drawmessagecontrols(shape.index, m[0], m[1], 'Material is not added to Part!', 'slabpart'); }
        else if (shape.materialid == slab.materialid) {
            onsetslabpart(m[0], m[1], 'onslabrectshape');
        } else { drawmessagecontrols(shape.index, m[0], m[1], 'Material Mismatch!', 'slabpart'); }
    }
    setdrawmode(0);
}
function onslabmouseup() {
    console.log('onslabmouseup', d3.event.sourceEvent)
}
function onslabmouseenter() {
    if (bdrag && shape.mode == 'slabpart') {
        let slabindex = this.getAttribute("slabindex");
        slab = slabs[slabindex];
        shape.slabid = slab.id;
        shape.slabindex = slab.index;
    }
}
function onslabmouseleave() {
    console.log('dragleave', d3.event.sourceEvent.srcElement)
}
function checkslabbounds(ndx, ndy) {
    // Define boundary 
    for (let i = 0; i < slabs.length; i++) {
        let slabrect = d3.select("#slabrect" + slabs[i].index);
        //console.log(slabrect);
        var rectDimensions = slabrect.node().getBBox();
        var xmin = rectDimensions.x;
        var ymin = rectDimensions.y;
        var xmax = rectDimensions.x + rectDimensions.width;
        var ymax = rectDimensions.y + rectDimensions.height;

        var x1 = ndx;
        var y1 = ndy;
        var x2 = ndx + 10;
        var y2 = ndy + 10;
        if (x1 >= xmin && x1 <= xmax && y1 >= ymin && y1 <= ymax) {
            console.log('in slab rect')
        } else {
            console.log('not in slab rect')
        }
    }
    d3.event.sourceEvent.stopPropagation();
}
/*Drawing methods*/
function drawslabshapes(matid) {
    for (let i = 0; i < slabs.length; i++) {
        if (slabs[i].materialid == matid && slabs[i].isactive == 1) {
            drawslabrectshape(i);
        }
    }
}
function drawslabrectshape(index) {
    slab = slabs[index];
    drawslabrect(index);
    drawslabrectmarkers(index);
}
function drawslabrect(index) {    
    if (slab.w > 0 && slab.h > 0) {
        mslabg = mslabsg.select("#mslabg" + slab.index); if (mslabg.empty()) { mslabg = mslabsg.append("g").attr("id", "mslabg" + slab.index); }
        mslabg.selectAll('*').remove();
        mslabpathg = mslabg.select("#mslabpathg" + slab.index); if (mslabpathg.empty()) { mslabpathg = mslabg.append("g").attr("id", "mslabpathg" + slab.index); }
        mslabmarkersg = mslabg.select("#mslabmarkersg" + slab.index); if (mslabmarkersg.empty()) { mslabmarkersg = mslabg.append("g").attr("id", "mslabmarkersg" + slab.index); }
        let slabrect = mslabpathg.select("#slabrect" + slab.index);
        if (slabrect.empty()) { slabrect = mslabpathg.append("rect").attr("id", "slabrect" + slab.index); }
        slabrect.attr("x", slab.x).attr("y", slab.y + 2 * slab.dx).attr("width", slab.w * scale).attr("height", slab.h * scale).attr("slabindex", slab.index).attr("class", "slabshape")
        .on("click", onslabrectshape).on("mouseenter", onslabmouseenter)
        if (layoutmode == 2) { drawslabrectimage(index); } else { slabrect.style("fill-opacity", "0.7"); }
       
    }
}
function drawslabrectimage(index) {
    if (slab.path.length > 0) {
        let slabptrnimmage = mslabpathg.select("#slabptrnimg" + slab.index);
        if (slabptrnimmage.empty()) {
            slabptrnimmage = mslabpathg.append("image").attr("id", "slabptrnimg" + slab.index).attr("slabindex", slab.index).attr("x", slab.x).attr("y", slab.y + 2 * slab.dx).attr("width", slab.w * scale)
            .attr("height", slab.h * scale).attr("preserveAspectRatio", "xMidYMid slice").attr("xlink:href", slab.path).on("click", onslabrectshape).on("mouseenter", onslabmouseenter);
        }
    }
}
function drawslabrectmarkers() {
    if (slab.w > 0 && slab.h > 0) {
        var index = 0, x1 = 0, y1 = 0, x2 = 0, y2 = 0, w = 0, h = 0, dx = 0, mx = 0, my = 0, mtext = '', mtlen = 0;
        index = slab.index + "1";
        dx = slab.dx, w = slab.w * scale, h = slab.h * scale, x1 = slab.x, y1 = slab.y + dx, x2 = x1 + w, y2 = y1;
        if (slab.color.length > 0) { mtext = slab.color + "-"; }
        if (slab.extslabno.length > 0) { mtext = slab.extslabno + "-"; }
        if (slab.blockno.length > 0) { mtext = slab.blockno + "-"; }
        mtext += w / scale + '"';
        if (slab.extslabno != null && slab.extslabno.length > 0) { mtext = "#" + slab.extslabno + "-" + mtext; }
        if (!mslabmarkersg.empty()) {
            mslabmarkerg = mslabmarkersg.select("#mslabmarkerg" + index);
            if (mslabmarkerg.empty()) { mslabmarkerg = mslabmarkersg.append("g").attr("id", "mslabmarkerg" + index); }
            var markerline = mslabmarkerg.select("#mline" + index);
            if (markerline.empty()) { markerline = mslabmarkerg.append("line").attr("id", "mline" + index); }
            markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "arrow").attr("marker-start", "url(#triangle-start)").attr("marker-end", "url(#triangle-end)");

            var markertext = mslabmarkerg.select("#mtext" + index);
            if (markertext.empty()) { markertext = mslabmarkerg.append("text").attr("id", "mtext" + index).text(mtext); }
            mtlen = markertext.node().getComputedTextLength();
            mx = (x1 + w / 2) - (mtlen / 2), my = y1;
            markertext.attr("x", mx).attr("y", my);

            mx = mx + mtlen + dx;
            //var markerupload = mslabmarkerg.select("#markerupload" + index);
            //if (markerupload.empty()) { markerupload = mslabmarkerg.append("text").attr("id", "markerupload" + index); }
            //markerupload.attr("x", mx).attr("y", my).text("Upload").on("click", onslabimageupload);

            index = index + "2", x1 = x1 + w + dx, y1 = y1 + dx, x2 = x1, y2 = y1 + h;
            markerline = mslabmarkerg.select("#mline" + index);
            if (markerline.empty()) { markerline = mslabmarkerg.append("line").attr("id", "mline" + index); }
            markerline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", "arrow").attr("marker-start", "url(#triangle-start)").attr("marker-end", "url(#triangle-end)");

            mtext = h / scale + '"';
            markertext = mslabmarkerg.select("#mtext" + index);
            if (markertext.empty()) { markertext = mslabmarkerg.append("text").attr("id", "mtext" + index).text(mtext); }
            mx = x2, my = y1 + h / 2;
            markertext.attr("x", mx).attr("y", my);
        }
    }
}
function onslabimageupload() {
    //alert('image upload');
}
function deleteslab() {

}
