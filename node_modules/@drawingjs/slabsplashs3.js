function initslabsplashgroups(index) {
    slabsplashouterg = slabsplashsg.select("#slabsplashouterg" + index);
    if (slabsplashouterg.empty()) { slabsplashouterg = slabsplashsg.append("g").attr("id", "slabsplashouterg" + index).attr("index", index); }
    slabsplashg = slabsplashouterg.select("#slabsplashg" + index);   
    if (slabsplashg.empty()) { slabsplashg = slabsplashouterg.append("g").attr("id", "slabsplashg" + index); }
    slabsplashouterg.call(slabsplashdrag);
}
function setslabsplashs(matid) {
    for (var i = 0; i < slabsplashs.length; i++) {
        // console.log(slabsplashs[i].materialid, matid, slabsplashs[i].isactive);
        if (slabsplashs[i] != undefined && slabsplashs[i].materialid == matid) {
            if (slabsplashs[i].isactive == 1) { onsetslabsplash(i); }
        }
    }
}
function slabsplashindex(shapesplindex, shapesideindex, spindex) {
    let index = -1;
    for (let i = 0; i < slabsplashs.length; i++) {       
        if (slabsplashs[i].shapesplindex == shapesplindex && slabsplashs[i].shapesideindex == shapesideindex && slabsplashs[i].spindex == spindex && slabsplashs[i].isactive == 1) { index = i; break; }
    }
    return index;
}
function shapeslabsplashcount(shapesplindex, shapesideindex, spindex) {
    let spcount = 0;
    for (let i = 0; i < slabsplashs.length; i++) {        
        if (slabsplashs[i].shapesplindex == shapesplindex && slabsplashs[i].shapesideindex == shapesideindex && slabsplashs[i].spindex == spindex && slabsplashs[i].isactive == 1) { 
            spcount++;
        }
    }   
    return spcount;
}

function onsetslabsplash(index) { 
    slabsplashshape(index);
    drawslabsplash(index);
    onrotateslabsplash(-1, index, 0);
    onsetslabsplashseams(index);
    ActionUpdateSlabPartSplash();
    if (layoutmode == 2) { onsetslabsplashclipimage(index); }
}
function setslabpartsplashs(index) {
    let slabpart = slabparts[index];
    let splx = slab.x + 5, sply = (slab.y + 2 * slab.dx);
    for (let j = 0; j < slabpart.sides.length; j++) {
        for (let k = 0; k < slabpart.sides[j].splashs.length; k++) {
            let slabpartsplash = JSON.parse(JSON.stringify(slabpart.sides[j].splashs[k]));
            if (slabpartsplash.isactive == 1) {
                slabpartsplash.x = splx, slabpartsplash.y = sply;                
                setslabpartsplash(slabpartsplash, slabpart.spindex);
                sply += (slabpartsplash.height * scale) + slab.dx;
            }
        }
        slabpart.sides[j].splashs = [];
    }
}
function setslabpartsplash(slabpartsplash, spindex) {
    var index = slabsplashindex(slabpartsplash.index, slabpartsplash.sideindex, spindex);  
    if (index == -1) {
        index = slabsplashs.length; slabsplashs.push(slabpartsplash);
        setslabsplash(index, 0, 0, slabpartsplash.index, slabpartsplash.sideindex, spindex);
        slabsplashshape(index);
        drawslabsplash(index);
        onrotateslabsplash(-1, index, 0);
        onsetslabsplashseams(index);
        ActionUpdateSlabPartSplash();
    }
}
function setslabsplash(index, spx, spy, splashindex, sideindex, spindex) {
    slabsplash = slabsplashs[index];
    slabsplash.index = index; //slabsplash index
    slabsplash.spindex = spindex;  //shape reference index 
    slabsplash.shapesplindex = splashindex;  //shape splash reference index 
    slabsplash.shapesideindex = sideindex;  //shape side reference index 
    slabsplash.slabid = slab.id;
    slabsplash.materialid = slab.materialid;
    slabsplash.slabindex = slab.index;
    slabsplash.spseamindex = -1;
    slabsplash.mode = 'slabsplash';
    slabsplash.color = shape.color;
    slabsplash.isactive = 1;
    if (spx > 0 && spy > 0) { slabsplash.x = spx, slabsplash.y = spy, slabsplash.tx = 0, slabsplash.ty = 0; }
    slabsplashs[index] = slabsplash;
}
function setslabsplashsideedge(index, splashindex, edgetypeid, edgetype) {
    let slabsplash = slabsplashs[splashindex];
    let spledge = slabsplash.edges[index];
    spledge.type = edgetype, spledge.typeid = edgetypeid, spledge.text = edgetype;
}
function slabsplashshape(index) {
    let slabsplash = slabsplashs[index];
    let x = slabsplash.x, y = slabsplash.y, w = slabsplash.width * scale, h = slabsplash.height * scale;
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x11 = x, y11 = y, x12 = x + w, y12 = y;
    let npt1 = calcTranslationExact1(-h, x11, y11, x12, y12);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x21 = x11 + dx1, y21 = y11 + dy1, x22 = x12 + dx1, y22 = y12 + dy1;
    slabsplash.x11 = x11, slabsplash.y11 = y11, slabsplash.x12 = x12, slabsplash.y12 = y12;
    slabsplash.x21 = x21, slabsplash.y21 = y21, slabsplash.x22 = x22, slabsplash.y22 = y22;   
}
function slabsplashshape1(slabsplash) {
    let x = slabsplash.x, y = slabsplash.y, w = slabsplash.width * scale, h = slabsplash.height * scale;
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x11 = x, y11 = y, x12 = x + w, y12 = y;
    let npt1 = calcTranslationExact1(-h, x11, y11, x12, y12);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x21 = x11 + dx1, y21 = y11 + dy1, x22 = x12 + dx1, y22 = y12 + dy1;
    slabsplash.x11 = x11, slabsplash.y11 = y11, slabsplash.x12 = x12, slabsplash.y12 = y12;
    slabsplash.x21 = x21, slabsplash.y21 = y21, slabsplash.x22 = x22, slabsplash.y22 = y22;
}
function onslabsplash() {
    d3.event.stopPropagation();
    let index = parseInt(this.getAttribute("index"));
    let sindex = parseInt(this.getAttribute("sindex"));
    let sideindex = parseInt(this.getAttribute("sideindex"));
    initslabsplashgroups(index);
    let m = d3.mouse(this);   
    if (drawmode == 7) {
        onsetslabsplashseam(m[0], m[1], -1, index, sideindex, sindex);
        setdrawmode(0);
    }
}
function onslabsplashcontextmenu() {
    removeshapecontrols();
    d3.event.preventDefault();
    var index = parseInt(this.getAttribute("index"));
    initslabsplashgroups(index);
    var m = d3.mouse(this);
    drawslabsplashcontrols(index, m[0], m[1]);
}
function drawslabsplash(index) {
    initslabsplashgroups(index);
    let slabsplash = slabsplashs[index];
    let sideindex = slabsplash.shapesideindex, sidecode = slabsplash.sidecode, width = slabsplash.width, height = slabsplash.height, type = slabsplash.type, mtext = width + " x " + height;
    let x11 = slabsplash.x11, y11 = slabsplash.y11, x12 = slabsplash.x12, y12 = slabsplash.y12;
    let x21 = slabsplash.x21, y21 = slabsplash.y21, x22 = slabsplash.x22, y22 = slabsplash.y22;
    let spindex = slabsplash.spindex;
    let edge1type = slabsplash.edges[0].type, edge2type = slabsplash.edges[1].type, edge3type = slabsplash.edges[2].type, edge4type = slabsplash.edges[3].type;
    slabsplashg.selectAll('*').remove();
    drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext, spindex);
    drawslabsplashline(0, index, sideindex, sidecode, x11, y11, x21, y21, edge1type);
    drawslabsplashline(1, index, sideindex, sidecode, x11, y11, x12, y12, edge2type);
    drawslabsplashline(2, index, sideindex, sidecode, x21, y21, x22, y22, edge3type);
    drawslabsplashline(3, index, sideindex, sidecode, x12, y12, x22, y22, edge4type);
    //transformslabsplash(index);
    if (layoutmode == 2) { onsetslabsplashclipimage(index); }
}
function drawslabsplashline(lineindex, splashindex, sideindex, sidecode, x1, y1, x2, y2, edgetype) {
    var eclass = sideedgeclass(edgetype);
    var spgindex = splashindex;
    var splindex = splashindex + "" + lineindex;
    var splline = slabsplashg.select("#slabsplash" + splindex);
    if (splline.empty()) { splline = slabsplashg.append("line").attr("id", "slabsplash" + splindex); }
    splline.attr("x1", x1).attr("y1", y1).attr("x2", x2).attr("y2", y2).attr("class", eclass).attr("index", lineindex).attr("splashindex", splashindex).attr("edgetype", edgetype);
}
function drawslabsplashpath(index, sideindex, sidecode, type, x11, y11, x21, y21, x12, y12, x22, y22, mtext, spindex) {
    let spath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    spath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    let sclass = 'shapesplash', smode = 'slabsplash';  
    let splashpath = slabsplashg.select("#slabsplashpath" + index);
    if (splashpath.empty()) { splashpath = slabsplashg.append("path").attr("id", "slabsplashpath" + index); }
    splashpath.attr("index", index).attr("sideindex", sideindex).attr("sidecode", sidecode).attr("sindex", spindex).attr("smode", smode).attr("d", spath);
    splashpath.attr("style", "fill:" + shape.color).style("fill-opacity", "0.2");
    splashpath.on("click", onslabsplash).on("contextmenu", onslabsplashcontextmenu);
    //var npt = calcontrolcenterpoint(slabsplashg);
    //var mtx = npt.ctx, mty = npt.cty + 3;
    //var splashtext = slabsplashg.select("#slabsplashtext" + splindex);
    //if (splashtext.empty()) { splashtext = slabsplashg.append("text").attr("id", "slabsplashtext" + splindex); }
    //splashtext.attr("x", mtx).attr("y", mty).text(mtext + '"');
}
function slabsplashdragstarted() {
    if (d3.event.sourceEvent.srcElement.tagName == 'path') {
        var index = parseInt(this.getAttribute("index"));
        initslabsplashgroups(index);
        var slabsplash = slabsplashs[index];
        dragdx = d3.event.x - slabsplash.x; dragdy = d3.event.y - slabsplash.y;
        bdrag = true;
    }
    removeshapecontrols();
}
function slabsplashdragged() {
    if (bdrag) {
        var index = parseInt(this.getAttribute("index"));
        var slabsplash = slabsplashs[index];      
        this.x = this.x || slabsplash.tx;
        this.y = this.y || slabsplash.ty;
        this.x += d3.event.dx;
        this.y += d3.event.dy;
        slabsplash.tx = this.x, slabsplash.ty = this.y;
        let spx = d3.event.x - dragdx, spy = d3.event.y - dragdy;       
        slabsplash.x = spx, slabsplash.y = spy;
        if (drawmode != 7) { slabsplashouterg.attr("pointer-events", "none"); }
        onsetslabsplash(index);
        //transformslabsplash(index);
    }
}
function slabsplashdragended() {
    if (bdrag) {
        slabsplashouterg.attr("pointer-events", "auto");
        bdrag = false;
        slabsplashouterg
        dragdx = 0, dragdy = 0;
        ActionUpdateSlabPartSplash();
    }
}
function transformslabsplash(index) {
    //var slabsplash = slabsplashs[index];
    //var npt = [slabsplash.tx, slabsplash.ty];
    //slabsplashouterg.attr('transform', 'translate(' + npt + ')');
}
function onrotateslabsplash(type, index, angle) {   
    var npt = [];
    var slabsplashg = slabsplashsg.select("#slabsplashg" + index);
    if (!slabsplashg.empty()) {
        var slabsplash = slabsplashs[index];
        if (type == 0) { slabsplash.angle = angle; }
        else if (type == 1) { slabsplash.angle += angle; }
        else if (type == -1) { slabsplash.angle -= angle; }
        var gnode = slabsplashg.node();
        var sx = gnode.getBBox().x + gnode.getBBox().width / 2; sy = gnode.getBBox().y + gnode.getBBox().height / 2;
        var npt = [sx.toFixed(), sy.toFixed()];
        slabsplashg.attr("transform", "rotate(" + slabsplash.angle + "," + npt + ")");
        $('#slabsplashctlinputangle' + index).val(slabsplash.angle);
    }
}
function ondeleteslabsplash(index) {
    removeshapecontrols();
    var slabsplash = slabsplashs[index];
    deleteslabsplashs(slabsplash.shapesplindex, slabsplash.shapesideindex, slabsplash.spindex);
    ActionUpdateSlabPartSplash();
}
function deleteslabsplashs1(spindex) {
    for (let i = 0; i < slabsplashs.length; i++) {
        if (slabsplashs[i].spindex == spindex && slabsplashs[i].isactive == 1) {
            slabsplashs[i].isactive = 0;
            deleteslabsplash(i);
        }
    }
    ActionUpdateSlabPartSplash();
}
function deleteslabsplashs(shapesplindex, shapesideindex, spindex) {
    for (let i = 0; i < slabsplashs.length; i++) {
        if (slabsplashs[i].shapesplindex == shapesplindex && slabsplashs[i].shapesideindex == shapesideindex && slabsplashs[i].spindex == spindex && slabsplashs[i].isactive == 1) {
            slabsplashs[i].isactive = 0;
            deleteslabsplash(i);
        }
    }
}
function deleteslabsplash(index) {
    if (slabsplashsg != undefined) {
        slabsplashouterg = slabsplashsg.select("#slabsplashouterg" + index);
        if (!slabsplashouterg.empty()) { slabsplashouterg.remove(); }
    }
}
function unhighlightslabsplashs(spindex, color) {
    //console.log(slabsplashs.length);
    for (let i = 0; i < slabsplashs.length; i++) {
        // console.log(spindex, color, slabsplashs[i].spindex, slabsplashs[i].isactive);
        if (slabsplashs[i] != undefined && slabsplashs[i].spindex == spindex && slabsplashs[i].isactive == 1) {
            unhighlightslabsplash(i, color);
        }
    }
}
function unhighlightslabsplash(index, color) {
    //console.log(spindex, color);
    let slabsplash = slabsplashs[index];   
    $("#slabsplashpath" + index).attr("style", "fill:" + color + ";fill-opacity:0.3");
}
function onsetslabsplashclipimage(index) {
    //let spindex = slabsplashs[index].spindex;
    ////setshapesplashpathopacity(spindex, "0");
    ////setslabsplashpathopacity(index, "0");
    ////1. Define the SVG clipPath
    //setslabsplashclippath(index, spindex);
    ////2. Render the <rect> in <defs> with a <use> element
    //setslabsplashclipimage(index, spindex);
    ////3. Add the image, which is clipped via the clip-path attribute  
}
function setslabsplashclippath(index, spindex) {
    let slabsplash = slabsplashs[index];
    let sideindex = slabsplash.shapesideindex, sidecode = slabsplash.sidecode, shapesplindex = slabsplash.shapesplindex, spseamindex = slabsplash.spseamindex;    
    let side = shapes[spindex].sides[sideindex];
    let splash = side.splashs[shapesplindex];
    let x = splash.x, y = splash.y, width = slabsplash.width * scale, height = slabsplash.height * scale, simageangle = slabsplash.angle;
    if (spseamindex != -1) { let splashseam = splash.seams[spseamindex]; if (splashseam != undefined) { x = splashseam.x1, y = splashseam.y1; } }

    let splashpath = shapesplabsplashpath(x, y, width, height);

    let slabsplashclippath = maskdefs.select("#slabsplashclippath" + index);
    if (slabsplashclippath.empty()) { slabsplashclippath = maskdefs.append("clipPath").attr("id", "slabsplashclippath" + index); } else { slabsplashclippath.selectAll('*').remove(); }
    
    let splashclippath = slabsplashclippath.append("path").attr("id", "splashpath" + index).attr("d", splashpath);
    if (simageangle != 0) {
        let npt = [(x + width / 2).toFixed(), (y + height / 2).toFixed()];
        splashclippath.attr("transform", "rotate(" + simageangle + "," + npt + ")");
    }    
}
function shapesplabsplashpath(x, y, w, h) {    
    let x11 = 0, y11 = 0, x12 = 0, y12 = 0, x21 = 0, y21 = 0, x22 = 0, y22 = 0;
    x11 = x, y11 = y, x12 = x + w, y12 = y;
    let npt1 = calcTranslationExact1(-h, x11, y11, x12, y12);
    let dx1 = npt1.dx, dy1 = npt1.dy;
    x21 = x11 + dx1, y21 = y11 + dy1, x22 = x12 + dx1, y22 = y12 + dy1;
    let splashpath = "M" + x11 + "," + y11 + "l" + (x12 - x11) + "," + (y12 - y11);
    splashpath += "l" + (x22 - x12) + "," + (y22 - y12) + "l" + (x21 - x22) + "," + (y21 - y22) + "z";
    return splashpath;
}

function setslabsplashclipimage(index, spindex) {
    let slabsplash = slabsplashs[index];
    let splx = slabsplash.x, sply = slabsplash.y, shapesplindex = slabsplash.shapesplindex, sideindex = slabsplash.shapesideindex, spseamindex = slabsplash.spseamindex,
        sidecode = slabsplash.sidecode, slabindex = slabsplash.slabindex, splh = slabsplash.height * scale, splw = slabsplash.width * scale, simageangle = slabsplash.angle;
    let side = shapes[spindex].sides[sideindex];
    let splash = side.splashs[shapesplindex];
    let x = splash.x, y = splash.y;
    if (spseamindex != -1) { let splashseam = splash.seams[spseamindex]; if (splashseam != undefined) { x = splashseam.x1, y = splashseam.y1; } }

    //1.slab top left - slab.x, slab.y
    let mslabpathg = d3.select("#mslabpathg" + slabindex);
    let mslabpathgnode = mslabpathg.node().getBBox(), mslabgx = mslabpathgnode.x, mslabgy = mslabpathgnode.y, mslabgw = mslabpathgnode.width, mslabgh = mslabpathgnode.height;   
    //2.calc dx, dy from slab top left to splash top left
    let dx = mslabgx - splx, dy = mslabgy - sply + splh;
    //3.shape splash x and y   
    let slabclipimgx = x + dx, slabclipimgy = y + dy;
    
    //4. offset slab image using dx, dy;
    let shapeslabimagesg = d3.select("#shapeslabimgsg" + spindex);
    let slabsplashimg = shapeslabimagesg.select("#slabsplashimg" + index);
    if (slabsplashimg.empty()) { slabsplashimg = shapeslabimagesg.append("svg:image").attr("id", "slabsplashimg" + index); }
    slabsplashimg.attr("xlink:href", slab.path).attr("x", slabclipimgx).attr("y", slabclipimgy).attr("width", mslabgw).attr("height", mslabgh).attr("preserveAspectRatio", "xMidYMid slice")
    .attr("clip-path", "url(#slabsplashclippath" + index + ")");
    if (simageangle != 0) {
        let npt = [(x + width / 2).toFixed(), (y + splh / 2).toFixed()];
        slabsplashimg.attr("transform", "rotate(" + -simageangle + "," + npt + ")");
    }
      
}
function removeslabsplashclipimage(index, spindex) {    
    let spclippath = d3.select("#slabsplashclippath" + index);
    if (!spclippath.empty()) { spclippath.remove(); }   
    let slabsplashimg = d3.select("#slabsplashimg" + index);
    if (!slabsplashimg.empty()) { slabsplashimg.remove(); }
}